PROJECT_ROOT: D:\workspace\trade_guardian
GENERATED_BY: merge_project.py
================================================================================


================================================================================
FILE_PATH: build_context.txt
================================================================================
create_tg_db.py:def init_db():
history_viewer.py:    def __init__(self, db_path="db/trade_guardian.db"):
history_viewer.py:    def get_latest_radar(self, symbol=None, limit=20):
history_viewer.py:    def _process_logic(self, df, latest_id, conn):
history_viewer.py:    def display(self, symbol=None):
merge_project.py:def is_text_file(file_path):
merge_project.py:def merge_project_files():
src\trade_guardian\app\cli.py:    DEFAULT_CONFIG,
src\trade_guardian\app\cli.py:def main():
src\trade_guardian\app\cli.py:    p_init.add_argument("--path", type=str, default=None, help="Output path (default: ./config/config.json)")
src\trade_guardian\app\cli.py:    p_scan.add_argument("--config", type=str, default=None, help="Config path (default: ./config/config.json)")
src\trade_guardian\app\cli.py:    p_scan.add_argument("--strategy", type=str, default="auto", help="Strategy name (default: auto)")
src\trade_guardian\app\cli.py:    p_scan.add_argument("--days", type=int, default=600)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--csv", type=str, default=None, help="Tickers csv path")
src\trade_guardian\app\cli.py:    p_scan.add_argument("--min-score", type=int, default=60)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--max-risk", type=int, default=70)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--limit", type=int, default=0)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--top", type=int, default=None, help="Only show top N sorted blueprints")
src\trade_guardian\app\cli.py:    p_scan.add_argument("--short-rank", type=int, default=None)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--min-short-dte", type=int, default=None)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--max-probe-rank", type=int, default=None)
src\trade_guardian\app\cli.py:        write_config_template(out, DEFAULT_CONFIG, overwrite=args.force)
src\trade_guardian\app\cli.py:        autogen_default = bool(DEFAULT_CONFIG.get("runtime", {}).get("autogen_config_if_missing", True))
src\trade_guardian\app\cli.py:        autogen = autogen_default
src\trade_guardian\app\cli.py:            write_config_template(cfg_path, DEFAULT_CONFIG, overwrite=False)
src\trade_guardian\app\cli.py:        cfg = load_config(cfg_path, DEFAULT_CONFIG)
src\trade_guardian\app\orchestrator.py:    def __init__(self, client, cfg: dict, policy, strategy=None):
src\trade_guardian\app\orchestrator.py:    def _get_universe(self) -> List[str]:
src\trade_guardian\app\orchestrator.py:    def scanlist(self, strategy_name: str = "auto", days: int = 600, 
src\trade_guardian\app\orchestrator.py:                ctx = self.client.build_context(ticker, days=days)
src\trade_guardian\app\orchestrator.py:    def _get_gate_status(self, row: ScanRow, bp: Optional[Blueprint], dna_type: str) -> str:
src\trade_guardian\app\orchestrator.py:    def _print_enhanced_blueprint(self, bp: Blueprint, row: ScanRow, dna: str):
src\trade_guardian\app\orchestrator.py:    def _get_temp(self, dna):
src\trade_guardian\app\orchestrator.py:    def plan(self, ctx: Context, row: ScanRow) -> Optional[Blueprint]:
src\trade_guardian\app\orchestrator.py:    def _load_strategy(self, name: str):
src\trade_guardian\app\persistence.py:    def __init__(self, db_path: str = None):
src\trade_guardian\app\persistence.py:    def save_scan_session(self, 
src\trade_guardian\app\persistence.py:    def check_iv_spikes(self, current_batch_id: int, threshold: float = 3.0) -> List[Tuple[str, float]]:
src\trade_guardian\app\persistence.py:    def get_latest_drift_1h(self, symbol: str) -> float:
src\trade_guardian\app\renderer.py:    def __init__(self, cfg=None, policy=None, hv_cache_path: Optional[str] = None):
src\trade_guardian\app\renderer.py:    def _sanitize_int(self, value: Any, default: int = 0) -> int:
src\trade_guardian\app\renderer.py:            if isinstance(value, list): return self._sanitize_int(value[0], default) if value else default
src\trade_guardian\app\renderer.py:            return default
src\trade_guardian\app\renderer.py:            return default
src\trade_guardian\app\renderer.py:    def render(self, 
src\trade_guardian\app\renderer.py:    def render_diagnostics(self, strict: List[ScanRow], **kwargs):
src\trade_guardian\app\renderer.py:    def _print_table(self, title: str, rows: List[ScanRow]):
src\trade_guardian\app\renderer.py:    def _print_details(self, title: str, rows: List[ScanRow]):
src\trade_guardian\app\renderer.py:    def _print_blueprints(self, title: str, rows: List[ScanRow]):
src\trade_guardian\domain\features.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\domain\features.py:    def _eligible_points(term: List[TermPoint], min_dte: int) -> List[TermPoint]:
src\trade_guardian\domain\features.py:    def _baseline_iv(term: List[TermPoint], fallback_iv: float) -> float:
src\trade_guardian\domain\features.py:    def build(self, term: List[TermPoint], hv: HVInfo, rank: int) -> Dict[str, object]:
src\trade_guardian\domain\hv.py:    def __init__(self, client: SchwabClient, cache: JsonDailyCache):
src\trade_guardian\domain\hv.py:    def get_hv(self, symbol: str) -> HVInfo:
src\trade_guardian\domain\models.py:    meta: Dict[str, Any] = field(default_factory=dict)
src\trade_guardian\domain\models.py:    legs: List[OrderLeg] = field(default_factory=list)
src\trade_guardian\domain\policy.py:    def probe_ranks(self) -> List[int]:
src\trade_guardian\domain\registry.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\domain\registry.py:    def get(self, name: str):
src\trade_guardian\domain\registry.py:        if n in ("auto", "smart", "default"):
src\trade_guardian\domain\scoring.py:    def __init__(self, rules: ScoringRules):
src\trade_guardian\domain\scoring.py:    def _hv_points(self, hv_rank: float) -> int:
src\trade_guardian\domain\scoring.py:    def score_calendar(self, regime: str, curvature: str, edge: float, hv_rank: float) -> tuple[int, ScoreBreakdown]:
src\trade_guardian\infra\cache.py:    def __init__(self, path: str):
src\trade_guardian\infra\cache.py:    def _load(self):
src\trade_guardian\infra\cache.py:    def _save(self):
src\trade_guardian\infra\cache.py:    def _today() -> str:
src\trade_guardian\infra\cache.py:    def get(self, key: str) -> Optional[dict]:
src\trade_guardian\infra\cache.py:    def set(self, key: str, value: dict) -> None:
src\trade_guardian\infra\cache.py:        self._data.setdefault("items", {})[key] = value
src\trade_guardian\infra\config.py:DEFAULT_CONFIG: Dict[str, Any] = {
src\trade_guardian\infra\config.py:def _deep_merge(a: Dict[str, Any], b: Dict[str, Any]) -> Dict[str, Any]:
src\trade_guardian\infra\config.py:def load_config(path: str, default_cfg: Dict[str, Any]) -> Dict[str, Any]:
src\trade_guardian\infra\config.py:        return dict(default_cfg)
src\trade_guardian\infra\config.py:        return dict(default_cfg)
src\trade_guardian\infra\config.py:    return _deep_merge(default_cfg, user_cfg)
src\trade_guardian\infra\config.py:def write_config_template(path: str, default_cfg: Dict[str, Any], overwrite: bool = False) -> None:
src\trade_guardian\infra\config.py:        json.dump(default_cfg, f, indent=2, ensure_ascii=False)
src\trade_guardian\infra\config.py:def merge_config_paths(cfg: Dict[str, Any], root: str, csv_override: Optional[str]) -> Dict[str, Any]:
src\trade_guardian\infra\config.py:    out.setdefault("paths", {})
src\trade_guardian\infra\config.py:def _resolve_probe_count(pcfg: Dict[str, Any], base_rank: int) -> int:
src\trade_guardian\infra\config.py:def policy_from_cfg_and_cli(cfg: Dict[str, Any], args) -> ShortLegPolicy:
src\trade_guardian\infra\rate_limit.py:    def __init__(self, throttle_sec: float):
src\trade_guardian\infra\rate_limit.py:    def sleep(self):
src\trade_guardian\infra\retry_option_chain.py:def _utc_now_iso() -> str:
src\trade_guardian\infra\retry_option_chain.py:def _safe_snippet(s: Any, max_len: int = 400) -> str:
src\trade_guardian\infra\retry_option_chain.py:def classify_empty_response(
src\trade_guardian\infra\retry_option_chain.py:def _write_jsonl(path: Path, record: Dict[str, Any]) -> None:
src\trade_guardian\infra\retry_option_chain.py:def fetch_with_retry_and_diagnostics(
src\trade_guardian\infra\retry_option_chain.py:def _sleep_backoff(attempt: int, retry: RetryConfig) -> None:
src\trade_guardian\infra\schwab_client.py:    def __init__(self, cfg: dict = None):
src\trade_guardian\infra\schwab_client.py:    def build_context(self, symbol: str, days: int = 600) -> Optional[Context]:
src\trade_guardian\infra\schwab_client.py:            print(f"âŒ [Error] build_context critical fail for {symbol}: {e}")
src\trade_guardian\infra\schwab_client.py:    def _headers(self):
src\trade_guardian\infra\schwab_client.py:    def get_quote(self, symbol: str) -> dict:
src\trade_guardian\infra\schwab_client.py:    def calculate_hv_percentile(self, symbol: str) -> HVInfo:
src\trade_guardian\infra\schwab_client.py:    def _fetch_calls_chain(self, symbol: str, from_d: str, to_d: str, range_val: str = "NTM") -> dict:
src\trade_guardian\infra\schwab_client.py:    def scan_atm_term(self, symbol: str, days: int, contract_type: str = "CALL") -> tuple[float, list[TermPoint], dict]:
src\trade_guardian\infra\schwab_token_manager.py:def fetch_schwab_token() -> str:
src\trade_guardian\infra\schwab_token_manager_legacy.py:def fetch_schwab_token() -> Optional[str]:
src\trade_guardian\infra\tickers.py:def load_tickers_csv(path: str) -> List[str]:
src\trade_guardian\strategies\auto.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\auto.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\auto.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian\strategies\base.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\base.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian\strategies\blueprint.py:def _extract_greeks_for(chain: Dict[str, Any], side: str, exp: str, strike: float) -> Dict[str, float]:
src\trade_guardian\strategies\blueprint.py:def _extract_mid_for(chain: Dict[str, Any], side: str, exp: str, strike: float) -> Optional[float]:
src\trade_guardian\strategies\blueprint.py:    def one_liner(self) -> str:
src\trade_guardian\strategies\blueprint.py:    def one_liner(self) -> str:
src\trade_guardian\strategies\blueprint.py:    def one_liner(self) -> str:
src\trade_guardian\strategies\blueprint.py:def build_diagonal_blueprint(
src\trade_guardian\strategies\blueprint.py:def build_straddle_blueprint(
src\trade_guardian\strategies\blueprint.py:def build_calendar_blueprint(
src\trade_guardian\strategies\calendar.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\calendar.py:    def _tag(self, regime: str, curvature: str) -> str:
src\trade_guardian\strategies\calendar.py:    def _clamp(x: float, lo: float, hi: float) -> float:
src\trade_guardian\strategies\calendar.py:    def _risk_score(
src\trade_guardian\strategies\calendar.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\calendar.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian\strategies\diagonal.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\diagonal.py:    def _clamp(x: float, lo: float, hi: float) -> float:
src\trade_guardian\strategies\diagonal.py:    def _find_strikes(self, ctx: Context, short_exp: str) -> Tuple[Optional[float], Optional[str], Optional[float]]:
src\trade_guardian\strategies\diagonal.py:            # LEAPS definition: usually > 1 year, but > 120 days is acceptable for diagonals
src\trade_guardian\strategies\diagonal.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\diagonal.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian\strategies\hv_calendar.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\hv_calendar.py:    def _hv_adjust(self, hv_rank: float) -> int:
src\trade_guardian\strategies\hv_calendar.py:    def _find_point_gamma(ctx: Context, exp: str, dte: int) -> float:
src\trade_guardian\strategies\hv_calendar.py:    def _best_effort_squeeze_ratio(ctx: Context) -> float:
src\trade_guardian\strategies\hv_calendar.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\hv_calendar.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian\strategies\long_gamma.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\long_gamma.py:    def _clamp(x: float, lo: float, hi: float) -> float:
src\trade_guardian\strategies\long_gamma.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\placeholder.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\placeholder.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\strategy2_stub.py:    def __init__(self, cfg: dict):
src\trade_guardian\strategies\strategy2_stub.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\strategy2_stub.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian.py:def run_guardian_loop():


================================================================================
FILE_PATH: create_tg_db.py
================================================================================
import sqlite3
import os
import sys

def init_db():
    # ==========================================
    # 1. è·¯å¾„å®šä½é€»è¾‘
    # ==========================================
    # è·å–å½“å‰è„šæœ¬æ‰€åœ¨çš„æ ¹ç›®å½•
    project_root = os.path.dirname(os.path.abspath(__file__))
    
    # å®šä¹‰æ•°æ®åº“æ–‡ä»¶å¤¹å’Œæ–‡ä»¶è·¯å¾„
    db_folder = os.path.join(project_root, "db")
    db_path = os.path.join(db_folder, "trade_guardian.db")

    print(f"ğŸ“ Project Root: {project_root}")
    
    # 2. å¦‚æœ db æ–‡ä»¶å¤¹ä¸å­˜åœ¨ï¼Œåˆ›å»ºå®ƒ
    if not os.path.exists(db_folder):
        print(f"ğŸ› ï¸  Creating DB folder: {db_folder}")
        os.makedirs(db_folder)
    
    # ğŸš¨ [æ–°å¢é€»è¾‘] æš´åŠ›é‡ç½®ï¼šå¦‚æœæ—§åº“å­˜åœ¨ï¼Œç›´æ¥åˆ é™¤ï¼Œç¡®ä¿æ–°å­—æ®µç”Ÿæ•ˆï¼
    if os.path.exists(db_path):
        try:
            os.remove(db_path)
            print(f"ğŸ’¥ Deleted old database to apply new schema: {db_path}")
        except Exception as e:
            print(f"âŒ Error deleting old DB: {e}")
            return

    print(f"ğŸ”— Connecting to database: {db_path}")
    conn = sqlite3.connect(db_path)
    c = conn.cursor()

    # ==========================================
    # 3. åˆ›å»ºè¡¨ç»“æ„ (Schema)
    # ==========================================

    # è¡¨ 1: Scan Batches (æ‰«ææ‰¹æ¬¡/ä¼šè¯)
    # è®°å½•æ¯ä¸€æ¬¡è¿è¡Œ scanlist çš„å…¨å±€ä¿¡æ¯å’Œå¸‚åœºå®è§‚çŠ¶æ€
    print("   ... Checking table: scan_batches")
    c.execute('''
        CREATE TABLE IF NOT EXISTS scan_batches (
            batch_id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp TEXT,           -- ç³»ç»Ÿå¯åŠ¨æ—¶é—´ (ISO æ ¼å¼)
            strategy_name TEXT,       -- è¿è¡Œçš„ç­–ç•¥ (auto/long_gamma/diagonal)
            market_vix REAL,          -- [æ–°å¢] æ‰«ææ—¶çš„ VIX æŒ‡æ•°æ°´å¹³
            universe_size INTEGER,    -- æ‰«æçš„æ ‡çš„æ€»æ•°
            avg_abs_edge REAL,        -- å¸‚åœºå¹³å‡åç¦»å¼ºåº¦ (æ¸©åº¦è®¡)
            cheap_vol_pct REAL,       -- ä¾¿å®œè´§å æ¯” (Edge > 0)
            elapsed_time REAL         -- æ€»è¿è¡Œè€—æ—¶ (ç§’)
        )
    ''')

    # è¡¨ 2: Market Snapshots (è¡Œæƒ…å¿«ç…§)
    # è®°å½•æ¯åªè‚¡ç¥¨åœ¨ T æ—¶åˆ»è¢«æ‰«æåˆ°çš„åŸå§‹çŠ¶æ€
    print("   ... Checking table: market_snapshots")
    c.execute('''
        CREATE TABLE IF NOT EXISTS market_snapshots (
            snapshot_id INTEGER PRIMARY KEY AUTOINCREMENT,
            batch_id INTEGER,         -- å…³è”æ‰«ææ‰¹æ¬¡
            symbol TEXT,              -- è‚¡ç¥¨ä»£ç 
            price REAL,               -- ç°ä»·
            iv_short REAL,            -- çŸ­ç«¯ IV (29 DTE)
            iv_base REAL,             -- é•¿ç«¯åŸºå‡† IV
            edge REAL,                -- Edge Value
            hv_rank REAL,             -- å†å²æ³¢åŠ¨ç‡æ’å
            regime TEXT,              -- æœŸé™ç»“æ„ (CONTANGO/BACKWARDATION)
            FOREIGN KEY(batch_id) REFERENCES scan_batches(batch_id)
        )
    ''')

    # è¡¨ 3: Trade Plans & Gates (æ‰§è¡Œè®¡åˆ’ä¸é£é™©é—¸é—¨)
    # è®°å½• Trade Guardian å¯¹è¯¥è¡Œæƒ…åˆ‡é¢åšå‡ºçš„å†³ç­–ç»†èŠ‚
    print("   ... Checking table: trade_plans")
    c.execute('''
        CREATE TABLE IF NOT EXISTS trade_plans (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            snapshot_id INTEGER,      -- å…³è”è¡Œæƒ…å¿«ç…§
            strategy_type TEXT,       -- å…·ä½“é‡‡ç”¨çš„å­ç­–ç•¥ (LG / PMCC)
            cal_score INTEGER,        -- ç­–ç•¥è¯„åˆ† (0-100)
            short_risk INTEGER,       -- é£é™©è¯„åˆ† (0-100)
            gate_status TEXT,         -- æ‰§è¡Œå›¾æ ‡ (âœ… / âš ï¸ / â›”)
            total_gamma REAL,         -- ç»„åˆæ€» Gamma
            est_debit REAL,           -- ä¼°ç®—æƒåˆ©é‡‘æˆæœ¬
            error_msg TEXT,           -- å¦‚æœè¢«æ‹’ç»ï¼Œè®°å½•åŸå›  (å¦‚ Debit > Width)
            blueprint_json TEXT,      -- å®Œæ•´çš„è“å›¾ç»“æ„ (JSON æ ¼å¼)
            tag TEXT,                 -- [æ–°å¢] ç­–ç•¥æ ‡ç­¾ (LG-M-K)
            FOREIGN KEY(snapshot_id) REFERENCES market_snapshots(snapshot_id)
        )
    ''')

    conn.commit()
    
    # éªŒè¯è¡¨æ•°é‡
    c.execute("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%';")
    tables = c.fetchall()
    
    # éªŒè¯å­—æ®µæ˜¯å¦å­˜åœ¨
    c.execute("PRAGMA table_info(trade_plans)")
    tp_cols = [row[1] for row in c.fetchall()]
    
    conn.close()

    print(f"\nâœ… SUCCESS! Trade Guardian DB initialized with {len(tables)} tables:")
    for t in tables:
        print(f"   - {t[0]}")
    
    if 'tag' in tp_cols:
        print(f"ğŸ‰ Verification: 'tag' column successfully added!")
    else:
        print(f"âŒ Verification Failed: 'tag' column missing!")

    print(f"\nğŸ¯ Database Location: {db_path}")

if __name__ == "__main__":
    init_db()

================================================================================
FILE_PATH: history_viewer.py
================================================================================
import sqlite3
import pandas as pd
import sys
import time
from tabulate import tabulate
from colorama import Fore, Style, init

# åˆå§‹åŒ–é¢œè‰²ç¯å¢ƒ
init(autoreset=True)

class HistoryViewer:
    def __init__(self, db_path="db/trade_guardian.db"):
        self.db_path = db_path

    def get_latest_radar(self, symbol=None, limit=20):
        """
        é”å®šæœ€æ–°ç‰©ç†æ‰¹æ¬¡ï¼Œå¹¶è¯»å– Tag
        """
        conn = sqlite3.connect(self.db_path)
        try:
            # 1. è·å–æœ€æ–°çš„ batch ä¿¡æ¯
            batch_res = conn.execute("""
                SELECT b.batch_id, strftime('%H:%M:%S', b.timestamp), b.market_vix 
                FROM scan_batches b
                JOIN market_snapshots s ON s.batch_id = b.batch_id
                ORDER BY b.batch_id DESC LIMIT 1
            """).fetchone()
            
            if not batch_res:
                return pd.DataFrame()
            
            latest_id, latest_time, current_vix = batch_res
            
            # 2. æŸ¥è¯¢è¯¦ç»†æ•°æ® (æ˜¾å¼æŸ¥è¯¢ p.tag)
            query = f"""
            SELECT 
                s.symbol as Sym,
                s.price as Price,
                s.iv_short as IV_S,
                s.snapshot_id,
                COALESCE(p.gate_status, 'WAIT') as Gate,
                COALESCE(p.cal_score, 0) as Score,
                COALESCE(p.total_gamma, 0.0) as Gamma,
                COALESCE(p.tag, '') as Tag
            FROM market_snapshots s
            LEFT JOIN trade_plans p ON s.snapshot_id = p.snapshot_id
            WHERE s.batch_id = ?
            ORDER BY Score DESC, IV_S DESC
            LIMIT ?
            """
            df = pd.read_sql_query(query, conn, params=(latest_id, limit))
            
            if not df.empty:
                df['Time'] = latest_time
                df['VIX'] = current_vix
                df = self._process_logic(df, latest_id, conn)
            
            return df
        finally:
            conn.close()

    def _process_logic(self, df, latest_id, conn):
        """
        è®¡ç®—åŠ¨èƒ½ (Delta 15m / 1h)
        """
        # è·å–ä¸Šä¸€ä¸ª Batch çš„ VIX ç”¨äºè®¡ç®—å·®å€¼
        v_prev = conn.execute("SELECT market_vix FROM scan_batches WHERE batch_id = ?", (latest_id-1,)).fetchone()
        df['VIX_Î”'] = round(df['VIX'].iloc[0] - v_prev[0], 2) if v_prev else 0.0

        for i, row in df.iterrows():
            sym = row['Sym']
            # å°è¯•è·å–å†å² IV æ•°æ®
            res15 = conn.execute("SELECT iv_short FROM market_snapshots WHERE symbol=? AND batch_id=?", (sym, latest_id-1)).fetchone()
            res1h = conn.execute("SELECT iv_short FROM market_snapshots WHERE symbol=? AND batch_id=?", (sym, latest_id-4)).fetchone()

            d15 = round(row['IV_S'] - (res15[0] if res15 else row['IV_S']), 1)
            d1h = round(row['IV_S'] - (res1h[0] if res1h else row['IV_S']), 1)
            
            df.at[i, 'Î”15m'] = d15
            df.at[i, 'Î”1h'] = d1h

            # DNA åˆ¤å®š (ä»…ç”¨äºæ˜¾ç¤ºé¢œè‰²)
            dna_type = "QUIET"
            if d15 > 2.0: dna_type = "PULSE"
            elif d15 > 0.5: dna_type = "TREND"
            elif d15 < -1.0: dna_type = "CRUSH"
            
            df.at[i, 'DNA_Raw'] = dna_type
                
        return df

    def display(self, symbol=None):
        df = self.get_latest_radar(symbol=symbol)
        if df.empty:
            print(f"{Fore.RED}ğŸ“­ [Sync] Monitoring...{Style.RESET_ALL}")
            return

        formatted_rows = []
        for _, row in df.iterrows():
            # --- 1. æ•°æ®æ ¼å¼åŒ– (çº¯æ–‡æœ¬ï¼Œå›ºå®šå®½åº¦) ---
            p_str = f"{row['Price']:>10.2f}"
            iv_str = f"{row['IV_S']:>8.1f}%"
            d15_raw = f"{row['Î”15m']:>+6.1f}"
            d1h_raw = f"{row['Î”1h']:>+6.1f}"
            g_str = f"{row['Gamma']:>8.3f}"
            s_str = f"{row['Score']:>5}"
            
            # --- 2. é¢œè‰²æ¸²æŸ“ ---
            
            # åŠ¨èƒ½ (Î”15m)
            d15_render = d15_raw
            if row['Î”15m'] > 1.5: 
                d15_render = f"{Fore.RED}{d15_raw}{Style.RESET_ALL}"
            elif row['Î”15m'] < -1.5: 
                d15_render = f"{Fore.CYAN}{d15_raw}{Style.RESET_ALL}"

            # DNA çŠ¶æ€
            dna_raw = f"{row['DNA_Raw']:<6}"
            if row['DNA_Raw'] == "PULSE": dna_render = f"{Fore.CYAN}{dna_raw}{Style.RESET_ALL}"
            elif row['DNA_Raw'] == "TREND": dna_render = f"{Fore.GREEN}{dna_raw}{Style.RESET_ALL}"
            elif row['DNA_Raw'] == "CRUSH": dna_render = f"{Fore.YELLOW}{dna_raw}{Style.RESET_ALL}"
            else: dna_render = f"{Fore.WHITE}{dna_raw}{Style.RESET_ALL}"

            # Gate çŠ¶æ€ (åŒæ­¥ Orchestrator çš„é¢œè‰²é€»è¾‘)
            gate_raw = f"{row['Gate']:<6}"
            if row['Gate'] == "EXEC": gate_c = Fore.GREEN
            elif row['Gate'] == "LIMIT": gate_c = Fore.CYAN  # âœ… LIMIT æ˜¾ç¤ºä¸ºé’è‰²
            elif row['Gate'] == "FORBID": gate_c = Fore.RED
            else: gate_c = Fore.YELLOW # WAIT
            gate_render = f"{gate_c}{gate_raw}{Style.RESET_ALL}"

            # Tag æ¸²æŸ“ (âœ… å…³é”®ç‚¹)
            # ç¡®ä¿ Tag ä¸ä¸º None (æ•°æ®åº“è¯»å–å¯èƒ½ä¼šè¯»å‡º None)
            tag_val = row['Tag'] if row['Tag'] is not None else ""
            tag_render = f"{Fore.WHITE}{tag_val:<8}{Style.RESET_ALL}"

            formatted_rows.append([
                f"{Fore.LIGHTBLACK_EX}{row['Time']}{Style.RESET_ALL}",
                f"{Style.BRIGHT}{row['Sym']:<6}{Style.RESET_ALL}",
                dna_render,
                p_str,
                iv_str,
                d15_render,
                d1h_raw,
                g_str,
                f"{Fore.CYAN if row['Score'] >= 70 else Fore.WHITE}{s_str}{Style.RESET_ALL}",
                gate_render,
                tag_render  # âœ… æœ€åä¸€åˆ—
            ])

        # --- 3. å¤´éƒ¨ä¿¡æ¯ä¸æ‰“å° ---
        v_diff = df['VIX_Î”'].iloc[0]
        v_info = f" | VIX: {df['VIX'].iloc[0]} ({Fore.RED if v_diff > 0 else Fore.GREEN}{v_diff:+0.2f}{Style.RESET_ALL})"
        
        # è°ƒæ•´æ¨ªçº¿å®½åº¦ä»¥é€‚é…æ–°å¢çš„åˆ—
        print("\n" + "="*126)
        print(f"ğŸ“¡ DNA MOMENTUM RADAR | {df['Time'].iloc[0]}{v_info}")
        print("="*126)
        
        # å®šä¹‰è¡¨å¤´ï¼Œç¡®ä¿ä¸ row æ•°æ®åˆ—æ•°ä¸€è‡´
        headers = ["Time", "Sym", "DNA", "Price", "IV_S", "Î”15m", "Î”1h", "Gamma", "Score", "Gate", "Tag"]
        
        # stralign="left" é˜²æ­¢ tabulate è‡ªåŠ¨å±…ä¸­å¯¼è‡´é¢œè‰²ä»£ç é”™ä½
        print(tabulate(formatted_rows, headers=headers, tablefmt='psql', stralign="left", disable_numparse=True))
        print("\n" + "="*126)

        
if __name__ == "__main__":
    viewer = HistoryViewer()
    target_sym = sys.argv[1] if len(sys.argv) > 1 else None
    print(f"Starting Dashboard... (Target: {target_sym if target_sym else 'ALL'})")
    while True:
        try:
            viewer.display(symbol=target_sym)
            time.sleep(60)
        except KeyboardInterrupt:
            print("\nStopped.")
            break
        except Exception as e:
            # æ­¤æ—¶å¦‚æœå‡ºé”™ï¼Œè¯·å‘Šè¯‰æˆ‘é”™è¯¯ä¿¡æ¯ï¼Œä½†é€»è¾‘ä¸Šåº”è¯¥å·²ç»é—­ç¯
            print(f"Error: {e}")
            time.sleep(5)

================================================================================
FILE_PATH: pyproject.toml
================================================================================
[build-system]
requires = ["setuptools>=68"]
build-backend = "setuptools.build_meta"

[project]
name = "trade-guardian"
version = "0.1.0"
requires-python = ">=3.10"
dependencies = [
  "requests",
  "pandas",
  "numpy",
  "tabulate",
  "colorama",
]

[tool.setuptools]
package-dir = {"" = "src"}

[tool.setuptools.packages.find]
where = ["src"]


================================================================================
FILE_PATH: README.md
================================================================================


# ğŸ§  Trade Guardian (v2.0)

**Trade Guardian** æ˜¯ä¸€æ¬¾é¢å‘ä¸“ä¸šæœŸæƒäº¤æ˜“è€…çš„è‡ªåŠ¨åŒ–æ‰«æä¸æ‰§è¡Œè®¡åˆ’å·¥å…·ã€‚å®ƒä¸ä»…èƒ½å‘ç°å¸‚åœºä¸­å®šä»·åä½çš„æ³¢åŠ¨ç‡æœºä¼šï¼ˆEdgeï¼‰ï¼Œæ›´èƒ½é€šè¿‡å†…ç½®çš„ **Planner (è®¡åˆ’å™¨)** å¼ºåˆ¶æ‰§è¡Œç¡¬æ€§é£é™©æ‹¦æˆªã€‚

> **è®¾è®¡å“²å­¦**ï¼šScanner è´Ÿè´£æµ·é€‰æœºä¼šï¼ŒPlanner è´Ÿè´£ç¡®ä¿å¯äº¤æ˜“æ€§ä¸ç¡¬é£é™©é—¸é—¨ã€‚

---

## ğŸš€ æ ¸å¿ƒè¿›åŒ–åŠŸèƒ½

### 1. çœŸå®æ•°æ®é©±åŠ¨ (Schwab API)

ç³»ç»Ÿå·²å®Œå…¨æ‰“é€š **Schwab API**ï¼Œå®æ—¶è·å–ï¼š

* æ ‡çš„ç°ä»·ã€å†å²æ³¢åŠ¨ç‡ (HV) åŠ HV Rankã€‚
* ATM æœŸæƒé“¾ã€éšå«æ³¢åŠ¨ç‡ (IV) æœŸé™ç»“æ„åŠ Greeks (Gamma/Delta/Theta)ã€‚
* è‡ªåŠ¨é”å®šæµåŠ¨æ€§æœ€ä½³çš„ **æœˆåº¦æœŸæƒåˆçº¦ (Monthly OpEx)**ã€‚

### 2. å¢å¼ºå‹é£é™©å¼•æ“ (The Guardian)

* **Total Gamma ç›‘æµ‹**ï¼šè‡ªåŠ¨è®¡ç®—ç»„åˆï¼ˆå¦‚è·¨å¼ç»„åˆ Straddleï¼‰çš„æ€» Gammaï¼Œå¹¶è¿›è¡Œåˆ†çº§ï¼š
* **EXTREME â›”** (Î“ â‰¥ 0.20): æç«¯æ³¢åŠ¨é£é™©ã€‚
* **HIGH âš ï¸** (Î“ â‰¥ 0.12): é«˜é£é™©ï¼Œéœ€å¤§å¹…ç¼©å‡ä»“ä½ã€‚
* **ELEVATED ğŸ”¸** (Î“ â‰¥ 0.08): é¢„è­¦åŒºã€‚


* **PMCC å®‰å…¨é”**ï¼šç¡¬æ€§æ‰§è¡Œ `Debit < Width` æ£€æŸ¥ï¼Œè‡ªåŠ¨æ‹¦æˆªæ³¨å®šäºæŸçš„é”æ­»äº¤æ˜“ï¼ˆLocked Lossï¼‰ï¼Œå¹¶ç»™å‡ºä¿®æ­£å»ºè®®ã€‚

### 3. äº¤æ˜“å‘˜çœ‹æ¿å¼è¾“å‡º

* **Gate çŠ¶æ€åˆ—**ï¼šåœ¨æ‰«æç»“æœä¸­ç›´è§‚æ˜¾ç¤º `âœ… å¯æ‰§è¡Œ`ã€`âš ï¸ é«˜é£é™©`ã€`â›” å·²æ‹’ç»`ã€‚
* **Trader's Sort**ï¼šä¼˜å…ˆæ’åˆ—â€œé«˜ Edgeã€ä½ Riskã€Gate âœ…â€çš„æ ‡çš„ã€‚
* **Actionable Blueprints**ï¼šç”Ÿæˆå«å…·ä½“æ—¥æœŸã€è¡Œæƒä»·ã€æ–¹å‘åŠæˆæœ¬ä¼°ç®—çš„æ‰§è¡Œè“å›¾ã€‚

---

## ğŸ› ï¸ å®‰è£…ä¸é…ç½®

1. **ç¯å¢ƒè¦æ±‚**ï¼šPython 3.8+
2. **å®‰è£…ä¾èµ–**ï¼š
```bash
pip install requests pandas numpy

```


3. **æ•°æ®é…ç½®**ï¼š
* åœ¨ `data/tickers.csv` ä¸­å¡«å…¥ä½ æƒ³æ‰«æçš„è‚¡ç¥¨ä»£ç ï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰ã€‚
* ç¡®ä¿ `src/trade_guardian/infra/schwab_token_manager.py` èƒ½å¤Ÿè·å–æœ‰æ•ˆçš„ API Tokenã€‚



---

## ğŸ“– ä½¿ç”¨æŒ‡å—

### å¯åŠ¨å…¨è‡ªåŠ¨æ‰«æ

```bash
python src/trade_guardian.py scanlist --strategy auto --days 600 --detail --top 5

```

**å‚æ•°è¯´æ˜**ï¼š

* `--strategy auto`: åŒæ—¶è¿è¡Œ Long Gamma (Straddle) å’Œ Diagonal (PMCC) ç­–ç•¥ã€‚
* `--days 600`: æ‰«æè¿œç«¯æœŸæƒé“¾ï¼ˆç”¨äº PMCC å¯»æ‰¾ LEAPSï¼‰ã€‚
* `--detail`: è¾“å‡ºå…·ä½“çš„æ‰§è¡Œè“å›¾ï¼ˆActionable Blueprintsï¼‰ã€‚
* `--top 5`: ç»è¿‡æ’åºåï¼Œåªæ˜¾ç¤ºæœ€ä¼˜è´¨çš„å‰ 5 ä¸ªäº¤æ˜“è®¡åˆ’ã€‚

---

## ğŸ“Š è¾“å‡ºè§£è¯»

### æ‰«æè¡¨ (Scanner View)

| Sym | Px | ShortExp | DTE | ShortIV | Edge | Risk | Gate |
| --- | --- | --- | --- | --- | --- | --- | --- |
| AMD | 202.0 | 2026-01-16 | 29 | 45.2% | +0.13x | 20 | âœ… |
| ONDS | 7.87 | 2026-01-16 | 29 | 120.4% | +0.26x | 70 | âš ï¸ |
| MSTR | 159.2 | 2026-01-16 | 29 | 77.6% | +0.02x | 30 | â›” |

### æ‰§è¡Œè“å›¾ç¤ºä¾‹ (Execution Plan)

```text
 MSTR DIAGONAL    Est.Debit: $55.87
    +1 2026-06-18 111.0  CALL
    -1 2026-01-16 162.0  CALL
    ==============================
    â›” REJECTED: Debit > Width. Excess: $4.87.
    ==============================
    Strategy Gate: Blocked by Risk Policy.
       â€¢ Try buying deeper ITM LEAPS or RAISING Short Strike.

```

---

## ğŸ§¾ è¯Šæ–­æŒ‡æ ‡ (Diagnostics)

* **Avg |Edge|**: å¸‚åœºæ•´ä½“æ³¢åŠ¨ç‡åç¦»å¼ºåº¦ã€‚
* **Cheap Vol (%)**: å¸‚åœºä¸­å¤„äºâ€œä¾¿å®œâ€çŠ¶æ€ï¼ˆIV < HVï¼‰çš„æ ‡çš„æ¯”ä¾‹ï¼Œä½œä¸ºå¤šç©ºæƒ…ç»ªæ¸©åº¦è®¡ã€‚

---

## âš–ï¸ å…è´£å£°æ˜

æœ¬å·¥å…·ä»…ä¾›ç ”ç©¶ä¸å‚è€ƒä½¿ç”¨ï¼Œä¸æ„æˆä»»ä½•æŠ•èµ„å»ºè®®ã€‚æœŸæƒäº¤æ˜“æ¶‰åŠé«˜é£é™©ï¼Œåœ¨ä½¿ç”¨è“å›¾æ‰§è¡Œäº¤æ˜“å‰ï¼Œè¯·åŠ¡å¿…æ ¸å®å®æ—¶æŠ¥ä»·å¹¶è¿›è¡Œä¸ªäººé£é™©è¯„ä¼°ã€‚

---

**Current Version**: 2.0.0 | **Last Updated**: 2025-12-18

================================================================================
FILE_PATH: requirements.txt
================================================================================
requests
pandas
numpy
tabulate
colorama


================================================================================
FILE_PATH: config\config.json
================================================================================
{
  "runtime": {
    "autogen_config_if_missing": true
  },
  "paths": {
    "tickers_csv": "./data/tickers.csv",
    "cache_dir": "./cache"
  },
  "scan": {
    "contract_type": "CALL",
    "throttle_sec": 0.5,
    "days_default": 600
  },
  "rules": {
    "min_edge_short_base": 1.05
  },
  "policy": {
    "base_rank": 1,
    "min_dte": 3,
    "max_probe_rank": 3
  }
}

================================================================================
FILE_PATH: src\trade_guardian.py
================================================================================
import time
import sys
import os
from datetime import datetime

# ç¡®ä¿ src ç›®å½•åœ¨è·¯å¾„ä¸­ï¼Œä»¥ä¾¿æ­£ç¡®å¯¼å…¥
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from trade_guardian.app.cli import main

def run_guardian_loop():
    """
    å®ˆæŠ¤è€…æ¨¡å¼ï¼šæ¯ 15 åˆ†é’Ÿè‡ªåŠ¨æ‰§è¡Œä¸€æ¬¡å…¨é‡æ‰«æå¹¶å­˜åº“
    """
    INTERVAL = 15 * 60  # 15 åˆ†é’Ÿ (900ç§’)
    
    print("="*80)
    print(f"ğŸ›¡ï¸  TRADE GUARDIAN - DAEMON MODE ACTIVE")
    print(f"â° Polling Interval: {INTERVAL/60} minutes")
    print(f"ğŸ“‚ Project Root: {project_root}")
    print("="*80)
    
    try:
        while True:
            start_ts = time.time()
            now_str = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            # æ¨¡æ‹Ÿå‘½ä»¤è¡Œå‚æ•°ç»™ cli.main()
            # è¿™é‡Œä½ å¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´é»˜è®¤å‚æ•°
            sys.argv = [
                "trade_guardian.py", 
                "scanlist", 
                "--strategy", "auto", 
                "--days", "600", 
                "--detail",
                "--top", "10" # è‡ªåŠ¨æ¨¡å¼ä¸‹åªæ˜¾ç¤ºæœ€æœ‰ä»·å€¼çš„10ä¸ªè®¡åˆ’
            ]
            
            print(f"\nğŸ”„ [LOOP START] {now_str}")
            
            try:
                # æ‰§è¡ŒåŸæœ‰çš„ cli ä¸»å‡½æ•°
                main()
            except Exception as e:
                print(f"âŒ Session Execution Error: {e}")

            elapsed = time.time() - start_ts
            wait_time = max(0, INTERVAL - elapsed)
            
            next_run = datetime.fromtimestamp(time.time() + wait_time).strftime('%H:%M:%S')
            
            print(f"\nâœ… SESSION COMPLETE. Duration: {elapsed:.2f}s")
            print(f"â³ Sleeping {wait_time/60:.1f} min. Next run at: {next_run} (Ctrl+C to stop)")
            
            time.sleep(wait_time)
            
    except KeyboardInterrupt:
        print("\nğŸ›‘ Guardian daemon stopped by user. exiting...")
        sys.exit(0)

if __name__ == "__main__":
    # é€»è¾‘åˆ¤å®šï¼š
    # 1. å¦‚æœä½ è¾“å…¥ python src/trade_guardian.py scanlist ... (å¸¦å‚æ•°) -> è¿è¡Œä¸€æ¬¡å°±ç»“æŸ
    # 2. å¦‚æœä½ ç›´æ¥è¾“å…¥ python src/trade_guardian.py (ä¸å¸¦å‚æ•°) -> è¿›å…¥15åˆ†é’Ÿè½®è¯¢æ¨¡å¼
    if len(sys.argv) > 1:
        main()
    else:
        run_guardian_loop()

================================================================================
FILE_PATH: src\trade_guardian\__init__.py
================================================================================
__all__ = ["app", "domain", "infra", "strategies"]
__version__ = "0.1.0"


================================================================================
FILE_PATH: src\trade_guardian\app\cli.py
================================================================================
import argparse
import os
import time

from trade_guardian.infra.config import (
    DEFAULT_CONFIG,
    load_config,
    write_config_template,
    merge_config_paths,
    policy_from_cfg_and_cli,
)
from trade_guardian.infra.schwab_client import SchwabClient
from trade_guardian.domain.registry import StrategyRegistry
from trade_guardian.app.orchestrator import TradeGuardian


def main():
    parser = argparse.ArgumentParser("Trade Guardian")
    sub = parser.add_subparsers(dest="cmd", required=True)

    # ---------- initconfig ----------
    p_init = sub.add_parser("initconfig", help="Generate config/config.json template")
    p_init.add_argument("--path", type=str, default=None, help="Output path (default: ./config/config.json)")
    p_init.add_argument("--force", action="store_true", help="Overwrite if exists")

    # ---------- scanlist ----------
    p_scan = sub.add_parser("scanlist", help="Scan tickers.csv and output candidates")
    p_scan.add_argument("--config", type=str, default=None, help="Config path (default: ./config/config.json)")
    p_scan.add_argument("--autogen-config", action="store_true", help="Auto-generate config if missing")
    p_scan.add_argument("--no-autogen-config", action="store_true", help="Disable auto-generate config")

    p_scan.add_argument("--strategy", type=str, default="auto", help="Strategy name (default: auto)")
    p_scan.add_argument("--days", type=int, default=600)
    p_scan.add_argument("--csv", type=str, default=None, help="Tickers csv path")
    p_scan.add_argument("--min-score", type=int, default=60)
    p_scan.add_argument("--max-risk", type=int, default=70)
    p_scan.add_argument("--limit", type=int, default=0)
    p_scan.add_argument("--detail", action="store_true", help="Print blueprints and detailed logic")
    p_scan.add_argument("--top", type=int, default=None, help="Only show top N sorted blueprints")

    # Policy overrides
    p_scan.add_argument("--short-rank", type=int, default=None)
    p_scan.add_argument("--min-short-dte", type=int, default=None)
    p_scan.add_argument("--max-probe-rank", type=int, default=None)

    args = parser.parse_args()

    # å®šä½é¡¹ç›®æ ¹ç›®å½• (cli.py -> app -> trade_guardian -> src -> project_root)
    root = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "..", ".."))

    if args.cmd == "initconfig":
        out = args.path or os.path.join(root, "config", "config.json")
        os.makedirs(os.path.dirname(out), exist_ok=True)
        write_config_template(out, DEFAULT_CONFIG, overwrite=args.force)
        print(f"âœ… Wrote config template: {out}")
        return

    if args.cmd == "scanlist":
        # è®°å½•å¼€å§‹æ—¶é—´ï¼Œç”¨äºæ•°æ®åº“å­˜ç›˜
        start_ts = time.time()

        cfg_path = args.config or os.path.join(root, "config", "config.json")

        # æ£€æŸ¥æ˜¯å¦éœ€è¦è‡ªåŠ¨ç”Ÿæˆé…ç½®
        autogen_default = bool(DEFAULT_CONFIG.get("runtime", {}).get("autogen_config_if_missing", True))
        autogen = autogen_default
        if args.autogen_config: autogen = True
        if args.no_autogen_config: autogen = False

        if autogen and not os.path.exists(cfg_path):
            os.makedirs(os.path.dirname(cfg_path), exist_ok=True)
            write_config_template(cfg_path, DEFAULT_CONFIG, overwrite=False)

        # åŠ è½½ä¸åˆå¹¶è·¯å¾„
        cfg = load_config(cfg_path, DEFAULT_CONFIG)
        cfg = merge_config_paths(cfg, root, args.csv)

        # æ„å»ºç­–ç•¥å’Œå®¢æˆ·ç«¯
        policy = policy_from_cfg_and_cli(cfg, args)
        client = SchwabClient(cfg)
        registry = StrategyRegistry(cfg, policy)
        strategy = registry.get(args.strategy)

        # åˆå§‹åŒ–ä¸»æ§ç¨‹åº
        tg = TradeGuardian(client=client, cfg=cfg, policy=policy, strategy=strategy)
        
        # æ‰§è¡Œæ‰«æ
        # è¿™é‡Œè®¡ç®— elapsed (ç»è¿‡çš„æ—¶é—´)ï¼Œç¡®ä¿æ•°æ®åº“èƒ½è®°å½•è¿™æ¬¡ä»»åŠ¡è·‘äº†å¤šä¹…
        tg.scanlist(
            strategy_name=args.strategy,
            days=args.days,
            min_score=args.min_score,
            max_risk=args.max_risk,
            limit=args.limit,
            detail=args.detail,
            top=args.top,
            elapsed=0.0  # åˆå§‹è®¾ä¸º0ï¼ŒOrchestrator å†…éƒ¨ä¼šè®¡ç®—çœŸå®å€¼æˆ–ç”±è¿™é‡Œä¼ é€’
        )
        return


if __name__ == "__main__":
    main()

================================================================================
FILE_PATH: src\trade_guardian\app\orchestrator.py
================================================================================
from __future__ import annotations
import os
import sys
import time
import pandas as pd
from typing import List, Tuple, Optional, Any
from colorama import Fore, Style

from trade_guardian.domain.models import Context, ScanRow, Blueprint, OrderLeg
from trade_guardian.app.persistence import PersistenceManager

# --- [äº¤æ˜“å‘˜åº•çº¿å‚æ•°] ---
MICRO_MIN = 0.10
MONTH_MIN = 0.15

class TradeGuardian:
    def __init__(self, client, cfg: dict, policy, strategy=None):
        self.client = client
        self.cfg = cfg
        self.policy = policy
        self.strategy = strategy 
        self.tickers_path = os.path.join("data", "tickers.csv")
        self.db = PersistenceManager()
        self.last_batch_df: Optional[pd.DataFrame] = None 

    def _get_universe(self) -> List[str]:
        if not os.path.exists(self.tickers_path):
            print(f"\nâŒ [CRITICAL ERROR] Tickers file NOT FOUND")
            sys.exit(1)
        df = pd.read_csv(self.tickers_path, header=None)
        return df[0].dropna().apply(lambda x: str(x).strip().upper()).tolist()

    def scanlist(self, strategy_name: str = "auto", days: int = 600, 
                 min_score: int = 60, max_risk: int = 70, detail: bool = False,
                 limit: int = None, **kwargs):
        
        try:
            vix_q = self.client.get_quote("$VIX")
            current_vix = vix_q.get("lastPrice", 0.0) 
        except: current_vix = 0.0
        
        tickers = self._get_universe()
        if limit: tickers = tickers[:limit]

        db_results_pack = []  
        all_rows_for_stats = [] 
        current_rows_for_next_batch = [] 
        strict_results = [] 
        
        # âœ… æœ€ç»ˆå¯¹é½ä¿®å¤ï¼šå¢åŠ é—´è·ï¼Œå•ç‹¬å¤„ç†é¢œè‰²åˆ—çš„å®½åº¦
        FMT = "{sym:<5} {px:<7} {sexp:<11} {sdte:<3} {siv:>6} | {mexp:<11} {mdte:<3} {miv:>6} {em:>5} | {kexp:<11} {kdte:<3} {kiv:>6} {ek:>5} | {sc:>4} {dna:<6} {gate:<6}   {tag:<8}"
        
        HEADER = FMT.format(
            sym="Sym", px="Px", sexp="ShortExp", sdte="D", siv="S_IV",
            mexp="MicroExp", mdte="D", miv="M_IV", em="EdgM",
            kexp="MonthExp", kdte="D", kiv="K_IV", ek="EdgK",
            sc="Scr", dna="DNA", gate="Gate", tag="Tag"
        )
        WIDTH = len(HEADER)

        print("\n" + "=" * WIDTH)
        print(f"ğŸ§  TRADE GUARDIAN :: GRADUATION BUILD | VIX: {current_vix:.2f}")
        print("-" * WIDTH)
        print(HEADER)
        print("-" * WIDTH)

        for ticker in tickers:
            try:
                ctx = self.client.build_context(ticker, days=days)
                if not ctx: continue
                
                strategy = self._load_strategy("long_gamma")
                row = strategy.evaluate(ctx)
                if not row: continue

                # åŠ¨èƒ½è®¡ç®—
                iv_diff = 0.0
                if self.last_batch_df is not None:
                    prev = self.last_batch_df[self.last_batch_df['symbol'] == row.symbol]
                    if not prev.empty:
                        iv_diff = row.short_iv - prev.iloc[0]['iv']
                
                dna_type = "QUIET"
                if iv_diff > 2.0: dna_type = "PULSE"
                elif iv_diff > 0.5: dna_type = "TREND"
                elif iv_diff < -1.0: dna_type = "CRUSH"

                row.meta["delta_15m"] = iv_diff
                bp = self.plan(ctx, row)
                gate = self._get_gate_status(row, bp, dna_type) 
                
                db_results_pack.append((row, ctx, bp, gate)) 
                all_rows_for_stats.append(row)
                current_rows_for_next_batch.append({'symbol': row.symbol, 'iv': row.short_iv})
                
                if gate != "FORBID":
                    strict_results.append((row, ctx, bp, gate, dna_type))

                # é¢œè‰²é€»è¾‘
                if gate == "EXEC": g_color = Fore.GREEN
                elif gate == "LIMIT": g_color = Fore.CYAN
                elif gate == "FORBID": g_color = Fore.RED
                else: g_color = Fore.YELLOW
                
                # âœ… æ ¸å¿ƒä¿®å¤ï¼šå…ˆæ‰‹åŠ¨å¡«å……ç©ºæ ¼ï¼Œå†ä¸Šè‰²ï¼Œç¡®ä¿è§†è§‰å®½åº¦ä¸€è‡´
                # å°† Gate å¼ºåˆ¶å¡«å……åˆ° 6 å­—ç¬¦å®½ï¼Œç„¶åå†åŒ…é¢œè‰²ä»£ç 
                gate_padded = f"{gate:<6}"
                gate_display = f"{g_color}{gate_padded}{Style.RESET_ALL}"
                
                # æ•°æ®æå–
                m_iv_val = row.meta.get('micro_iv', 0) or 0
                k_iv_val = row.meta.get('month_iv', 0) or 0
                em_val = row.meta.get('edge_micro', 0) or 0
                ek_val = row.meta.get('edge_month', 0) or 0

                print(FMT.format(
                    sym=row.symbol,
                    px=f"{row.price:.1f}",
                    sexp=row.short_exp,
                    sdte=row.short_dte,
                    siv=f"{int(row.short_iv)}%",
                    
                    mexp=str(row.meta.get("micro_exp", "N/A")),
                    mdte=str(row.meta.get("micro_dte", 0)),
                    miv=f"{int(m_iv_val)}%",
                    em=f"{em_val:.2f}",
                    
                    kexp=str(row.meta.get("month_exp", "N/A")),
                    kdte=str(row.meta.get("month_dte", 0)),
                    kiv=f"{int(k_iv_val)}%",
                    ek=f"{ek_val:.2f}",
                    
                    sc=row.cal_score,
                    dna=dna_type,
                    gate=gate_display, # ä½¿ç”¨ä¿®å¤åçš„ Gate æ˜¾ç¤º
                    tag=row.tag
                ))

            except Exception as e:
                continue

        self.last_batch_df = pd.DataFrame(current_rows_for_next_batch)
        self.db.save_scan_session(strategy_name, current_vix, len(tickers), 0.0, 0.0, 0.0, db_results_pack)
        
        if detail and strict_results:
            print(f"\nğŸš€ Actionable Blueprints (Tactical Mode)")
            print("-" * WIDTH)
            for row, ctx, bp, gate, dna in strict_results:
                self._print_enhanced_blueprint(bp, row, dna, gate)
        print("-" * WIDTH)

    def _get_gate_status(self, row: ScanRow, bp: Optional[Blueprint], dna_type: str) -> str:
        est_gamma = row.meta.get("est_gamma", 0.0)
        
        # 1. ç»å¯¹é£æ§
        if not bp or bp.error or est_gamma >= 0.25: return "FORBID"
        if dna_type == "CRUSH": return "FORBID" 
        
        em = row.meta.get("edge_micro", 0)
        ek = row.meta.get("edge_month", 0)
        
        # 2. ç»“æ„é—¨æ§›
        if em < MICRO_MIN or ek < MONTH_MIN:
            return "WAIT"

        # 3. ç»“æ„è¾¾æ ‡
        if dna_type in ["PULSE", "TREND"]:
            return "EXEC"
        else:
            return "LIMIT"

    def plan(self, ctx: Context, row: ScanRow) -> Optional[Blueprint]:
        symbol = ctx.symbol
        atm_strike = row.meta.get("strike", round(row.price, 1))
        target_exp_key = f"{row.short_exp}:{row.short_dte}"
        est_debit = -999999.99
        
        try:
            call_map = ctx.raw_chain.get("callExpDateMap", {})
            put_map = ctx.raw_chain.get("putExpDateMap", {})
            strike_key = f"{float(atm_strike):g}"
            
            if strike_key not in call_map.get(target_exp_key, {}):
                keys = sorted([float(k) for k in call_map.get(target_exp_key, {}).keys()])
                if keys: strike_key = f"{min(keys, key=lambda x: abs(x - atm_strike)):g}"

            c_strikes = call_map.get(target_exp_key, {})
            p_strikes = put_map.get(target_exp_key, {})
            
            if strike_key in c_strikes and strike_key in p_strikes:
                c_c = c_strikes[strike_key][0]
                p_c = p_strikes[strike_key][0]
                call_price = (float(c_c.get("bid", 0)) + float(c_c.get("ask", 0))) / 2.0
                put_price = (float(p_c.get("bid", 0)) + float(p_c.get("ask", 0))) / 2.0
                if call_price > 0 and put_price > 0:
                    est_debit = call_price + put_price
        except: pass

        legs = [OrderLeg(symbol, "BUY", 1, row.short_exp, float(atm_strike), "CALL"), 
                OrderLeg(symbol, "BUY", 1, row.short_exp, float(atm_strike), "PUT")]
        return Blueprint(symbol, "STRADDLE", legs, round(est_debit, 2), "Gamma Plan")

    def _print_enhanced_blueprint(self, bp: Blueprint, row: ScanRow, dna: str, gate: str):
        tactic = ""
        if gate == "LIMIT":
            tactic = f"{Fore.CYAN}[æŒ‚å•æ½œä¼] å»ºè®® Limit @ Mid-$0.05 | è§¦å‘æ¡ä»¶: ç­‰å¾… DNA æ¿€æ´»{Style.RESET_ALL}"
        elif gate == "EXEC":
            tactic = f"{Fore.GREEN}[ç«‹å³æ‰§è¡Œ] å»ºè®® Market æˆ– Mid+$0.02 | è§¦å‘æ¡ä»¶: åŠ¨èƒ½ç¡®ç«‹{Style.RESET_ALL}"
        elif gate == "WAIT":
             tactic = f"{Fore.YELLOW}[ä¿æŒå…³æ³¨] å°šæœªè¾¾åˆ°å…¥åœºæ ‡å‡†{Style.RESET_ALL}"

        print(f" {Fore.WHITE}{bp.symbol:<5} | Gate: {gate:<5} | Debit: ${bp.est_debit} | Gamma: {row.meta.get('est_gamma', 0):.4f}")
        print(f"    Edges: Micro {row.meta.get('edge_micro', 0):.2f} / Month {row.meta.get('edge_month', 0):.2f}")
        print(f"    ğŸ‘‰ {tactic}")
        for leg in bp.legs:
            print(f"       {'+' if leg.action == 'BUY' else '-'}{leg.ratio} {leg.exp} {leg.strike:<6} {leg.type}")
        print(f"    {'='*80}")

    def _load_strategy(self, name: str):
        from trade_guardian.strategies.long_gamma import LongGammaStrategy
        return LongGammaStrategy(self.cfg, self.policy)

================================================================================
FILE_PATH: src\trade_guardian\app\persistence.py
================================================================================
import sqlite3
import os
from datetime import datetime

class PersistenceManager:
    def __init__(self, db_path="db/trade_guardian.db"):
        self.db_path = db_path
        # æ•°æ®åº“ç»“æ„å®Œå…¨ç”±ç”¨æˆ·çš„ create_tg_db.py æŒæ§ï¼Œè¿™é‡Œä¸å†å¹²æ¶‰
        if not os.path.exists(self.db_path):
             print(f"âš ï¸ Warning: DB not found at {self.db_path}. Please ensure create_tg_db.py has been run.")

    def save_scan_session(self, strategy_name, vix, count, _u1, _u2, _u3, results_pack):
        """ä¿å­˜å•æ¬¡æ‰«æçš„æ‰€æœ‰ç»“æœ"""
        conn = sqlite3.connect(self.db_path)
        c = conn.cursor()
        
        try:
            # 1. åˆ›å»ºæ‰¹æ¬¡
            # å¯¹åº” DB å­—æ®µ: universe_size (ä¸æ˜¯ ticker_count)
            current_time = datetime.now().isoformat()
            
            c.execute("""INSERT INTO scan_batches 
                      (timestamp, strategy_name, market_vix, universe_size) 
                      VALUES (?, ?, ?, ?)""",
                      (current_time, strategy_name, vix, count))
            batch_id = c.lastrowid
            
            # 2. æ’å…¥è¯¦æƒ…
            for item in results_pack:
                row, ctx, bp, gate = item
                
                # æ’å…¥å¿«ç…§
                # å¯¹åº” DB è¡¨: market_snapshots
                c.execute("""INSERT INTO market_snapshots 
                          (batch_id, symbol, price, iv_short, iv_base, edge) 
                          VALUES (?, ?, ?, ?, ?, ?)""",
                          (batch_id, row.symbol, row.price, row.short_iv, row.base_iv, row.edge))
                snap_id = c.lastrowid
                
                # å‡†å¤‡ Plan æ•°æ®
                # [models.py] ScanRow ç±»æ˜ç¡®æœ‰ tag å­—æ®µï¼Œç›´æ¥è¯»å–
                tag_val = row.tag 
                est_gamma = row.meta.get("est_gamma", 0.0)
                
                # è“å›¾æ•°æ®å¤„ç†
                est_debit = 0.0
                strat_name = "NONE"
                
                if bp:
                    est_debit = bp.est_debit
                    # [models.py] Blueprint ç±»æ˜ç¡®å­—æ®µåä¸º strategy
                    strat_name = bp.strategy 
                
                # æ’å…¥è®¡åˆ’
                # å¯¹åº” DB è¡¨: trade_plans
                # å¯¹åº” DB å­—æ®µ: strategy_type (è¿™æ˜¯å»ºè¡¨æ—¶çš„åˆ—å), tag
                # æ³¨æ„ï¼štrade_plans è¡¨æ²¡æœ‰ symbol å­—æ®µ (é€šè¿‡ snapshot_id å…³è”)ï¼Œä¸è¦å¼ºè¡Œå†™å…¥
                c.execute("""INSERT INTO trade_plans 
                          (snapshot_id, strategy_type, cal_score, gate_status, est_debit, total_gamma, tag) 
                          VALUES (?, ?, ?, ?, ?, ?, ?)""",
                          (snap_id, strat_name, row.cal_score, gate, est_debit, est_gamma, tag_val))
                
            conn.commit()
            print(f"ğŸ’¾ [DB] Persistent Success. Batch ID: {batch_id}")
            
        except Exception as e:
            # æ‰“å°è¯¦ç»†é”™è¯¯ï¼Œä¸å†æ©ç›–
            import traceback
            traceback.print_exc()
            print(f"âŒ [DB Error] Save failed: {e}")
        finally:
            conn.close()

================================================================================
FILE_PATH: src\trade_guardian\app\renderer.py
================================================================================
from __future__ import annotations
import os
from typing import List, Optional, Any
from trade_guardian.domain.models import ScanRow

# === 1. å®šä¹‰é¢œè‰²ä»£ç  ===
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    WARNING = '\033[93m' # é»„è‰²
    FAIL = '\033[91m'    # çº¢è‰²
    ENDC = '\033[0m'     # é‡ç½®é¢œè‰²
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

# è®© Windows ç»ˆç«¯æ”¯æŒ ANSI é¢œè‰²
os.system('')

class ScanlistRenderer:
    def __init__(self, cfg=None, policy=None, hv_cache_path: Optional[str] = None):
        self.cfg = cfg
        self.policy = policy
        self.hv_cache_path = hv_cache_path

    def _sanitize_int(self, value: Any, default: int = 0) -> int:
        """é˜²å¾¡æ€§ç¼–ç¨‹ï¼šç¡®ä¿è¿”å›çš„ä¸€å®šæ˜¯ int"""
        try:
            if isinstance(value, int): return value
            if isinstance(value, str) and value.isdigit(): return int(value)
            if isinstance(value, list): return self._sanitize_int(value[0], default) if value else default
            return default
        except:
            return default

    # [ä¸»æ¸²æŸ“å…¥å£]
    def render(self, 
               strict: List[ScanRow], 
               auto_adjusted: List[ScanRow], 
               watch: List[ScanRow], 
               days: int, 
               min_score: int = 0, 
               max_risk: int = 100, 
               detail: bool = False, 
               universe_size: int = 0,
               top: Any = 0, 
               **kwargs): # åæ‰æ‰€æœ‰æœªå®šä¹‰çš„å‚æ•°
        
        # æ¸…ç† top å‚æ•°
        safe_top = self._sanitize_int(top, 0)
        
        # æ‰“å°å¤´éƒ¨ä¿¡æ¯
        print("")
        print("=" * 95)
        print(f"ğŸ§  {Colors.HEADER}TRADE GUARDIAN :: SCANLIST (days={days}){Colors.ENDC}")
        print("=" * 95)
        
        # ç»Ÿè®¡ä¿¡æ¯
        adjusted_list = auto_adjusted if auto_adjusted else []
        total = universe_size if universe_size > 0 else (len(strict) + len(adjusted_list) + len(watch))
        
        print(f"Universe size: {total} | Strict: {len(strict)} | AutoAdjusted: {len(adjusted_list)} | Watch: {len(watch)} | Errors: 0")
        print(f"Strict Filter: score >= {min_score}, short_risk <= {max_risk}")
        if self.hv_cache_path:
            print(f"Throttle: 0.50s/ticker | HV cache: {self.hv_cache_path}")
        
        # æ‰“å°è¡¨æ ¼
        if strict:
            self._print_table(f"âœ… {Colors.GREEN}Strict Candidates (actionable now){Colors.ENDC}", strict)
            if detail:
                self._print_details("Top details (per-row explain)", strict)
                # æ‰“å°è“å›¾ (å»æ‰äº† Strategy #3 çš„æ–‡å­—)
                self._print_blueprints(f"ğŸš€ {Colors.CYAN}Actionable Blueprints{Colors.ENDC}", strict)

        if adjusted_list:
            self._print_table("ğŸ¤– Auto-Adjusted Candidates", adjusted_list)

        if watch:
            self._print_table("ğŸ‘€ Watchlist", watch)

    # [è¯Šæ–­ä¿¡æ¯å…¥å£]
    def render_diagnostics(self, strict: List[ScanRow], **kwargs):
        if not strict: return

        print(f"\nğŸ§¾ Diagnostics")
        avg_score = sum(r.cal_score for r in strict) / len(strict)
        
        # è®¡ç®—å¹³å‡ Edge
        valid_edges = [r.edge for r in strict if r.edge > 0]
        avg_edge = sum(valid_edges) / len(valid_edges) if valid_edges else 0.0
        
        print(f"   â€¢ Avg Score: {avg_score:.1f} | Avg Edge: {avg_edge:.2f}x")

    # [å†…éƒ¨ helper] æ‰“å°è¡¨æ ¼
    def _print_table(self, title: str, rows: List[ScanRow]):
        if not rows: return
        if title: print(f"\n{title}")
        
        header = f"{'Sym':<6} {'Px':<7} {'ShortExp':<10} {'ShortDTE':>8} {'ShortIV':>8} {'BaseIV':>8} {'Edge':>7} {'HV%':>5} {'Score':>7} {'Risk':>6} {'Tag':<11}"
        print(header)
        print("-" * len(header))
        
        for r in rows:
            # IV ä¿®æ­£ï¼šé™¤ä»¥ 100
            short_iv_val = r.short_iv / 100.0
            base_iv_val = r.base_iv / 100.0
            
            row_str = (
                f"{r.symbol:<6} "
                f"{r.price:<7.2f} "
                f"{r.short_exp:<10} "
                f"{r.short_dte:>8} "
                f"{short_iv_val:>8.1%} "
                f"{base_iv_val:>8.1%} "
                f"{r.edge:>6.2f}x "
                f"{r.hv_rank:>4.0f}% "
                f"{r.cal_score:>7} "
                f"{r.short_risk:>6} "
                f"{r.tag:<11}"
            )
            print(row_str)

    # [å†…éƒ¨ helper] æ‰“å°è¯¦æƒ…
    def _print_details(self, title: str, rows: List[ScanRow]):
        print(f"\n{title}")
        print("Explain legend")
        print("  score parts: b=base, rg=regime, ed=edge, hv=HV-rank slot, cv=curvature, pen=penalties")
        print("  risk  parts: b=base, dte=time-to-expiry, gm=gamma proxy, cv=curvature risk, rg=regime risk, pen=penalties")
        
        for r in rows:
            bd = r.score_breakdown
            rbd = r.risk_breakdown
            print(f"\n  {Colors.BOLD}{r.symbol:<6}{Colors.ENDC} score={r.cal_score:<3} [b{bd.base:+} rg{bd.regime:+} ed{bd.edge:+} hv{bd.hv:+} cv{bd.curvature:+} pen{bd.penalties:+}] | edge={r.edge:.2f}x tag={r.tag} hv={r.hv_rank:.0f}%")
            print(f"         risk={r.short_risk:<3} [b{rbd.base:+} dte{rbd.dte:+} gm{rbd.gamma:+} cv{rbd.curvature:+} rg{rbd.regime:+}] | short={r.short_exp} d{r.short_dte}")

    # [å†…éƒ¨ helper] æ‰“å°è“å›¾ (åŒ…å« Greeks)
    def _print_blueprints(self, title: str, rows: List[ScanRow]):
        valid_rows = [r for r in rows if getattr(r, 'blueprint', None)]
        if not valid_rows: return

        print(f"\n{title}")
        print("-" * 95)
        for r in valid_rows:
            bp = r.blueprint
            
            # æ‘˜è¦è¡Œ
            line = bp.one_liner()
            if "est_debit=" in line:
                parts = line.split("est_debit=")
                line = f"{parts[0]}{Colors.CYAN}est_debit={parts[1]}{Colors.ENDC}"
            print(f"  {line}")
            
            # Note è¡Œ
            note = getattr(bp, "note", "")
            if note:
                if "WARNING" in note or "Risk" in note:
                    print(f"    Note: {Colors.FAIL}{note}{Colors.ENDC}")
                elif "Healthy" in note:
                    print(f"    Note: {Colors.GREEN}{note}{Colors.ENDC}")
                else:
                    print(f"    Note: {note}")

            # è…¿éƒ¨è¯¦æƒ… (å¸¦ Greeks)
            if hasattr(bp, "short_exp") and hasattr(bp, "long_exp"):
                # Diagonal / PMCC / Calendar
                if hasattr(bp, "short_strike") and hasattr(bp, "long_strike"):
                     # PMCC
                     s_delta = bp.short_greeks.get("delta", 0) if getattr(bp, "short_greeks", None) else 0
                     l_delta = bp.long_greeks.get("delta", 0) if getattr(bp, "long_greeks", None) else 0
                     print(f"    Legs: +{bp.long_exp} ({bp.long_strike}C) [Î”{l_delta:.2f}]")
                     print(f"          -{bp.short_exp} ({bp.short_strike}C) [Î”{s_delta:.2f}]")
                else:
                     # Calendar
                     print(f"    Legs: -{bp.short_exp} / +{bp.long_exp} @ Strike {bp.strike}")
            
            elif hasattr(bp, "exp"):
                # Straddle
                atm_gamma = bp.greeks.get("gamma", 0) if getattr(bp, "greeks", None) else 0
                atm_delta = bp.greeks.get("delta", 0) if getattr(bp, "greeks", None) else 0
                print(f"    Legs: +{bp.exp} CALL & PUT @ Strike {bp.strike} [Î”{atm_delta:.2f} Î“{atm_gamma:.3f}]")
            
            else:
                print(f"    Legs: (Unknown structure)")

        print("-" * 95)
        print("")

================================================================================
FILE_PATH: src\trade_guardian\app\__init__.py
================================================================================


================================================================================
FILE_PATH: src\trade_guardian\domain\features.py
================================================================================
from __future__ import annotations

from typing import Dict, List

from trade_guardian.domain.models import HVInfo, TermPoint
from trade_guardian.domain.policy import ShortLegPolicy


class TSFeatureBuilder:
    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy

    @staticmethod
    def _eligible_points(term: List[TermPoint], min_dte: int) -> List[TermPoint]:
        return [p for p in term if p.dte >= min_dte]

    @staticmethod
    def _baseline_iv(term: List[TermPoint], fallback_iv: float) -> float:
        mids = [p.iv for p in term if 30 <= p.dte <= 90 and p.iv > 0]
        if mids:
            return float(sum(mids) / len(mids))
        return float(fallback_iv)

    def build(self, term: List[TermPoint], hv: HVInfo, rank: int) -> Dict[str, object]:
        if not term:
            return {"status": "Error", "msg": "Empty term structure"}

        eligible = self._eligible_points(term, self.policy.min_dte)
        if not eligible:
            return {"status": "Error", "msg": f"No eligible expiries (min_dte={self.policy.min_dte})"}

        if rank < 0 or rank >= len(eligible):
            return {"status": "Error", "msg": f"Rank out of range: rank={rank} eligible={len(eligible)}"}

        short = eligible[rank]
        base_iv = self._baseline_iv(term, fallback_iv=short.iv)

        # regime: compare base vs short
        if base_iv > short.iv * 1.03:
            regime = "CONTANGO"
        elif short.iv > base_iv * 1.03:
            regime = "BACKWARDATION"
        else:
            regime = "FLAT"

        # curvature: compare rank0 (nearest eligible) vs short
        front = eligible[0]
        squeeze_ratio = (front.iv / base_iv) if base_iv > 0 else 0.0

        # spiky front when rank0 materially richer than short rank
        curv = "SPIKY_FRONT" if (front.iv > short.iv * 1.20 and front.dte < 14) else "NORMAL"

        edge = (short.iv / base_iv) if base_iv > 0 else 0.0

        return {
            "status": "Success",
            "regime": regime,
            "curvature": curv,
            "short_exp": short.exp,
            "short_dte": short.dte,
            "short_iv": short.iv,
            "base_iv": base_iv,
            "edge": edge,
            "squeeze_ratio": squeeze_ratio,
        }


================================================================================
FILE_PATH: src\trade_guardian\domain\hv.py
================================================================================
from __future__ import annotations

from trade_guardian.domain.models import HVInfo
from trade_guardian.infra.cache import JsonDailyCache
from trade_guardian.infra.schwab_client import SchwabClient


class HVService:
    def __init__(self, client: SchwabClient, cache: JsonDailyCache):
        self.client = client
        self.cache = cache

    def get_hv(self, symbol: str) -> HVInfo:
        cached = self.cache.get(symbol)
        if cached:
            return HVInfo(**cached)

        hv = self.client.calculate_hv_percentile(symbol)
        # store even if partial to avoid repeated API spam
        self.cache.set(symbol, hv.__dict__)
        return hv


================================================================================
FILE_PATH: src\trade_guardian\domain\models.py
================================================================================
from __future__ import annotations
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any

# --- åŸºç¡€è®¾æ–½ç±» (ç”¨äº SchwabClient ç­‰) ---

@dataclass
class HVInfo:
    """Historical Volatility Data Container"""
    current_hv: float = 0.0
    hv_rank: float = 0.0
    hv_percentile: float = 0.0
    high_52w: float = 0.0
    low_52w: float = 0.0
    # [Fix] è¡¥å…¨ SchwabClient éœ€è¦çš„çŠ¶æ€å­—æ®µ
    status: str = "Success"
    msg: str = ""
    # [Optional] å¦‚æœè¿˜éœ€è¦å…¶ä»–ç»Ÿè®¡å­—æ®µï¼Œå¯ä»¥åœ¨æ­¤ä¿ç•™
    hv_low: float = 0.0
    hv_high: float = 0.0
    p50: float = 0.0
    p75: float = 0.0
    p90: float = 0.0

@dataclass
class TermPoint:
    """Term Structure Point (ç”¨äº term structure è®¡ç®—)"""
    exp: str = "" # [Fix] ç¡®ä¿æœ‰é»˜è®¤å€¼ï¼Œå¯¹åº” date_iso
    exp_date: str = "" # å…¼å®¹æ—§ä»£ç 
    dte: int = 0
    iv: float = 0.0
    strike: float = 0.0
    mark: float = 0.0
    delta: float = 0.0
    theta: float = 0.0
    gamma: float = 0.0

# --- æ ¸å¿ƒåˆ†æç±» ---

@dataclass
class IVData:
    rank: float = 0.0
    percentile: float = 0.0
    current_iv: float = 0.0
    hv_rank: float = 0.0
    current_hv: float = 0.0

@dataclass
class Context:
    symbol: str
    price: float
    iv: IVData
    hv: IVData
    tsf: dict  # Term Structure Factors
    raw_chain: dict
    metrics: Any = None # Optional for Greeks

@dataclass
class ScoreBreakdown:
    base: int = 0
    regime: int = 0
    edge: int = 0
    hv: int = 0
    curvature: int = 0
    penalties: int = 0

@dataclass
class RiskBreakdown:
    base: int = 0
    dte: int = 0
    gamma: int = 0
    regime: int = 0
    curvature: int = 0
    penalties: int = 0

@dataclass
class ScanRow:
    symbol: str
    price: float
    short_exp: str
    short_dte: int
    short_iv: float
    base_iv: float
    edge: float
    hv_rank: float
    regime: str
    curvature: str
    tag: str
    cal_score: int
    short_risk: int
    score_breakdown: ScoreBreakdown
    risk_breakdown: RiskBreakdown
    meta: Dict[str, Any] = field(default_factory=dict)

@dataclass
class Recommendation:
    strategy: str
    symbol: str
    action: str
    rationale: str
    entry_price: float
    score: int
    conviction: str
    meta: dict

# --- æ‰§è¡Œè“å›¾ç±» (Orchestrator éœ€è¦) ---

@dataclass
class OrderLeg:
    """å®šä¹‰æœŸæƒç­–ç•¥çš„ä¸€æ¡è…¿"""
    symbol: str
    action: str      # BUY / SELL
    ratio: int       # e.g. 1
    exp: str         # Expiry Date (YYYY-MM-DD)
    strike: float
    type: str        # CALL / PUT

@dataclass
class Blueprint:
    """å®šä¹‰æœ€ç»ˆç”Ÿæˆçš„æ‰§è¡Œè“å›¾"""
    symbol: str
    strategy: str
    legs: List[OrderLeg] = field(default_factory=list)
    est_debit: float = 0.0
    note: str = ""
    gamma_exposure: float = 0.0
    error: Optional[str] = None

================================================================================
FILE_PATH: src\trade_guardian\domain\policy.py
================================================================================
from dataclasses import dataclass
from typing import List


@dataclass(frozen=True)
class ShortLegPolicy:
    base_rank: int = 1
    min_dte: int = 3
    max_probe_rank: int = 3  # count, e.g. 3 => ranks base..base+2

    def probe_ranks(self) -> List[int]:
        if self.max_probe_rank <= 1:
            return [self.base_rank]
        return list(range(self.base_rank, self.base_rank + self.max_probe_rank))


================================================================================
FILE_PATH: src\trade_guardian\domain\registry.py
================================================================================
from __future__ import annotations

from trade_guardian.domain.policy import ShortLegPolicy

from trade_guardian.strategies.auto import AutoStrategy  # <--- æ–°å¢
from trade_guardian.strategies.calendar import CalendarStrategy
from trade_guardian.strategies.hv_calendar import HVCalendarStrategy
from trade_guardian.strategies.long_gamma import LongGammaStrategy
from trade_guardian.strategies.diagonal import DiagonalStrategy



class StrategyRegistry:
    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy

    def get(self, name: str):
        n = (name or "").strip().lower()

        if n in ("calendar", "cal"):
            return CalendarStrategy(self.cfg, self.policy)

        if n in ("hv_calendar", "hvcal", "hv"):
            return HVCalendarStrategy(self.cfg, self.policy)
            
        if n in ("long_gamma", "gamma", "straddle", "lg"):
            return LongGammaStrategy(self.cfg, self.policy)
        
        if n in ("diagonal", "pmcc", "diag"):
            return DiagonalStrategy(self.cfg, self.policy)
        
        # æ³¨å†Œ auto
        if n in ("auto", "smart", "default"):
            return AutoStrategy(self.cfg, self.policy)
        


        # æ›´æ–°æŠ¥é”™ä¿¡æ¯ï¼Œæç¤ºç”¨æˆ·æ”¯æŒçš„æ–°ç­–ç•¥
        raise KeyError(f"Unknown strategy: {name}. Available: calendar, hv_calendar, long_gamma")

================================================================================
FILE_PATH: src\trade_guardian\domain\scoring.py
================================================================================
from __future__ import annotations

from dataclasses import dataclass

from trade_guardian.domain.models import ScoreBreakdown


@dataclass(frozen=True)
class ScoringRules:
    # core
    min_edge_short_base: float = 1.05

    # HV-aware (Strategy #2)
    hv_enabled: bool = False
    hv_low_rank: float = 20.0
    hv_mid_rank: float = 50.0
    hv_high_rank: float = 70.0

    hv_low_bonus: int = 10     # hv_rank <= low
    hv_mid_bonus: int = 4      # (low, mid]
    hv_high_penalty: int = -4  # (mid, high]
    hv_extreme_penalty: int = -10  # > high


class Scoring:
    def __init__(self, rules: ScoringRules):
        self.rules = rules

    def _hv_points(self, hv_rank: float) -> int:
        """
        HV scoring (explainable bucket model):
          - low hv_rank: calendars generally benefit from "room for vol expansion"
          - high hv_rank: you're paying rich vol; calendar can become "chasing vol"
        """
        if not self.rules.hv_enabled:
            return 0

        r = float(hv_rank)
        if r <= self.rules.hv_low_rank:
            return int(self.rules.hv_low_bonus)
        if r <= self.rules.hv_mid_rank:
            return int(self.rules.hv_mid_bonus)
        if r <= self.rules.hv_high_rank:
            return int(self.rules.hv_high_penalty)
        return int(self.rules.hv_extreme_penalty)

    def score_calendar(self, regime: str, curvature: str, edge: float, hv_rank: float) -> tuple[int, ScoreBreakdown]:
        """
        Keep simple & explainable:
          base 50
          +curv bonus when SPIKY_FRONT
          edge: reward if >= min_edge_short_base, penalty if weak
          regime: penalize CONTANGO a bit, neutral FLAT, small bonus BACKWARDATION
          hv: optional bucketed adjustment (Strategy #2)
        """
        bd = ScoreBreakdown(base=50)

        # regime
        if regime == "CONTANGO":
            bd.regime = -8
        elif regime == "BACKWARDATION":
            bd.regime = +4
        else:
            bd.regime = 0

        # curvature
        bd.curvature = +6 if curvature == "SPIKY_FRONT" else 0

        # edge
        if edge >= self.rules.min_edge_short_base:
            bd.edge = +8
        elif edge >= 1.0:
            bd.edge = -8
        else:
            bd.edge = -14

        # hv (strategy #2)
        bd.hv = self._hv_points(hv_rank)

        total = bd.base + bd.regime + bd.edge + bd.hv + bd.curvature + bd.penalties
        return int(total), bd


================================================================================
FILE_PATH: src\trade_guardian\domain\__init__.py
================================================================================



================================================================================
FILE_PATH: src\trade_guardian\infra\cache.py
================================================================================
from __future__ import annotations

import json
import os
from datetime import datetime
from typing import Any, Dict, Optional


class JsonDailyCache:
    """
    Simple daily cache. Resets automatically each day by storing a date stamp.
    """
    def __init__(self, path: str):
        self.path = path
        self._data: Dict[str, Any] = {}
        self._load()

    def _load(self):
        if not os.path.exists(self.path):
            self._data = {"_date": self._today(), "items": {}}
            return
        try:
            with open(self.path, "r", encoding="utf-8") as f:
                self._data = json.load(f)
        except Exception:
            self._data = {"_date": self._today(), "items": {}}

        if self._data.get("_date") != self._today():
            self._data = {"_date": self._today(), "items": {}}

    def _save(self):
        os.makedirs(os.path.dirname(self.path), exist_ok=True)
        with open(self.path, "w", encoding="utf-8") as f:
            json.dump(self._data, f, indent=2)

    @staticmethod
    def _today() -> str:
        return datetime.now().strftime("%Y-%m-%d")

    def get(self, key: str) -> Optional[dict]:
        return self._data.get("items", {}).get(key)

    def set(self, key: str, value: dict) -> None:
        self._data.setdefault("items", {})[key] = value
        self._save()


================================================================================
FILE_PATH: src\trade_guardian\infra\config.py
================================================================================
from __future__ import annotations

import json
import os
from typing import Any, Dict, Optional

from trade_guardian.domain.policy import ShortLegPolicy

DEFAULT_CONFIG: Dict[str, Any] = {
    "paths": {
        "tickers_csv": "data/tickers.csv",
        "cache_dir": "cache",
    },
    "scan": {
        "throttle_sec": 0.50,
        "contract_type": "ALL",
    },
    "rules": {
        "min_edge_short_base": 1.05,
    },
    "policy": {
        "base_rank": 1,
        "min_dte": 3,
        # å…¼å®¹ä¸¤ç§å†™æ³•ï¼šprobe_count / max_probe_rank
        # - probe_count=3 => æ¢æµ‹ base..base+2
        "probe_count": 3,
        # "max_probe_rank": 3,
    },
    "strategies": {
        "hv_calendar": {
            "hv_rules": {
                "hv_low_rank": 20.0,
                "hv_mid_rank": 50.0,
                "hv_high_rank": 70.0,
                "hv_low_bonus": 10,
                "hv_mid_bonus": 4,
                "hv_high_penalty": -4,
                "hv_extreme_penalty": -10,
            }
        }
    },
}


def _deep_merge(a: Dict[str, Any], b: Dict[str, Any]) -> Dict[str, Any]:
    out = dict(a)
    for k, v in b.items():
        if isinstance(v, dict) and isinstance(out.get(k), dict):
            out[k] = _deep_merge(out[k], v)  # type: ignore[arg-type]
        else:
            out[k] = v
    return out


def load_config(path: str, default_cfg: Dict[str, Any]) -> Dict[str, Any]:
    if not os.path.exists(path):
        return dict(default_cfg)
    with open(path, "r", encoding="utf-8") as f:
        user_cfg = json.load(f)
    if not isinstance(user_cfg, dict):
        return dict(default_cfg)
    return _deep_merge(default_cfg, user_cfg)


def write_config_template(path: str, default_cfg: Dict[str, Any], overwrite: bool = False) -> None:
    if os.path.exists(path) and not overwrite:
        return
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        json.dump(default_cfg, f, indent=2, ensure_ascii=False)


def merge_config_paths(cfg: Dict[str, Any], root: str, csv_override: Optional[str]) -> Dict[str, Any]:
    out = dict(cfg)
    out.setdefault("paths", {})
    paths = dict(out["paths"])

    if csv_override:
        paths["tickers_csv"] = csv_override

    tickers_csv = paths.get("tickers_csv", "data/tickers.csv")
    if not os.path.isabs(tickers_csv):
        tickers_csv = os.path.join(root, tickers_csv)
    paths["tickers_csv"] = os.path.normpath(tickers_csv)

    cache_dir = paths.get("cache_dir", "cache")
    if not os.path.isabs(cache_dir):
        cache_dir = os.path.join(root, cache_dir)
    paths["cache_dir"] = os.path.normpath(cache_dir)

    out["paths"] = paths
    return out


def _resolve_probe_count(pcfg: Dict[str, Any], base_rank: int) -> int:
    """
    Return probe_count (>=1).
    æ”¯æŒï¼š
      - policy.probe_count
      - policy.max_probe_rank (inclusive)
    """
    if "probe_count" in pcfg and pcfg.get("probe_count") is not None:
        try:
            c = int(pcfg["probe_count"])
            return max(1, c)
        except Exception:
            return 3

    if "max_probe_rank" in pcfg and pcfg.get("max_probe_rank") is not None:
        try:
            mx = int(pcfg["max_probe_rank"])
            # max_probe_rank is inclusive absolute rank; convert to count
            return max(1, (mx - int(base_rank) + 1))
        except Exception:
            return 3

    return 3


def policy_from_cfg_and_cli(cfg: Dict[str, Any], args) -> ShortLegPolicy:
    """
    Build ShortLegPolicy from config + CLI overrides.

    CLI args:
      --short-rank
      --min-short-dte
      --max-probe-rank   (meaning: absolute inclusive rank upper bound)
    """
    pcfg = (cfg.get("policy", {}) or {})

    base_rank = int(pcfg.get("base_rank", 1))
    min_dte = int(pcfg.get("min_dte", 3))
    probe_count = _resolve_probe_count(pcfg, base_rank)

    # CLI overrides
    if getattr(args, "short_rank", None) is not None:
        base_rank = int(args.short_rank)
    if getattr(args, "min_short_dte", None) is not None:
        min_dte = int(args.min_short_dte)

    if getattr(args, "max_probe_rank", None) is not None:
        mx = int(args.max_probe_rank)
        probe_count = max(1, (mx - int(base_rank) + 1))

    # âœ… ç”¨ä½ç½®å‚æ•°ï¼šé¿å… dataclass å­—æ®µåå˜åŒ–å¯¼è‡´çš„ keyword å´©æºƒ
    # çº¦å®šï¼šShortLegPolicy(base_rank, min_dte, probe_count)
    return ShortLegPolicy(int(base_rank), int(min_dte), int(probe_count))


================================================================================
FILE_PATH: src\trade_guardian\infra\rate_limit.py
================================================================================
import time


class RateLimiter:
    def __init__(self, throttle_sec: float):
        self.throttle_sec = float(throttle_sec)

    def sleep(self):
        if self.throttle_sec > 0:
            time.sleep(self.throttle_sec)


================================================================================
FILE_PATH: src\trade_guardian\infra\retry_option_chain.py
================================================================================
from __future__ import annotations

import json
import logging
import random
import time
from dataclasses import dataclass, asdict
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Callable, Dict, Optional, Tuple

log = logging.getLogger(__name__)


@dataclass(frozen=True)
class RetryConfig:
    max_attempts: int = 3
    base_sleep_s: float = 0.5      # first backoff
    max_sleep_s: float = 4.0       # cap
    jitter_s: float = 0.15         # random +/- jitter
    timeout_s: float = 10.0        # if your client supports timeout, pass it through


@dataclass
class FetchAttemptRecord:
    ts_utc: str
    symbol: str
    provider: str
    attempt: int
    max_attempts: int
    ok: bool

    # request parameters you care about
    request_params: Dict[str, Any]

    # response/exception info
    reason: str = ""               # classified reason string
    http_status: Optional[int] = None
    error: str = ""                # exception message if any
    response_meta: Dict[str, Any] = None  # optional: headers, request_id, etc.
    response_snippet: str = ""     # short text snippet (safe length)


class OptionChainFetchError(RuntimeError):
    pass


def _utc_now_iso() -> str:
    return datetime.now(timezone.utc).isoformat(timespec="seconds")


def _safe_snippet(s: Any, max_len: int = 400) -> str:
    if s is None:
        return ""
    try:
        txt = s if isinstance(s, str) else json.dumps(s, ensure_ascii=False)
    except Exception:
        txt = repr(s)
    txt = txt.replace("\n", " ").replace("\r", " ")
    return txt[:max_len]


def classify_empty_response(
    *,
    payload: Any,
    http_status: Optional[int] = None,
    error: Optional[BaseException] = None,
) -> str:
    """
    Return a stable machine-readable reason.
    Keep this conservative: it's for diagnostics, not logic.
    """
    if error is not None:
        msg = str(error).lower()
        if "timeout" in msg:
            return "timeout"
        if "rate" in msg or "429" in msg:
            return "rate_limited"
        if "403" in msg or "forbidden" in msg:
            return "forbidden"
        if "401" in msg or "unauthorized" in msg:
            return "unauthorized"
        if "not found" in msg or "404" in msg:
            return "not_found"
        if "connection" in msg or "ssl" in msg:
            return "network_error"
        return "exception"

    if http_status is not None:
        if http_status == 204:
            return "no_content"
        if http_status == 404:
            return "not_found"
        if http_status == 401:
            return "unauthorized"
        if http_status == 403:
            return "forbidden"
        if http_status == 429:
            return "rate_limited"
        if 500 <= http_status <= 599:
            return "server_error"
        if 400 <= http_status <= 499:
            return "client_error"

    # payload-level hints
    if payload is None:
        return "payload_none"
    if isinstance(payload, (list, tuple)) and len(payload) == 0:
        return "payload_empty_list"
    if isinstance(payload, dict) and len(payload.keys()) == 0:
        return "payload_empty_dict"

    # common shapes: provider returns {"errors":[...]} or {"message": "..."}
    if isinstance(payload, dict):
        if "error" in payload:
            return "payload_error_field"
        if "errors" in payload and payload.get("errors"):
            return "payload_errors"
        if "message" in payload and payload.get("message"):
            return "payload_message"
        # option-chain typical: chain/expirations missing
        for k in ("callExpDateMap", "putExpDateMap", "options", "data"):
            if k in payload and not payload.get(k):
                return f"payload_missing_{k}"

    return "unknown_empty_or_unexpected"


def _write_jsonl(path: Path, record: Dict[str, Any]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("a", encoding="utf-8") as f:
        f.write(json.dumps(record, ensure_ascii=False) + "\n")


def fetch_with_retry_and_diagnostics(
    *,
    symbol: str,
    provider: str,
    request_params: Dict[str, Any],
    fetch_fn: Callable[[Dict[str, Any]], Tuple[Any, Optional[int], Dict[str, Any]]],
    # fetch_fn contract:
    #   input: request_params
    #   return: (payload, http_status, response_meta)
    #   - http_status may be None if not available
    #   - response_meta may include request_id, headers, url, etc.
    retry: RetryConfig = RetryConfig(),
    diag_jsonl_path: Path = Path("cache") / "option_chain_failures.jsonl",
    # If True: only retry on transient reasons; if False: retry all failures
    retry_only_transient: bool = True,
) -> Any:
    """
    This function is meant to sit in your infra layer.
    It does:
      - retry/backoff
      - classify failures and write JSONL diagnostic records
    """

    transient_reasons = {
        "timeout",
        "network_error",
        "server_error",
        "rate_limited",
        "no_content",
        "unknown_empty_or_unexpected",
        "payload_none",
        "payload_empty_list",
        "payload_empty_dict",
    }

    last_error: Optional[BaseException] = None
    last_reason = "unknown"
    last_status: Optional[int] = None
    last_meta: Dict[str, Any] = {}

    for attempt in range(1, retry.max_attempts + 1):
        try:
            payload, http_status, response_meta = fetch_fn(request_params)
            last_status = http_status
            last_meta = response_meta or {}

            # treat "empty payload" as failure that can be retried (often transient)
            is_empty = payload is None
            if not is_empty and isinstance(payload, (list, tuple, dict)):
                is_empty = (len(payload) == 0)

            if is_empty:
                reason = classify_empty_response(payload=payload, http_status=http_status)
                last_reason = reason

                rec = FetchAttemptRecord(
                    ts_utc=_utc_now_iso(),
                    symbol=symbol,
                    provider=provider,
                    attempt=attempt,
                    max_attempts=retry.max_attempts,
                    ok=False,
                    request_params=request_params,
                    reason=reason,
                    http_status=http_status,
                    error="",
                    response_meta=response_meta or {},
                    response_snippet=_safe_snippet(payload),
                )
                _write_jsonl(diag_jsonl_path, asdict(rec))

                # decide retry
                if attempt < retry.max_attempts and (not retry_only_transient or reason in transient_reasons):
                    _sleep_backoff(attempt, retry)
                    continue

                raise OptionChainFetchError(f"{symbol}: empty option chain payload ({reason})")

            # success
            return payload

        except Exception as e:
            last_error = e
            reason = classify_empty_response(payload=None, http_status=last_status, error=e)
            last_reason = reason

            rec = FetchAttemptRecord(
                ts_utc=_utc_now_iso(),
                symbol=symbol,
                provider=provider,
                attempt=attempt,
                max_attempts=retry.max_attempts,
                ok=False,
                request_params=request_params,
                reason=reason,
                http_status=last_status,
                error=str(e),
                response_meta=last_meta or {},
                response_snippet="",
            )
            _write_jsonl(diag_jsonl_path, asdict(rec))

            if attempt < retry.max_attempts and (not retry_only_transient or reason in transient_reasons):
                _sleep_backoff(attempt, retry)
                continue

            raise

    # should never reach
    if last_error is not None:
        raise last_error
    raise OptionChainFetchError(f"{symbol}: failed to fetch option chain ({last_reason})")


def _sleep_backoff(attempt: int, retry: RetryConfig) -> None:
    # exponential backoff with jitter
    base = retry.base_sleep_s * (2 ** (attempt - 1))
    sleep_s = min(retry.max_sleep_s, base)
    sleep_s += random.uniform(-retry.jitter_s, retry.jitter_s)
    sleep_s = max(0.0, sleep_s)
    time.sleep(sleep_s)


================================================================================
FILE_PATH: src\trade_guardian\infra\schwab_client.py
================================================================================
from __future__ import annotations

import requests
import numpy as np
import pandas as pd
import traceback
from datetime import datetime, timedelta, date
from urllib.parse import quote
from typing import Optional, Any

from trade_guardian.domain.models import Context, IVData, HVInfo, TermPoint
from trade_guardian.infra.schwab_token_manager import fetch_schwab_token

# --- Helper Functions (å®šä¹‰åœ¨ç±»å¤–éƒ¨) ---
def _to_date(iso: str) -> date:
    return datetime.strptime(iso, "%Y-%m-%d").date()

def is_third_friday(d: date) -> bool:
    """åˆ¤æ–­æ˜¯å¦ä¸ºæ ‡å‡†æœˆåº¦æœŸæƒ (ç¬¬ä¸‰ä¸ªå‘¨äº”)"""
    # Friday is 4, range 15-21 ensures it's the 3rd Friday
    return d.weekday() == 4 and 15 <= d.day <= 21

def get_series_kind(exp_str: str) -> str:
    """æ ¹æ®åˆ°æœŸæ—¥åˆ¤æ–­åˆçº¦ç±»å‹ï¼šMONTHLY, WEEKLY, DAILY"""
    d = _to_date(exp_str)
    if is_third_friday(d): return "MONTHLY"
    if d.weekday() == 4: return "WEEKLY"
    return "DAILY"

class SchwabClient:
    OPTION_CHAIN_URL = "https://api.schwabapi.com/marketdata/v1/chains"
    QUOTE_URL_TEMPLATE = "https://api.schwabapi.com/marketdata/v1/quotes?symbols={symbols}&fields=quote"
    PRICE_HISTORY_URL = "https://api.schwabapi.com/marketdata/v1/pricehistory"

    def __init__(self, cfg: dict = None):
        self.cfg = cfg or {}

    def build_context(self, symbol: str, days: int = 600) -> Optional[Context]:
        """
        Orchestrator è°ƒç”¨çš„æ ‡å‡†å…¥å£ã€‚
        è´Ÿè´£è·å– Price, IV, HV, Option Chain å¹¶ç»„è£…æˆ Context å¯¹è±¡ã€‚
        """
        try:
            # 1. è·å– HV æ•°æ®
            hv_info = self.calculate_hv_percentile(symbol)
            if getattr(hv_info, 'status', '') == "Error":
                hv_info = HVInfo(current_hv=0.0, hv_rank=50.0)

            # 2. è·å– Term Structure å’Œ Chain
            try:
                price, term_points, raw_chain = self.scan_atm_term(symbol, days)
            except Exception as e:
                # print(f"  [Warn] Chain scan failed for {symbol}: {e}")
                return None

            if not term_points:
                return None

            # 3. åˆ†ææœŸé™ç»“æ„ (Term Structure)
            term_points.sort(key=lambda x: x.dte)

            # --- [Step A: å¯»æ‰¾ Short Leg (ç›®æ ‡ 1-10 DTE)] ---
            short_candidates = [p for p in term_points if 1 <= p.dte <= 10]
            if short_candidates:
                # é¿å¼€ 0DTEï¼Œé€‰æœ€è¿‘çš„
                short_point = min(short_candidates, key=lambda x: x.dte if x.dte > 0 else 999)
            else:
                short_point = term_points[0]
            
            # æå– Short çš„ç‰¹å¾ï¼Œä¾›åç»­åŒ¹é…
            short_kind = get_series_kind(short_point.exp)
            short_weekday = _to_date(short_point.exp).weekday()

            # --- [Step B: å¯»æ‰¾ Micro Base (çŸ­æœŸèŠ‚å¥, å¼ºåˆ¶ > Short)] ---
            # ç›®æ ‡ï¼šå¯»æ‰¾æ¯” Short æ›´è¿œçš„ä¸‹ä¸€é˜¶åˆçº¦ (Next Step)
            # ä¿®æ­£æ ¸å¿ƒï¼šp.dte > short_point.dte
            micro_target = 10
            micro_pool = [p for p in term_points if short_point.dte < p.dte <= 21]
            
            micro_point = None
            if not micro_pool:
                # æç½•è§æƒ…å†µï¼šæ²¡æœ‰æ¯” Short æ›´è¿œçš„åˆçº¦äº†ï¼Œé€€åŒ–ä¸º Short (Edge=0)
                micro_point = short_point
            else:
                # 1. ä¼˜å…ˆæ‰¾åŒ Weekday (æ—¥æœŸå¯¹æ—¥æœŸ)
                micro_best = [p for p in micro_pool if _to_date(p.exp).weekday() == short_weekday]
                
                if not micro_best:
                    # 2. é€€å›åŒ Kind (æ¯”å¦‚éƒ½æ˜¯ Weekly)
                    micro_best = [p for p in micro_pool if get_series_kind(p.exp) == short_kind]
                
                if not micro_best:
                     # 3. å…œåº• (åªè¦æ¯” Short è¿œå°±è¡Œ)
                     micro_best = micro_pool

                # åœ¨ç¬¦åˆæ¡ä»¶çš„æ± å­é‡Œï¼Œæ‰¾æœ€æ¥è¿‘ micro_target (10) çš„
                micro_point = min(micro_best, key=lambda x: abs(x.dte - micro_target))

            # --- [Step C: å¯»æ‰¾ Month Base (ç»“æ„é”šç‚¹, ç›®æ ‡ 25-50 DTE)] ---
            month_target = 30
            month_pool = [p for p in term_points if 25 <= p.dte <= 50]
            
            month_point = None
            if not month_pool:
                # å…œåº•å…¨åœºæ‰¾æœ€æ¥è¿‘ 30 çš„
                month_point = min(term_points, key=lambda x: abs(x.dte - month_target))
            else:
                # 1. ä¼˜å…ˆæ‰¾åŒ Kind (ä¸»è¦æ˜¯ Monthly å¯¹ Monthly)
                month_best = [p for p in month_pool if get_series_kind(p.exp) == short_kind]
                
                if not month_best:
                    # 2. å…œåº•å…¨åœº
                    month_best = month_pool
                
                month_point = min(month_best, key=lambda x: abs(x.dte - month_target))

            # ----------------------------------------

            # 4. æ•°æ®è®¡ç®—ä¸ç»„è£…
            short_iv = short_point.iv
            micro_iv = micro_point.iv
            month_iv = month_point.iv
            
            # é˜²æ­¢é™¤é›¶
            if micro_iv == 0: micro_iv = short_iv if short_iv > 0 else 1.0
            if month_iv == 0: month_iv = short_iv if short_iv > 0 else 1.0

            # 5. ç»„è£… TSFï¼šåŒ…å«åŒåŸºå‡†å…¨é‡ä¿¡æ¯
            tsf = {
                "regime": "NORMAL", # å ä½
                "curvature": "FLAT",
                
                # Short Leg Info
                "short_exp": short_point.exp,
                "short_dte": short_point.dte,
                "short_iv": short_iv,
                "short_kind": short_kind,

                # Micro Base Info
                "micro_exp": micro_point.exp,
                "micro_dte": micro_point.dte,
                "micro_iv": micro_iv,
                
                # Month Base Info
                "month_exp": month_point.exp,
                "month_dte": month_point.dte,
                "month_iv": month_iv,
                
                # Pre-calculated Edges (åŒ Edge)
                "edge_micro": (micro_iv - short_iv) / short_iv if short_iv > 0 else 0.0,
                "edge_month": (month_iv - short_iv) / short_iv if short_iv > 0 else 0.0
            }

            # 6. ç»„è£… Greeks & Data Assembly
            iv_data = IVData(
                rank=hv_info.hv_rank, 
                percentile=0.0, 
                current_iv=short_iv, 
                hv_rank=hv_info.hv_rank, 
                current_hv=hv_info.current_hv
            )
            
            class Metrics: pass
            metrics = Metrics()
            metrics.gamma = short_point.gamma
            metrics.delta = short_point.delta
            metrics.theta = short_point.theta

            # 7. è¿”å› Context
            return Context(
                symbol=symbol,
                price=price,
                iv=iv_data,
                hv=iv_data, 
                tsf=tsf,
                raw_chain=raw_chain,
                metrics=metrics
            )

        except Exception as e:
            print(f"âŒ [Error] build_context critical fail for {symbol}: {e}")
            return None

    # --- åŸºç¡€ API æ–¹æ³• ---

    def _headers(self):
        token = fetch_schwab_token()
        if not token: raise ValueError("Token fetch failed")
        return {"Authorization": f"Bearer {token}", "Accept": "application/json"}

    def get_quote(self, symbol: str) -> dict:
        encoded = quote(symbol, safe="")
        url = self.QUOTE_URL_TEMPLATE.format(symbols=encoded)
        resp = requests.get(url, headers=self._headers(), timeout=20)
        return resp.json().get(symbol, {}).get("quote", {}) or {}

    def calculate_hv_percentile(self, symbol: str) -> HVInfo:
        try:
            params = {"symbol": symbol, "periodType": "year", "period": 2, "frequencyType": "daily", "frequency": 1}
            resp = requests.get(self.PRICE_HISTORY_URL, headers=self._headers(), params=params, timeout=30)
            data = resp.json()
            candles = data.get("candles") or []
            if not candles: return HVInfo(status="Error")

            df = pd.DataFrame(candles)
            df["close"] = df["close"].astype(float)
            df["log_ret"] = np.log(df["close"] / df["close"].shift(1))
            df["hv"] = df.dropna(subset=["log_ret"])["log_ret"].rolling(window=20).std() * np.sqrt(252) * 100
            
            current_hv = float(df["hv"].iloc[-1])
            recent = df["hv"].dropna().tail(252)
            hv_low, hv_high = float(recent.min()), float(recent.max())
            hv_rank = (current_hv - hv_low) / (hv_high - hv_low) * 100.0 if hv_high > hv_low else 0.0
            
            return HVInfo(status="Success", current_hv=current_hv, hv_rank=hv_rank, hv_low=hv_low, hv_high=hv_high)
        except: return HVInfo(status="Error")

    def _fetch_calls_chain(self, symbol: str, from_d: str, to_d: str, range_val: str = "NTM") -> dict:
        params = {"symbol": symbol, "contractType": "ALL", "strategy": "SINGLE", "range": range_val, "fromDate": from_d, "toDate": to_d}
        resp = requests.get(self.OPTION_CHAIN_URL, headers=self._headers(), params=params, timeout=30)
        return resp.json() if resp.status_code == 200 else {}

    def scan_atm_term(self, symbol: str, days: int) -> tuple[float, list[TermPoint], dict]:
        q = self.get_quote(symbol)
        price = float(q.get("lastPrice") or 0.0)
        if price == 0: raise RuntimeError(f"No price for {symbol}")

        from_date = datetime.now().strftime("%Y-%m-%d")
        to_date = (datetime.now() + timedelta(days=days)).strftime("%Y-%m-%d")
        chain = self._fetch_calls_chain(symbol, from_date, to_date, range_val="ALL")
        call_map = chain.get("callExpDateMap") or {}

        term: list[TermPoint] = []
        for date_str, strikes_map in sorted(call_map.items()):
            parts = date_str.split(":")
            date_iso, dte = parts[0], int(parts[1])
            
            best_strike, min_dist, best_data = 0.0, 1e18, None
            for s_str, contracts in strikes_map.items():
                s_val = float(s_str)
                dist = abs(s_val - price)
                if dist < min_dist:
                    c = contracts[0]
                    iv = float(c.get("volatility", 0) or 0.0)
                    if iv > 0:
                        if iv < 5.0: iv *= 100.0
                        min_dist, best_strike = dist, s_val
                        best_data = {"iv": iv, "mark": float(c.get("mark") or 0.0), 
                                     "delta": float(c.get("delta") or 0.0), 
                                     "theta": float(c.get("theta") or 0.0), 
                                     "gamma": float(c.get("gamma") or 0.0)}
            if best_data:
                term.append(TermPoint(exp=date_iso, dte=dte, strike=best_strike, **best_data))
        return price, term, chain

================================================================================
FILE_PATH: src\trade_guardian\infra\schwab_token_manager.py
================================================================================
# trade_guardian/infra/schwab_token_manager.py
from __future__ import annotations

import os

def fetch_schwab_token() -> str:
    """
    Resolve Schwab OAuth access token.
    Priority:
      1) env SCHWAB_ACCESS_TOKEN
      2) legacy module shipped with this project: schwab_token_manager_legacy.py
      3) legacy global module name: schwab_token_manager (if user has it on PYTHONPATH)
    """
    tok = os.getenv("SCHWAB_ACCESS_TOKEN", "").strip()
    if tok:
        return tok

    # local legacy copy (recommended)
    try:
        from .schwab_token_manager_legacy import fetch_schwab_token as legacy_fetch
        tok = (legacy_fetch() or "").strip()
        if tok:
            return tok
    except Exception:
        pass

    # global legacy name (optional)
    try:
        from schwab_token_manager import fetch_schwab_token as global_fetch  # type: ignore
        tok = (global_fetch() or "").strip()
        if tok:
            return tok
    except Exception:
        pass

    raise RuntimeError(
        "Schwab token not found. "
        "Set env SCHWAB_ACCESS_TOKEN, or copy your old schwab_token_manager.py into "
        "trade_guardian/infra/schwab_token_manager_legacy.py."
    )


================================================================================
FILE_PATH: src\trade_guardian\infra\schwab_token_manager_legacy.py
================================================================================
# File: schwab_token_manager.py

import requests
import json
from typing import Optional

# --- Configuration for API Token Server ---
TOKEN_SERVER = "http://127.0.0.1:5000" # Your local token server URL

def fetch_schwab_token() -> Optional[str]:
    """
    Fetches the Schwab API access token from the local token server.
    This is a central utility function to be used by other data fetcher modules.
    """
    try:
        resp = requests.get(f"{TOKEN_SERVER}/token")
        resp.raise_for_status()
        token_data = resp.json()
        access_token = token_data.get("access_token")
        if not access_token:
            print("Error: 'access_token' key not found in token server response.")
            return None
        return access_token
    except requests.exceptions.RequestException as e:
        print(f"Error fetching Schwab token: {e}")
    except json.JSONDecodeError:
        print(f"Error decoding JSON from token server. Response: {resp.text}")
    return None

# --- Main block for standalone testing ---
if __name__ == "__main__":
    print("--- Testing Schwab Token Manager ---")
    token = fetch_schwab_token()
    if token:
        print("Successfully fetched an access token.")
        # print(f"Token (first 15 chars): {token[:15]}...") # Uncomment for more verbose testing
    else:
        print("Failed to fetch an access token.")
    print("--- Test Complete ---")

================================================================================
FILE_PATH: src\trade_guardian\infra\tickers.py
================================================================================
# src/trade_guardian/infra/tickers.py
from __future__ import annotations

from typing import List
import csv
import os
import re

_VALID = re.compile(r"^[A-Z0-9\.\-\_]+$")  # allow BRK.B, etc.

def load_tickers_csv(path: str) -> List[str]:
    """
    Load tickers from a csv where each line contains a symbol (or first column is symbol).
    Skips:
      - blank lines
      - comment lines starting with # or //
      - header-like tokens: SYMBOL, TICKER, SYM
      - invalid symbols
    """
    if not os.path.exists(path):
        raise FileNotFoundError(f"tickers.csv not found: {path}")

    out: List[str] = []
    with open(path, "r", newline="", encoding="utf-8-sig") as f:
        reader = csv.reader(f)
        for row in reader:
            if not row:
                continue
            sym = (row[0] or "").strip().upper()
            if not sym:
                continue
            if sym.startswith("#") or sym.startswith("//"):
                continue
            if sym in {"SYMBOL", "TICKER", "SYM"}:
                continue
            if not _VALID.match(sym):
                continue
            out.append(sym)

    # de-dup while keeping order
    seen = set()
    uniq: List[str] = []
    for s in out:
        if s not in seen:
            uniq.append(s)
            seen.add(s)
    return uniq


================================================================================
FILE_PATH: src\trade_guardian\infra\__init__.py
================================================================================



================================================================================
FILE_PATH: src\trade_guardian\strategies\auto.py
================================================================================
from __future__ import annotations

from typing import Optional, Tuple

from trade_guardian.domain.models import Context, Recommendation, ScanRow
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.strategies.base import Strategy

# [å…³é”®å˜æ›´] å¯¼å…¥ Diagonal è€Œä¸æ˜¯ Calendar
from trade_guardian.strategies.diagonal import DiagonalStrategy
from trade_guardian.strategies.long_gamma import LongGammaStrategy


class AutoStrategy(Strategy):
    """
    Strategy #5: Auto / Smart Router (Final Version)
    Analyzes Vol Regime & HV Rank to dispatch to the best sub-strategy.
    
    Sub-Strategies:
      1. Long Gamma (Straddle): For Low Vol / Contango environments.
      2. Diagonal (PMCC): For Mid-High Vol / Structural plays.
    
    Logic:
      - Low Vol (HV < 35): Force Long Gamma
      - High Vol (HV > 55) or Backwardation: Force Diagonal
      - Mid Vol (35 <= HV <= 55): Run BOTH, pick the one with higher Score.
    """
    name = "auto"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy
        # åˆå§‹åŒ–åŒæ ¸å¼•æ“
        self.diagonal = DiagonalStrategy(cfg, policy)     # æ›¿ä»£äº†åŸæ¥çš„ Calendar
        self.long_gamma = LongGammaStrategy(cfg, policy)

    def evaluate(self, ctx: Context) -> ScanRow:
        """
        Routing Logic:
        1. Get HV Rank & Regime
        2. Decide Strategy (Deterministic or Competitive)
        3. Delegate evaluate()
        4. Tag result with AUTO prefix
        """
        hv_rank = float(ctx.hv.hv_rank)
        regime = str(ctx.tsf.get("regime", "FLAT"))

        # --- å†³ç­–é€»è¾‘ (Brain) ---
        
        # 1. [æ˜ç¡®ä½æ³¢åŠ¨] ä¸”ç»“æ„å¥åº· -> å€¾å‘ Long Gamma
        # HV Rank < 35 ä¸”éå€’æŒ‚ï¼Œé€‚åˆåšå¤šæ³¢åŠ¨ç‡
        if hv_rank < 35 and regime != "BACKWARDATION":
            row = self.long_gamma.evaluate(ctx)
            # Tag: LG-C -> AUTO-LG-C
            row.tag = f"AUTO-{row.tag}"
            return row
        
        # 2. [æ˜ç¡®é«˜æ³¢åŠ¨] æˆ– [å€’æŒ‚] -> å€¾å‘ Diagonal (PMCC)
        # æ­¤æ—¶ä¹° Straddle å¤ªè´µï¼Œä¸å¦‚ç”¨ PMCC é™ä½æˆæœ¬æˆ–è§‚æœ›
        elif hv_rank > 55 or regime == "BACKWARDATION":
            row = self.diagonal.evaluate(ctx)
            # Tag: PMCC-C -> AUTO-PMCC-C
            row.tag = f"AUTO-{row.tag}"
            return row

        # 3. [æ¨¡ç³Šåœ°å¸¦ / ç«äº‰åŒºåŸŸ] 35 <= HV <= 55
        # ä¸¤ä¸ªç­–ç•¥éƒ½è·‘ä¸€éï¼Œè°åˆ†é«˜é€‰è°
        else:
            res_lg = self.long_gamma.evaluate(ctx)
            res_diag = self.diagonal.evaluate(ctx)

            # æ¯”è¾ƒåˆ†æ•° (Score)
            if res_lg.cal_score >= res_diag.cal_score:
                # Long Gamma èƒœå‡º
                row = res_lg
                row.tag = f"AUTO-{row.tag}"
                return row
            else:
                # Diagonal èƒœå‡º
                row = res_diag
                row.tag = f"AUTO-{row.tag}"
                return row

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        """
        Recommendation routing logic matches evaluate logic.
        """
        hv_rank = float(ctx.hv.hv_rank)
        regime = str(ctx.tsf.get("regime", "FLAT"))

        # 1. Force Long Gamma
        if hv_rank < 35 and regime != "BACKWARDATION":
            return self.long_gamma.recommend(ctx, min_score, max_risk)
        
        # 2. Force Diagonal
        elif hv_rank > 55 or regime == "BACKWARDATION":
            return self.diagonal.recommend(ctx, min_score, max_risk)
        
        # 3. Competitive
        else:
            # å¤ç”¨ evaluate çš„ç»“æœæ¥å†³å®šè°ƒç”¨è°
            row_lg = self.long_gamma.evaluate(ctx)
            row_diag = self.diagonal.evaluate(ctx)

            if row_lg.cal_score >= row_diag.cal_score:
                return self.long_gamma.recommend(ctx, min_score, max_risk)
            else:
                return self.diagonal.recommend(ctx, min_score, max_risk)

================================================================================
FILE_PATH: src\trade_guardian\strategies\base.py
================================================================================
from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Optional, Tuple

from trade_guardian.domain.models import Context, Recommendation, ScanRow


class Strategy(ABC):
    name: str = "base"

    @abstractmethod
    def evaluate(self, ctx: Context) -> ScanRow:
        raise NotImplementedError

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        """
        Optional: probe ranks to find a tradable short leg.
        For strategies that don't support probing, return (None, "-").
        """
        return None, "-"


================================================================================
FILE_PATH: src\trade_guardian\strategies\blueprint.py
================================================================================
from dataclasses import dataclass
from typing import Optional, Dict, Any

# [è¾…åŠ©å‡½æ•°å‡çº§] å°è¯•æå– Greeks
def _extract_greeks_for(chain: Dict[str, Any], side: str, exp: str, strike: float) -> Dict[str, float]:
    """å°è¯•ä»åŸå§‹æ•°æ®ä¸­æå– Delta/Gamma/Theta"""
    # æ³¨æ„ï¼šè¿™å–å†³äºä½ çš„æ•°æ®æºæ ¼å¼ã€‚
    # å‡è®¾ chain['callExpDateMap'][exp][strike][0] é‡Œé¢é™¤äº† mark è¿˜æœ‰ delta/gamma ç­‰å­—æ®µ
    # å¦‚æœæ²¡æœ‰ï¼Œè¿™ä¸ªå‡½æ•°ä¼šè¿”å›ç©ºå­—å…¸ï¼Œä¸å½±å“ç¨‹åºè¿è¡Œ
    
    side_map_key = "callExpDateMap" if side.upper() == "CALL" else "putExpDateMap"
    exp_map = chain.get(side_map_key, {})
    
    # å°è¯•æ‰¾åˆ°å¯¹åº”çš„ Expiry Key (æ¨¡ç³ŠåŒ¹é… "2026-01-02:...")
    target_key = None
    for k in exp_map.keys():
        if k.startswith(exp):
            target_key = k
            break
    
    if not target_key: return {}
    
    strikes = exp_map[target_key]
    # å¯»æ‰¾ Strike (key æ˜¯ string)
    # æµ®ç‚¹æ•°åŒ¹é…æ¯”è¾ƒéº»çƒ¦ï¼Œæˆ‘ä»¬åšä¸ªç®€å•çš„è½¬ string å°è¯•
    # æˆ–è€…éå†
    quote = None
    strike_str = f"{strike:.1f}"
    if strike_str in strikes:
        quote = strikes[strike_str][0]
    else:
        # å°è¯• float åŒ¹é…
        for s_str, q_list in strikes.items():
            if abs(float(s_str) - strike) < 0.01:
                quote = q_list[0]
                break
    
    if not quote: return {}

    return {
        "delta": float(quote.get("delta", 0.0)),
        "gamma": float(quote.get("gamma", 0.0)),
        "theta": float(quote.get("theta", 0.0))
    }

def _extract_mid_for(chain: Dict[str, Any], side: str, exp: str, strike: float) -> Optional[float]:
    # ... (ä¿æŒåŸæœ‰çš„ _extract_mid_for ä»£ç ä¸å˜) ...
    # ä¸ºäº†å®Œæ•´æ€§ï¼Œè¿™é‡Œç®€ç•¥ï¼Œè¯·ä¿ç•™ä½ åŸæ–‡ä»¶é‡Œçš„é€»è¾‘
    side_map = chain.get("callExpDateMap" if side == "CALL" else "putExpDateMap", {})
    # ... (åŸæœ‰é€»è¾‘)
    # è¿™é‡Œåªæ˜¯å ä½ï¼Œå®é™…è¯·ä¸è¦åˆ é™¤åŸæ¥çš„é€»è¾‘
    for k in side_map:
        if k.startswith(exp):
            strikes = side_map[k]
            for s_key, quotes in strikes.items():
                if abs(float(s_key) - strike) < 0.01:
                    q = quotes[0]
                    # ä¼˜å…ˆç”¨ markï¼Œæ²¡æœ‰åˆ™ç”¨ (bid+ask)/2
                    if "mark" in q: return float(q["mark"])
                    if "bid" in q and "ask" in q: return (float(q["bid"]) + float(q["ask"])) / 2.0
    return None


@dataclass
class CalendarBlueprint:
    symbol: str
    strike: float
    short_exp: str
    long_exp: str
    est_debit: Optional[float]
    note: str
    # æ–°å¢
    short_greeks: Optional[Dict[str, float]] = None
    long_greeks: Optional[Dict[str, float]] = None

    def one_liner(self) -> str:
        debit = f"{self.est_debit:.2f}" if isinstance(self.est_debit, (int, float)) else "N/A"
        return (
            f"{self.symbol} CALENDAR  "
            f"-{self.short_exp} / +{self.long_exp} @ {self.strike:g}  "
            f"est_debit={debit}"
        )

@dataclass
class StraddleBlueprint:
    symbol: str
    strike: float
    exp: str
    est_debit: Optional[float]
    note: str
    # æ–°å¢
    greeks: Optional[Dict[str, float]] = None # ATM çš„ Greeks

    def one_liner(self) -> str:
        debit = f"{self.est_debit:.2f}" if isinstance(self.est_debit, (int, float)) else "N/A"
        return (
            f"{self.symbol} STRADDLE  "
            f"BUY {self.exp} {self.strike:g} CALL/PUT  "
            f"est_debit={debit}"
        )

@dataclass
class DiagonalBlueprint:
    symbol: str
    side: str
    short_exp: str
    short_strike: float
    long_exp: str
    long_strike: float
    est_debit: Optional[float]
    width: float
    max_loss: Optional[float]
    note: str
    # æ–°å¢
    short_greeks: Optional[Dict[str, float]] = None
    long_greeks: Optional[Dict[str, float]] = None

    def one_liner(self) -> str:
        debit = f"{self.est_debit:.2f}" if isinstance(self.est_debit, (int, float)) else "N/A"
        return (
            f"{self.symbol} DIAGONAL({self.side})  "
            f"BUY {self.long_exp} {self.long_strike:g} / "
            f"SELL {self.short_exp} {self.short_strike:g}  "
            f"est_debit={debit}"
        )

# === æ›´æ–° Build å‡½æ•° ===

def build_diagonal_blueprint(
    *,
    symbol: str,
    underlying: float,
    chain: Dict[str, Any],
    short_exp: str,
    long_exp: str,
    target_short_strike: float,
    target_long_strike: float,
    side: str = "CALL",
) -> Optional[DiagonalBlueprint]:
    
    short_mid = _extract_mid_for(chain, side=side, exp=short_exp, strike=target_short_strike)
    long_mid = _extract_mid_for(chain, side=side, exp=long_exp, strike=target_long_strike)

    # [æ–°å¢] æå– Greeks
    short_greeks = _extract_greeks_for(chain, side, short_exp, target_short_strike)
    long_greeks = _extract_greeks_for(chain, side, long_exp, target_long_strike)

    est_debit = None
    note = ""
    width = abs(target_short_strike - target_long_strike)

    if isinstance(short_mid, (int, float)) and isinstance(long_mid, (int, float)):
        est_debit = float(long_mid - short_mid)
        
        # Hard Filter
        if est_debit > width:
            return None 
        else:
            note = f"Healthy PMCC Setup. Width={width:.2f}"
    else:
        return None

    return DiagonalBlueprint(
        symbol=symbol,
        side=side,
        short_exp=short_exp,
        short_strike=target_short_strike,
        long_exp=long_exp,
        long_strike=target_long_strike,
        est_debit=est_debit,
        width=width,
        max_loss=est_debit,
        note=note,
        short_greeks=short_greeks,
        long_greeks=long_greeks
    )

def build_straddle_blueprint(
    *,
    symbol: str,
    underlying: float,
    chain: Dict[str, Any],
    exp: str,
) -> Optional[StraddleBlueprint]:
    
    # è¿™é‡Œçš„é€»è¾‘ç¨å¾®ç®€åŒ–ï¼Œæˆ‘ä»¬åªå– Call çš„ Greeks åšå‚è€ƒ
    # å®é™…ä¸Š Straddle éœ€è¦ Call å’Œ Put çš„ Greeks åªæœ‰ Gamma æ˜¯ç›¸åŠ ï¼ŒDelta æ˜¯ä¸­æ€§
    
    # 1. Find ATM strike (ä¿æŒåŸæœ‰é€»è¾‘)
    call_map = chain.get("callExpDateMap", {})
    # ... (çœç•¥æŸ¥æ‰¾ ATM Strike é€»è¾‘ï¼Œä¿æŒä½ åŸæœ‰çš„)
    # å‡è®¾æˆ‘ä»¬æ‰¾åˆ°äº† strike
    
    # ä¸ºäº†æ¼”ç¤ºï¼Œæˆ‘æŠŠåŸé€»è¾‘ç®€åŒ–å†™åœ¨è¿™é‡Œï¼Œä½ éœ€è¦ä¿ç•™ä½ åŸæ¥çš„ find strike é€»è¾‘
    target_key = None
    for k in call_map:
        if k.startswith(exp):
            target_key = k
            break
    if not target_key: return None
    
    strikes = sorted([float(s) for s in call_map[target_key].keys()])
    strike = min(strikes, key=lambda x: abs(x - underlying))
    
    # è·å–ä»·æ ¼
    call_mid = _extract_mid_for(chain, "CALL", exp, strike)
    put_mid = _extract_mid_for(chain, "PUT", exp, strike)
    
    # [æ–°å¢] è·å– Greeks
    atm_greeks = _extract_greeks_for(chain, "CALL", exp, strike)
    
    est_debit = None
    if call_mid and put_mid:
        est_debit = call_mid + put_mid
        
    return StraddleBlueprint(
        symbol=symbol,
        strike=strike,
        exp=exp,
        est_debit=est_debit,
        note="ATM strike chosen",
        greeks=atm_greeks
    )

def build_calendar_blueprint(
    *,
    symbol: str,
    underlying: float,
    chain: Dict[str, Any],
    short_exp: str,
    long_exp: str,
    prefer_side: str = "CALL"
) -> Optional[CalendarBlueprint]:
    
    # ... (ä¿ç•™åŸæœ‰ ATM Strike æŸ¥æ‰¾é€»è¾‘)
    # å‡è®¾æ‰¾åˆ° strike
    
    # æ¨¡æ‹ŸæŸ¥æ‰¾
    call_map = chain.get("callExpDateMap", {})
    target_key = None
    for k in call_map:
        if k.startswith(short_exp):
            target_key = k
            break
    if not target_key: return None
    strikes = sorted([float(s) for s in call_map[target_key].keys()])
    strike = min(strikes, key=lambda x: abs(x - underlying))
    
    short_mid = _extract_mid_for(chain, prefer_side, short_exp, strike)
    long_mid = _extract_mid_for(chain, prefer_side, long_exp, strike)
    
    # [æ–°å¢] Greeks
    short_greeks = _extract_greeks_for(chain, prefer_side, short_exp, strike)
    long_greeks = _extract_greeks_for(chain, prefer_side, long_exp, strike)
    
    est_debit = None
    if short_mid and long_mid:
        est_debit = long_mid - short_mid
        
    return CalendarBlueprint(
        symbol=symbol,
        strike=strike,
        short_exp=short_exp,
        long_exp=long_exp,
        est_debit=est_debit,
        note="ATM Calendar",
        short_greeks=short_greeks,
        long_greeks=long_greeks
    )

================================================================================
FILE_PATH: src\trade_guardian\strategies\calendar.py
================================================================================
from __future__ import annotations

from typing import Optional, Tuple

from trade_guardian.domain.models import (
    Context,
    Recommendation,
    ScanRow,
    ScoreBreakdown,
    RiskBreakdown,
)
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.domain.scoring import Scoring, ScoringRules


class CalendarStrategy:
    name = "calendar"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy
        rules = ScoringRules(min_edge_short_base=float(cfg["rules"]["min_edge_short_base"]))
        self.scoring = Scoring(rules)

    def _tag(self, regime: str, curvature: str) -> str:
        t = "F" if regime == "FLAT" else ("C" if regime == "CONTANGO" else "B")
        if curvature == "SPIKY_FRONT":
            t += "S"
        return t

    @staticmethod
    def _clamp(x: float, lo: float, hi: float) -> float:
        return max(lo, min(hi, x))

    def _risk_score(
        self,
        ctx: Context,
        *,
        short_dte: int,
        short_gamma: float,
        rank0_dte: int,
        rank0_gamma: float,
        regime: str,
        curvature: str,
        squeeze_ratio: float,
    ) -> tuple[int, RiskBreakdown]:
        """
        Continuous & explainable risk model (0..100):

        base: start at 35 (not 50) so the system has headroom.
        dte: continuous decay with DTE (shorter => higher risk)
        gamma: continuous penalty based on gamma normalized vs front (or max)
        curvature: continuous penalty based on squeeze_ratio (only when SPIKY_FRONT)
        regime: small penalty (BACKWARDATION > CONTANGO > FLAT)

        We also keep breakdown fields as integers for stable CLI output.
        """
        bd = RiskBreakdown(base=35)

        # -------- DTE penalty (continuous) --------
        # Target behavior (approx):
        #   dte ~ 1-3  => big penalty
        #   dte ~ 6    => medium
        #   dte ~ 10   => smaller
        #   dte >= 21  => near 0
        d = float(max(0, short_dte))
        # smooth curve: 0..~22 then clamp
        dte_pen = 26.0 / (1.0 + (d / 6.5) ** 1.25)  # d=6 => ~14-16 ; d=10 => ~9-11 ; d=20 => ~4
        # extra caution if front expiry is extremely close (weekly Friday effect / 0DTE clusters)
        front_pen = 0.0
        if rank0_dte <= 1:
            front_pen = 6.0
        elif rank0_dte <= 3:
            front_pen = 3.0

        bd.dte = int(round(self._clamp(dte_pen + front_pen, 0.0, 30.0)))

        # -------- Gamma penalty (continuous) --------
        # Normalize gamma: if we have rank0_gamma use it; otherwise fall back to max gamma in eligible term
        denom = rank0_gamma if rank0_gamma and rank0_gamma > 0 else 0.0
        if denom <= 0:
            # fallback: max gamma among term points we have
            try:
                denom = max(float(p.gamma) for p in ctx.term if p.gamma is not None)  # type: ignore
            except Exception:
                denom = 0.0

        g = float(short_gamma) if short_gamma is not None else 0.0
        g_norm = (g / denom) if denom > 0 else 0.0
        g_norm = self._clamp(g_norm, 0.0, 2.0)  # allow >1 if short gamma > front (rare but possible)

        # penalty curve: small when g_norm <=0.3, grows faster after 0.6
        # map roughly into 0..22
        gamma_pen = 22.0 * (g_norm ** 0.75)
        bd.gamma = int(round(self._clamp(gamma_pen, 0.0, 22.0)))

        # -------- Curvature penalty (continuous) --------
        # Use squeeze_ratio: (rank0_iv / base_iv) as a "front spike" severity.
        # Only penalize meaningfully if SPIKY_FRONT and squeeze is above mild threshold.
        curv_pen = 0.0
        if curvature == "SPIKY_FRONT":
            sr = float(squeeze_ratio) if squeeze_ratio is not None else 0.0
            # thresholded linear ramp:
            #  sr <= 1.10 => ~0
            #  sr 1.10..1.80 => 0..10
            curv_pen = 10.0 * self._clamp((sr - 1.10) / 0.70, 0.0, 1.0)

        bd.curv = int(round(self._clamp(curv_pen, 0.0, 10.0)))

        # -------- Regime penalty (small, not dominating) --------
        # BACKWARDATION means front richer -> short leg can be more dangerous (bigger adverse gamma & gap risk).
        if regime == "BACKWARDATION":
            bd.regime = 4
        elif regime == "CONTANGO":
            bd.regime = 2
        else:
            bd.regime = 0

        # -------- Penalties slot (reserved) --------
        bd.penalties = 0

        total = bd.base + bd.dte + bd.gamma + bd.curv + bd.regime + bd.penalties
        return int(self._clamp(float(total), 0.0, 100.0)), bd

    def evaluate(self, ctx: Context) -> ScanRow:
        tsf = ctx.tsf
        regime = str(tsf["regime"])
        curvature = str(tsf["curvature"])
        short_exp = str(tsf["short_exp"])
        short_dte = int(tsf["short_dte"])
        short_iv = float(tsf["short_iv"])
        base_iv = float(tsf["base_iv"])
        edge = float(tsf["edge"])
        squeeze_ratio = float(tsf.get("squeeze_ratio", 0.0))

        eligible = [p for p in ctx.term if p.dte >= self.policy.min_dte]
        if not eligible:
            # fallback: no eligible list, treat chosen short as the only reference
            rank0_dte = short_dte
            rank0_gamma = 0.0
            short_gamma = 0.0
        else:
            # rank0 refers to nearest *eligible* expiry (respect MIN_SHORT_DTE policy)
            rank0 = eligible[0]
            rank0_dte = int(rank0.dte)
            rank0_gamma = float(rank0.gamma) if rank0.gamma is not None else 0.0

            # find the chosen short point in eligible chain by matching exp or dte
            short_point = None
            for p in eligible:
                if str(p.exp) == short_exp:
                    short_point = p
                    break
            if short_point is None:
                # fallback by dte match
                for p in eligible:
                    if int(p.dte) == short_dte:
                        short_point = p
                        break
            short_gamma = float(short_point.gamma) if (short_point and short_point.gamma is not None) else 0.0

        score, bd = self.scoring.score_calendar(
            regime=regime,
            curvature=curvature,
            edge=edge,
            hv_rank=ctx.hv.hv_rank,
        )

        risk, rbd = self._risk_score(
            ctx,
            short_dte=short_dte,
            short_gamma=short_gamma,
            rank0_dte=rank0_dte,
            rank0_gamma=rank0_gamma,
            regime=regime,
            curvature=curvature,
            squeeze_ratio=squeeze_ratio,
        )

        tag = self._tag(regime, curvature)

        return ScanRow(
            symbol=ctx.symbol,
            price=float(ctx.price),
            short_exp=short_exp,
            short_dte=short_dte,
            short_iv=short_iv,
            base_iv=base_iv,
            edge=edge,
            hv_rank=float(ctx.hv.hv_rank),
            regime=regime,
            curvature=curvature,
            tag=tag,
            cal_score=int(score),
            short_risk=int(risk),
            score_breakdown=bd,
            risk_breakdown=rbd,
        )

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        """
        Probe ranks base..base+N-1 and return first rank with risk<=max_risk AND score>=min_score.
        If none, return (None, summary).
        """
        ranks = self.policy.probe_ranks()
        eligible = [p for p in ctx.term if p.dte >= self.policy.min_dte]
        if not eligible:
            return None, "-"

        # constants for risk computation
        regime = str(ctx.tsf["regime"])
        curvature = str(ctx.tsf["curvature"])
        squeeze_ratio = float(ctx.tsf.get("squeeze_ratio", 0.0))

        rank0 = eligible[0]
        rank0_dte = int(rank0.dte)
        rank0_gamma = float(rank0.gamma) if rank0.gamma is not None else 0.0

        best_attempt: Optional[Recommendation] = None
        best_summary = "-"

        for rk in ranks:
            if rk < 0 or rk >= len(eligible):
                continue

            p = eligible[rk]
            base_iv = float(ctx.tsf["base_iv"])
            edge = (float(p.iv) / base_iv) if base_iv > 0 else 0.0

            score, bd = self.scoring.score_calendar(
                regime=regime,
                curvature=curvature,
                edge=edge,
                hv_rank=ctx.hv.hv_rank,
            )

            short_gamma = float(p.gamma) if p.gamma is not None else 0.0
            risk, _ = self._risk_score(
                ctx,
                short_dte=int(p.dte),
                short_gamma=short_gamma,
                rank0_dte=rank0_dte,
                rank0_gamma=rank0_gamma,
                regime=regime,
                curvature=curvature,
                squeeze_ratio=squeeze_ratio,
            )

            tag = self._tag(regime, curvature)

            # first tradable that satisfies thresholds
            if score >= min_score and risk <= max_risk:
                rec = Recommendation(
                    rec_rank=int(rk),
                    rec_exp=str(p.exp),
                    rec_dte=int(p.dte),
                    rec_iv=float(p.iv),
                    rec_edge=float(edge),
                    rec_score=int(score),
                    rec_risk=int(risk),
                    rec_tag=tag,
                    rec_breakdown=bd,
                )
                summary = f"ok rk{rk} {p.exp} d{p.dte} e{edge:.2f} s{score} r{risk} {tag}"
                return rec, summary

            # track best attempt summary for watchlist
            if best_attempt is None or score > best_attempt.rec_score:
                best_attempt = Recommendation(
                    rec_rank=int(rk),
                    rec_exp=str(p.exp),
                    rec_dte=int(p.dte),
                    rec_iv=float(p.iv),
                    rec_edge=float(edge),
                    rec_score=int(score),
                    rec_risk=int(risk),
                    rec_tag=tag,
                    rec_breakdown=bd,
                )
                best_summary = f"best rk{rk} {p.exp} d{p.dte} e{edge:.2f} s{score} r{risk} {tag}"

        return None, best_summary


================================================================================
FILE_PATH: src\trade_guardian\strategies\diagonal.py
================================================================================
from __future__ import annotations

from typing import Optional, Tuple, List, Dict, Any

from trade_guardian.domain.models import (
    Context,
    Recommendation,
    ScanRow,
    ScoreBreakdown,
    RiskBreakdown,
)
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.strategies.base import Strategy


class DiagonalStrategy(Strategy):
    """
    Strategy #6: Diagonal Spread / PMCC (Poor Man's Covered Call)
    
    Logic:
      - Buy Deep ITM LEAPS (Long Term) -> Substitute for Stock (High Delta)
      - Sell OTM Near Term Call -> Income Generation (High Theta)
      - Ideal for Bullish Long-term + Neutral/Bullish Short-term
      - Likes Contango (Long term IV < Short term IV)
    """
    name = "diagonal"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy

    @staticmethod
    def _clamp(x: float, lo: float, hi: float) -> float:
        return max(lo, min(hi, x))
    
    def _find_strikes(self, ctx: Context, short_exp: str) -> Tuple[Optional[float], Optional[str], Optional[float]]:
        price = ctx.price
        chain = ctx.raw_chain
        
        # ---------------------------------------------------------
        # 1. å¯»æ‰¾ Short Leg (å–æ–¹è…¿) - Near Term OTM Call
        # ---------------------------------------------------------
        call_map = chain.get("callExpDateMap", {})
        short_strikes_map = None
        for k in call_map.keys():
            if k.startswith(short_exp):
                short_strikes_map = call_map[k]
                break
        
        if not short_strikes_map: 
            return None, None, None

        avail_strikes = sorted([float(s) for s in short_strikes_map.keys()])
        
        # æ‰¾ First OTMï¼Œé€šå¸¸ä¿ç•™ä¸€ç‚¹ç¼“å†² (e.g. 1.01% - 1.02%)
        # [Safety] strictly ensure it is OTM. If price is 100, we want > 101.
        short_strike = next((s for s in avail_strikes if s > price * 1.015), None)
        
        # å¦‚æœæ‰¾ä¸åˆ°åˆé€‚çš„ OTMï¼Œè¯´æ˜å½“å‰ Chain éƒ½åœ¨å®å€¼æˆ–è€…æ•°æ®ç¼ºå¤±ï¼Œä¸è¦å¼ºè¡Œé€‰å–
        if not short_strike: 
            return None, None, None

        # ---------------------------------------------------------
        # 2. å¯»æ‰¾ Long Leg (ä¹°æ–¹è…¿) - Deep ITM LEAPS
        # ---------------------------------------------------------
        long_candidates = []
        for exp_key in call_map.keys():
            parts = exp_key.split(":")
            exp_date = parts[0]
            try: 
                days = int(parts[1])
            except (IndexError, ValueError): 
                continue
            
            # LEAPS definition: usually > 1 year, but > 120 days is acceptable for diagonals
            if days > 120: 
                long_candidates.append((exp_date, days))
        
        if not long_candidates: 
            return None, None, None

        # ä¼˜å…ˆé€‰ 150-450 å¤© (Sweet spot for Theta decay curve vs Vega exposure)
        ideal = [c for c in long_candidates if 150 <= c[1] <= 450]
        if ideal:
            ideal.sort(key=lambda x: x[1])
            best_long_exp = ideal[0][0] # Pick the shortest valid LEAP to save Debit
            # best_long_days = ideal[0][1]
        else:
            long_candidates.sort(key=lambda x: x[1])
            best_long_exp = long_candidates[0][0]
            # best_long_days = long_candidates[0][1]
        
        long_strikes_map = None
        # æ¨¡ç³ŠåŒ¹é… Long Exp Key
        for k in call_map.keys():
            if k.startswith(best_long_exp):
                long_strikes_map = call_map[k]
                break
        
        if not long_strikes_map: 
            return None, None, None

        long_avail_strikes = sorted([float(s) for s in long_strikes_map.keys()])
        
        # [æ ¸å¿ƒé€»è¾‘] Select Long Strike (Deep ITM)
        # Target: ~70-75 Delta substitute. Roughly Price * 0.70 to 0.75.
        target_strike = price * 0.70 
        
        # Find closest available strike
        long_strike = min(long_avail_strikes, key=lambda x: abs(x - target_strike))

        # [Safety Check] PMCC Golden Rule: Short Strike MUST be > Long Strike
        if long_strike >= short_strike:
            # Try to force a lower strike if available
            lower_candidates = [s for s in long_avail_strikes if s < short_strike]
            if lower_candidates:
                long_strike = lower_candidates[0] # Aggressively deep
            else:
                return None, None, None # Cannot form a diagonal

        return short_strike, best_long_exp, long_strike

    def evaluate(self, ctx: Context) -> ScanRow:
        tsf = ctx.tsf
        regime = str(tsf["regime"])
        hv_rank = float(ctx.hv.hv_rank)
        price = float(ctx.price)
        
        # è·å– IV æ•°æ®
        short_iv = float(tsf["short_iv"])
        base_iv = float(tsf["base_iv"]) 
        
        # [æ–°å¢] 1. è®¡ç®— Edge (Short IV vs Long IV)
        if base_iv > 0:
            raw_edge = (short_iv - base_iv) / base_iv
        else:
            raw_edge = 0.0

        # å¯»æ‰¾ç»“æ„
        short_strike, long_exp, long_strike = self._find_strikes(ctx, str(tsf["short_exp"]))
        
        # --- Scoring (0-100) ---
        bd = ScoreBreakdown(base=50)

        # [ä¿®æ”¹] è¿ç»­æ‰“åˆ†é€»è¾‘
        edge_score = int(self._clamp(raw_edge * 100, -20, 25))
        bd.edge = edge_score

        hv_score = int((50 - hv_rank) / 3)
        bd.hv = int(self._clamp(hv_score, -15, 15))

        if regime == "CONTANGO": 
            bd.regime = +15 
        elif regime == "NORMAL": 
            bd.regime = +5
        elif regime == "BACKWARDATION": 
            bd.regime = -25 

        if not (short_strike and long_strike):
            bd.penalties = -999 
        
        # è´Ÿ Edge æƒ©ç½š
        if raw_edge < -0.05:
            bd.penalties -= 20

        score = bd.base + bd.regime + bd.edge + bd.hv + bd.curvature + bd.penalties

        # --- Risk (Gamma Integration) ---
        rbd = RiskBreakdown(base=30)
        
        # [æ–°å¢] 2. Gamma é£é™©ä¼°ç®— (è¿™å°±æ˜¯æ‚¨è¦æ‰¾çš„é€»è¾‘ï¼)
        est_gamma = 0.0 
        try:
            # ç®€åŒ–çš„ Gamma ä¼°ç®—ï¼šç”¨äºæ•æ‰ ONDS è¿™ç§çŸ­ä¹…æœŸé«˜é£é™©ç¥¨
            # å…¬å¼åŸç†: Gamma âˆ 1 / (S * Ïƒ * âˆšT)
            dte_years = max(1, int(tsf["short_dte"])) / 365.0
            if price > 0 and short_iv > 0:
                est_gamma = 0.4 / (price * short_iv * (dte_years ** 0.5))
        except:
            est_gamma = 0.0

        # Gamma é£é™©åˆ†æ¡£
        if est_gamma > 0.10: rbd.gamma = +35  # é«˜å± (å¦‚ ONDS)
        elif est_gamma > 0.05: rbd.gamma = +15
        elif est_gamma > 0.02: rbd.gamma = +5
        
        if regime == "BACKWARDATION": rbd.regime = +20

        risk = rbd.base + rbd.dte + rbd.gamma + rbd.regime

        tag = "PMCC"
        if raw_edge > 0.10: tag += "+" 

        row = ScanRow(
            symbol=ctx.symbol,
            price=price,
            short_exp=str(tsf["short_exp"]),
            short_dte=int(tsf["short_dte"]),
            short_iv=short_iv,
            base_iv=base_iv,
            edge=float(f"{raw_edge:.2f}"), # æ˜¾ç¤ºçœŸå® Edge
            hv_rank=hv_rank,
            regime=regime,
            curvature=str(tsf["curvature"]),
            tag=tag,
            cal_score=int(self._clamp(float(score), 0, 100)),
            short_risk=int(self._clamp(float(risk), 0, 100)),
            score_breakdown=bd,
            risk_breakdown=rbd,
        )

        if short_strike and long_strike:
            row.meta = {
                "strategy": "diagonal",
                "short_strike": short_strike,
                "long_exp": long_exp,
                "long_strike": long_strike,
                "spread_width": short_strike - long_strike,
                "est_gamma": float(f"{est_gamma:.4f}") # æ–¹ä¾¿è°ƒè¯•
            }
            
        return row

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        row = self.evaluate(ctx)
        
        if row.cal_score < min_score or row.short_risk > max_risk:
            return None, f"Score {row.cal_score} too low or Risk {row.short_risk} too high."
            
        if not row.meta or "long_strike" not in row.meta:
             return None, "No valid strike structure found."

        # Extract data from meta
        s_strike = row.meta["short_strike"]
        l_strike = row.meta["long_strike"]
        l_exp = row.meta["long_exp"]

        # Construct concise rationale
        rationale = (
            f"PMCC Setup: Buy {l_exp} {l_strike}C (ITM) / Sell {row.short_exp} {s_strike}C (OTM). "
            f"IV Rank {row.hv_rank:.1f} favors buying LEAPS. {row.regime} aids spread pricing."
        )

        rec = Recommendation(
            strategy=self.name,
            symbol=ctx.symbol,
            action="OPEN DIAGONAL",
            rationale=rationale,
            entry_price=ctx.price, # Reference only
            score=row.cal_score,
            conviction="MEDIUM" if row.cal_score < 75 else "HIGH",
            meta=row.meta
        )
        
        return rec, "OK"

================================================================================
FILE_PATH: src\trade_guardian\strategies\hv_calendar.py
================================================================================
from __future__ import annotations

from typing import Optional, Tuple

from trade_guardian.domain.models import Context, Recommendation, ScanRow
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.domain.scoring import Scoring, ScoringRules

# å¤ç”¨ calendar çš„é£é™©è¿ç»­æ¨¡å‹ + explainï¼ˆrisk_breakdownï¼‰
from trade_guardian.strategies.calendar import CalendarStrategy


class HVCalendarStrategy(CalendarStrategy):
    """
    Strategy #2: HV-aware calendar
      - score: calendar score + hv adjust (å†™å…¥ score_breakdown.hv)
      - risk : å¤ç”¨ CalendarStrategy._risk_scoreï¼ˆä½ å½“å‰ç‰ˆæœ¬éœ€è¦ gamma/squeeze ç­‰è¾“å…¥ï¼‰
    """
    name = "hv_calendar"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        super().__init__(cfg, policy)

        rules = ScoringRules(min_edge_short_base=float(cfg["rules"]["min_edge_short_base"]))
        self.scoring = Scoring(rules)

        hv_cfg = ((cfg.get("strategies", {}) or {}).get("hv_calendar", {}) or {})
        hv_rules = (hv_cfg.get("hv_rules", {}) or {})

        self.hv_low_rank = float(hv_rules.get("hv_low_rank", 20.0))
        self.hv_mid_rank = float(hv_rules.get("hv_mid_rank", 50.0))
        self.hv_high_rank = float(hv_rules.get("hv_high_rank", 70.0))

        self.hv_low_bonus = int(hv_rules.get("hv_low_bonus", 10))
        self.hv_mid_bonus = int(hv_rules.get("hv_mid_bonus", 4))
        self.hv_high_penalty = int(hv_rules.get("hv_high_penalty", -4))
        self.hv_extreme_penalty = int(hv_rules.get("hv_extreme_penalty", -10))

    def _hv_adjust(self, hv_rank: float) -> int:
        if hv_rank <= self.hv_low_rank:
            return self.hv_low_bonus
        if hv_rank <= self.hv_mid_rank:
            return self.hv_mid_bonus
        if hv_rank <= self.hv_high_rank:
            return 0
        if hv_rank <= 90.0:
            return self.hv_high_penalty
        return self.hv_extreme_penalty

    @staticmethod
    def _find_point_gamma(ctx: Context, exp: str, dte: int) -> float:
        """
        Best-effort: åœ¨ ctx.term é‡ŒæŒ‰ exp+dte æ‰¾å¯¹åº”ç‚¹çš„ gammaã€‚
        æ‰¾ä¸åˆ°å°±é€€åŒ–ä¸º 0.0ï¼ˆé£é™©æ¨¡å‹ä»å¯è·‘ï¼Œåªæ˜¯ gamma åˆ†é¡¹ä¼šåå°/ä¸º 0ï¼‰ã€‚
        """
        for p in ctx.term:
            if str(p.exp) == str(exp) and int(p.dte) == int(dte):
                try:
                    return float(getattr(p, "gamma", 0.0) or 0.0)
                except Exception:
                    return 0.0
        return 0.0

    @staticmethod
    def _best_effort_squeeze_ratio(ctx: Context) -> float:
        """
        squeeze_ratio åœ¨ä½ é¡¹ç›®é‡Œå¯èƒ½ï¼š
          - å·²ç»ç”± TSFeatureBuilder å†™å…¥ ctx.tsf["squeeze_ratio"]
          - æˆ–è€…æ²¡æœ‰ï¼ˆæ—©å…ˆè¾“å‡ºæ›¾å‡ºç° N/Aï¼‰
        è¿™é‡Œç»Ÿä¸€è¿”å› floatï¼Œç¼ºå¤±å°± 0.0ã€‚
        """
        try:
            v = ctx.tsf.get("squeeze_ratio", 0.0)  # type: ignore
            return float(v) if v is not None else 0.0
        except Exception:
            return 0.0

    def evaluate(self, ctx: Context) -> ScanRow:
        tsf = ctx.tsf
        regime = str(tsf["regime"])
        curvature = str(tsf["curvature"])
        short_exp = str(tsf["short_exp"])
        short_dte = int(tsf["short_dte"])
        short_iv = float(tsf["short_iv"])
        base_iv = float(tsf["base_iv"])
        edge = float(tsf["edge"])
        hv_rank = float(ctx.hv.hv_rank)

        # ---------------- score (HV-aware) ----------------
        score, bd = self.scoring.score_calendar(
            regime=regime,
            curvature=curvature,
            edge=edge,
            hv_rank=hv_rank,
        )
        hv_adj = self._hv_adjust(hv_rank)
        bd.hv = int(hv_adj)
        score = int(score + hv_adj)

        # ---------------- risk (reuse calendar continuous model) ----------------
        eligible = [p for p in ctx.term if int(p.dte) >= int(self.policy.min_dte)]
        rank0_dte = int(eligible[0].dte) if eligible else int(short_dte)
        rank0_gamma = float(getattr(eligible[0], "gamma", 0.0) or 0.0) if eligible else 0.0

        short_gamma = self._find_point_gamma(ctx, exp=short_exp, dte=short_dte)
        squeeze_ratio = self._best_effort_squeeze_ratio(ctx)

        # âœ… å…³é”®ï¼šä¸¥æ ¼æŒ‰ä½ å½“å‰ calendar.py çš„ keyword-only å‚æ•°ç­¾åè°ƒç”¨
        risk, rbd = self._risk_score(
            ctx,
            short_dte=short_dte,
            short_gamma=short_gamma,
            rank0_dte=rank0_dte,
            rank0_gamma=rank0_gamma,
            regime=regime,
            curvature=curvature,
            squeeze_ratio=squeeze_ratio,
        )

        tag = self._tag(regime, curvature)

        row = ScanRow(
            symbol=ctx.symbol,
            price=float(ctx.price),
            short_exp=short_exp,
            short_dte=short_dte,
            short_iv=short_iv,
            base_iv=base_iv,
            edge=edge,
            hv_rank=hv_rank,
            regime=regime,
            curvature=curvature,
            tag=tag,
            cal_score=int(score),
            short_risk=int(risk),
            score_breakdown=bd,
        )

        # renderer ç”¨ getattrï¼Œæ‰€ä»¥æˆ‘ä»¬ç”¨ setattr æŒ‚ä¸Š explain å­—æ®µ
        setattr(row, "risk_breakdown", rbd)
        setattr(row, "squeeze_ratio", squeeze_ratio)

        return row

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        ranks = self.policy.probe_ranks()
        eligible = [p for p in ctx.term if int(p.dte) >= int(self.policy.min_dte)]
        if not eligible:
            return None, "-"

        hv_rank = float(ctx.hv.hv_rank)
        hv_adj = self._hv_adjust(hv_rank)
        squeeze_ratio = self._best_effort_squeeze_ratio(ctx)

        rank0_dte = int(eligible[0].dte)
        rank0_gamma = float(getattr(eligible[0], "gamma", 0.0) or 0.0)

        best: Optional[Recommendation] = None
        best_summary = "-"

        for rk in ranks:
            if rk < 0 or rk >= len(eligible):
                continue

            p = eligible[rk]

            base_iv = float(ctx.tsf["base_iv"])
            edge = (float(p.iv) / base_iv) if base_iv > 0 else 0.0

            regime = str(ctx.tsf["regime"])
            curvature = str(ctx.tsf["curvature"])

            score, bd = self.scoring.score_calendar(regime=regime, curvature=curvature, edge=edge, hv_rank=hv_rank)
            bd.hv = int(hv_adj)
            score = int(score + hv_adj)

            short_gamma = float(getattr(p, "gamma", 0.0) or 0.0)

            risk, rbd = self._risk_score(
                ctx,
                short_dte=int(p.dte),
                short_gamma=short_gamma,
                rank0_dte=rank0_dte,
                rank0_gamma=rank0_gamma,
                regime=regime,
                curvature=curvature,
                squeeze_ratio=squeeze_ratio,
            )

            tag = self._tag(regime, curvature)

            if score >= min_score and risk <= max_risk:
                rec = Recommendation(
                    rec_rank=int(rk),
                    rec_exp=str(p.exp),
                    rec_dte=int(p.dte),
                    rec_iv=float(p.iv),
                    rec_edge=float(edge),
                    rec_score=int(score),
                    rec_risk=int(risk),
                    rec_tag=tag,
                    rec_breakdown=bd,
                )
                setattr(rec, "risk_breakdown", rbd)
                setattr(rec, "squeeze_ratio", squeeze_ratio)

                summary = f"ok rk{rk} {p.exp} d{p.dte} e{edge:.2f} s{score} r{risk} {tag}"
                return rec, summary

            if best is None or score > best.rec_score:
                best = Recommendation(
                    rec_rank=int(rk),
                    rec_exp=str(p.exp),
                    rec_dte=int(p.dte),
                    rec_iv=float(p.iv),
                    rec_edge=float(edge),
                    rec_score=int(score),
                    rec_risk=int(risk),
                    rec_tag=tag,
                    rec_breakdown=bd,
                )
                setattr(best, "risk_breakdown", rbd)
                setattr(best, "squeeze_ratio", squeeze_ratio)
                best_summary = f"best rk{rk} {p.exp} d{p.dte} e{edge:.2f} s{score} r{risk} {tag}"

        return None, best_summary


================================================================================
FILE_PATH: src\trade_guardian\strategies\long_gamma.py
================================================================================
from __future__ import annotations
from trade_guardian.domain.models import Context, ScanRow, ScoreBreakdown, RiskBreakdown
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.strategies.base import Strategy

class LongGammaStrategy(Strategy):
    name = "long_gamma"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy

    @staticmethod
    def _clamp(x: float, lo: float, hi: float) -> float:
        return max(lo, min(hi, x))

    def evaluate(self, ctx: Context) -> ScanRow:
        tsf = ctx.tsf
        symbol = ctx.symbol
        
        # 1. æå–ä¸‰ç‚¹æ•°æ®
        short_iv = float(tsf.get("short_iv", 0.0))
        edge_micro = float(tsf.get("edge_micro", 0.0))
        edge_month = float(tsf.get("edge_month", 0.0))
        
        # 2. è¯„åˆ†é€»è¾‘ (åŒå› å­é©±åŠ¨)
        score = 60
        # Micro Edge: çŸ­æœŸå¿…é¡»ä¾¿å®œ (æƒé‡ 40%)
        score += int(self._clamp(edge_micro * 40, -20, 20))
        # Month Edge: ç»“æ„å¿…é¡»æ”¯æ’‘ (æƒé‡ 60%)
        score += int(self._clamp(edge_month * 60, -20, 30))
        
        score = self._clamp(score, 0, 100)

        # 3. æ„é€  Gate ä¿¡å· (ä¸‰æ®µå¼é£æ§)
        gate = "WAIT"
        dna = "QUIET" # ç¨å Orchestrator ä¼šæ›´æ–°åŠ¨èƒ½
        
        # åŸºç¡€é—¨æ§›
        if score > 75 and edge_micro > 0.05 and edge_month > 0.10:
            gate = "READY" # ä»‹äº WAIT å’Œ EXEC ä¹‹é—´ï¼Œç­‰å¾…åŠ¨èƒ½è§¦å‘
        
        if symbol in ["TSLL", "TQQQ", "SOXL", "ONDS", "SMCI", "IWM"]:
            gate = "FORBID"

        # 4. æ„é€  Tag
        tag = "LG"
        if edge_micro > 0.15: tag += "-M" # Micro æå¥½
        if edge_month > 0.30: tag += "-K" # Month æå¥½ (K=Structure)

        # 5. è¿”å› ScanRow (meta æºå¸¦å…¨é‡åŒåŸºå‡†æ•°æ®)
        bd = ScoreBreakdown(base=60) 
        rbd = RiskBreakdown(base=20)
        
        row = ScanRow(
            symbol=symbol,
            price=float(ctx.price),
            short_exp=tsf.get("short_exp", ""),
            short_dte=int(tsf.get("short_dte", 0)),
            short_iv=short_iv,
            base_iv=tsf.get("month_iv", 0.0), # å…¼å®¹è€å­—æ®µ
            edge=edge_month,                 # å…¼å®¹è€å­—æ®µ
            hv_rank=50.0,
            regime="NORMAL",
            curvature="FLAT",
            tag=tag,
            cal_score=int(score),
            short_risk=20,
            score_breakdown=bd,
            risk_breakdown=rbd,
        )
        
        # å°†åŒåŸºå‡†æ”¾å…¥ metaï¼Œä¾› UI æ¸²æŸ“
        row.meta = {
            "micro_exp": tsf.get("micro_exp"),
            "micro_dte": tsf.get("micro_dte"),
            "micro_iv": tsf.get("micro_iv"),
            "edge_micro": edge_micro,
            
            "month_exp": tsf.get("month_exp"),
            "month_dte": tsf.get("month_dte"),
            "month_iv": tsf.get("month_iv"),
            "edge_month": edge_month,
            
            "est_gamma": float(ctx.metrics.gamma) * 2.0 if ctx.metrics else 0.0,
            "strike": round(float(ctx.price), 1)
        }
        return row

================================================================================
FILE_PATH: src\trade_guardian\strategies\placeholder.py
================================================================================
from __future__ import annotations

from trade_guardian.domain.models import Context, ScanRow, ScoreBreakdown
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.strategies.base import Strategy


class PlaceholderStrategy(Strategy):
    """
    Strategy #2/#3 placeholder.
    Exists to prove the framework: registry, CLI, orchestrator wiring.
    Not intended for trading logic.
    """
    name = "placeholder"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy

    def evaluate(self, ctx: Context) -> ScanRow:
        bd = ScoreBreakdown(base=0)
        return ScanRow(
            symbol=ctx.symbol,
            price=float(ctx.price),
            short_exp=ctx.tsf.get("short_exp", ""),
            short_dte=int(ctx.tsf.get("short_dte", 0)),
            short_iv=float(ctx.tsf.get("short_iv", 0.0)),
            base_iv=float(ctx.tsf.get("base_iv", 0.0)),
            edge=float(ctx.tsf.get("edge", 0.0)),
            hv_rank=float(ctx.hv.hv_rank),
            regime=str(ctx.tsf.get("regime", "FLAT")),
            curvature=str(ctx.tsf.get("curvature", "NORMAL")),
            tag="NA",
            cal_score=0,
            short_risk=100,
            score_breakdown=bd,
        )


================================================================================
FILE_PATH: src\trade_guardian\strategies\strategy2_stub.py
================================================================================
from typing import Optional, Tuple

from trade_guardian.domain.models import Context, ScanRow, Recommendation, ScoreBreakdown


class Strategy2Stub:
    """
    Reserved for strategy #2. Framework is in place.
    This stub intentionally does not implement real logic yet.
    """
    name = "strategy2"

    def __init__(self, cfg: dict):
        self.cfg = cfg

    def evaluate(self, ctx: Context) -> ScanRow:
        raise NotImplementedError("strategy2 is not implemented yet.")

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        return None, "-"


================================================================================
FILE_PATH: src\trade_guardian\strategies\__init__.py
================================================================================


================================================================================
FILE_PATH: src\trade_guardian.egg-info\dependency_links.txt
================================================================================



================================================================================
FILE_PATH: src\trade_guardian.egg-info\requires.txt
================================================================================
requests
pandas
numpy
tabulate
colorama


================================================================================
FILE_PATH: src\trade_guardian.egg-info\SOURCES.txt
================================================================================
pyproject.toml
src/trade_guardian/__init__.py
src/trade_guardian.egg-info/PKG-INFO
src/trade_guardian.egg-info/SOURCES.txt
src/trade_guardian.egg-info/dependency_links.txt
src/trade_guardian.egg-info/requires.txt
src/trade_guardian.egg-info/top_level.txt
src/trade_guardian/app/__init__.py
src/trade_guardian/app/cli.py
src/trade_guardian/app/orchestrator.py
src/trade_guardian/app/renderer.py
src/trade_guardian/domain/__init__.py
src/trade_guardian/domain/features.py
src/trade_guardian/domain/hv.py
src/trade_guardian/domain/models.py
src/trade_guardian/domain/policy.py
src/trade_guardian/domain/registry.py
src/trade_guardian/domain/scoring.py
src/trade_guardian/infra/__init__.py
src/trade_guardian/infra/cache.py
src/trade_guardian/infra/config.py
src/trade_guardian/infra/rate_limit.py
src/trade_guardian/infra/schwab_client.py
src/trade_guardian/infra/schwab_token_manager.py
src/trade_guardian/infra/tickers.py
src/trade_guardian/strategies/__init__.py
src/trade_guardian/strategies/base.py
src/trade_guardian/strategies/calendar.py
src/trade_guardian/strategies/placeholder.py
src/trade_guardian/strategies/strategy2_stub.py

================================================================================
FILE_PATH: src\trade_guardian.egg-info\top_level.txt
================================================================================
trade_guardian

