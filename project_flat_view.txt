PROJECT_ROOT: D:\workspace\trade_guardian
GENERATED_BY: merge_project.py
================================================================================


================================================================================
FILE_PATH: build_context.txt
================================================================================
create_tg_db.py:def init_db():
history_viewer.py:    def __init__(self, db_path="db/trade_guardian.db"):
history_viewer.py:    def get_latest_radar(self, symbol=None, limit=20):
history_viewer.py:    def _process_logic(self, df, latest_id, conn):
history_viewer.py:    def display(self, symbol=None):
merge_project.py:def is_text_file(file_path):
merge_project.py:def merge_project_files():
src\trade_guardian\app\cli.py:    DEFAULT_CONFIG,
src\trade_guardian\app\cli.py:def main():
src\trade_guardian\app\cli.py:    p_init.add_argument("--path", type=str, default=None, help="Output path (default: ./config/config.json)")
src\trade_guardian\app\cli.py:    p_scan.add_argument("--config", type=str, default=None, help="Config path (default: ./config/config.json)")
src\trade_guardian\app\cli.py:    p_scan.add_argument("--strategy", type=str, default="auto", help="Strategy name (default: auto)")
src\trade_guardian\app\cli.py:    p_scan.add_argument("--days", type=int, default=600)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--csv", type=str, default=None, help="Tickers csv path")
src\trade_guardian\app\cli.py:    p_scan.add_argument("--min-score", type=int, default=60)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--max-risk", type=int, default=70)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--limit", type=int, default=0)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--top", type=int, default=None, help="Only show top N sorted blueprints")
src\trade_guardian\app\cli.py:    p_scan.add_argument("--short-rank", type=int, default=None)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--min-short-dte", type=int, default=None)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--max-probe-rank", type=int, default=None)
src\trade_guardian\app\cli.py:        write_config_template(out, DEFAULT_CONFIG, overwrite=args.force)
src\trade_guardian\app\cli.py:        autogen_default = bool(DEFAULT_CONFIG.get("runtime", {}).get("autogen_config_if_missing", True))
src\trade_guardian\app\cli.py:        autogen = autogen_default
src\trade_guardian\app\cli.py:            write_config_template(cfg_path, DEFAULT_CONFIG, overwrite=False)
src\trade_guardian\app\cli.py:        cfg = load_config(cfg_path, DEFAULT_CONFIG)
src\trade_guardian\app\orchestrator.py:    def __init__(self, client, cfg: dict, policy, strategy=None):
src\trade_guardian\app\orchestrator.py:    def _get_universe(self) -> List[str]:
src\trade_guardian\app\orchestrator.py:    def scanlist(self, strategy_name: str = "auto", days: int = 600, 
src\trade_guardian\app\orchestrator.py:                ctx = self.client.build_context(ticker, days=days)
src\trade_guardian\app\orchestrator.py:    def _get_gate_status(self, row: ScanRow, bp: Optional[Blueprint], dna_type: str) -> str:
src\trade_guardian\app\orchestrator.py:    def _print_enhanced_blueprint(self, bp: Blueprint, row: ScanRow, dna: str):
src\trade_guardian\app\orchestrator.py:    def _get_temp(self, dna):
src\trade_guardian\app\orchestrator.py:    def plan(self, ctx: Context, row: ScanRow) -> Optional[Blueprint]:
src\trade_guardian\app\orchestrator.py:    def _load_strategy(self, name: str):
src\trade_guardian\app\persistence.py:    def __init__(self, db_path: str = None):
src\trade_guardian\app\persistence.py:    def save_scan_session(self, 
src\trade_guardian\app\persistence.py:    def check_iv_spikes(self, current_batch_id: int, threshold: float = 3.0) -> List[Tuple[str, float]]:
src\trade_guardian\app\persistence.py:    def get_latest_drift_1h(self, symbol: str) -> float:
src\trade_guardian\app\renderer.py:    def __init__(self, cfg=None, policy=None, hv_cache_path: Optional[str] = None):
src\trade_guardian\app\renderer.py:    def _sanitize_int(self, value: Any, default: int = 0) -> int:
src\trade_guardian\app\renderer.py:            if isinstance(value, list): return self._sanitize_int(value[0], default) if value else default
src\trade_guardian\app\renderer.py:            return default
src\trade_guardian\app\renderer.py:            return default
src\trade_guardian\app\renderer.py:    def render(self, 
src\trade_guardian\app\renderer.py:    def render_diagnostics(self, strict: List[ScanRow], **kwargs):
src\trade_guardian\app\renderer.py:    def _print_table(self, title: str, rows: List[ScanRow]):
src\trade_guardian\app\renderer.py:    def _print_details(self, title: str, rows: List[ScanRow]):
src\trade_guardian\app\renderer.py:    def _print_blueprints(self, title: str, rows: List[ScanRow]):
src\trade_guardian\domain\features.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\domain\features.py:    def _eligible_points(term: List[TermPoint], min_dte: int) -> List[TermPoint]:
src\trade_guardian\domain\features.py:    def _baseline_iv(term: List[TermPoint], fallback_iv: float) -> float:
src\trade_guardian\domain\features.py:    def build(self, term: List[TermPoint], hv: HVInfo, rank: int) -> Dict[str, object]:
src\trade_guardian\domain\hv.py:    def __init__(self, client: SchwabClient, cache: JsonDailyCache):
src\trade_guardian\domain\hv.py:    def get_hv(self, symbol: str) -> HVInfo:
src\trade_guardian\domain\models.py:    meta: Dict[str, Any] = field(default_factory=dict)
src\trade_guardian\domain\models.py:    legs: List[OrderLeg] = field(default_factory=list)
src\trade_guardian\domain\policy.py:    def probe_ranks(self) -> List[int]:
src\trade_guardian\domain\registry.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\domain\registry.py:    def get(self, name: str):
src\trade_guardian\domain\registry.py:        if n in ("auto", "smart", "default"):
src\trade_guardian\domain\scoring.py:    def __init__(self, rules: ScoringRules):
src\trade_guardian\domain\scoring.py:    def _hv_points(self, hv_rank: float) -> int:
src\trade_guardian\domain\scoring.py:    def score_calendar(self, regime: str, curvature: str, edge: float, hv_rank: float) -> tuple[int, ScoreBreakdown]:
src\trade_guardian\infra\cache.py:    def __init__(self, path: str):
src\trade_guardian\infra\cache.py:    def _load(self):
src\trade_guardian\infra\cache.py:    def _save(self):
src\trade_guardian\infra\cache.py:    def _today() -> str:
src\trade_guardian\infra\cache.py:    def get(self, key: str) -> Optional[dict]:
src\trade_guardian\infra\cache.py:    def set(self, key: str, value: dict) -> None:
src\trade_guardian\infra\cache.py:        self._data.setdefault("items", {})[key] = value
src\trade_guardian\infra\config.py:DEFAULT_CONFIG: Dict[str, Any] = {
src\trade_guardian\infra\config.py:def _deep_merge(a: Dict[str, Any], b: Dict[str, Any]) -> Dict[str, Any]:
src\trade_guardian\infra\config.py:def load_config(path: str, default_cfg: Dict[str, Any]) -> Dict[str, Any]:
src\trade_guardian\infra\config.py:        return dict(default_cfg)
src\trade_guardian\infra\config.py:        return dict(default_cfg)
src\trade_guardian\infra\config.py:    return _deep_merge(default_cfg, user_cfg)
src\trade_guardian\infra\config.py:def write_config_template(path: str, default_cfg: Dict[str, Any], overwrite: bool = False) -> None:
src\trade_guardian\infra\config.py:        json.dump(default_cfg, f, indent=2, ensure_ascii=False)
src\trade_guardian\infra\config.py:def merge_config_paths(cfg: Dict[str, Any], root: str, csv_override: Optional[str]) -> Dict[str, Any]:
src\trade_guardian\infra\config.py:    out.setdefault("paths", {})
src\trade_guardian\infra\config.py:def _resolve_probe_count(pcfg: Dict[str, Any], base_rank: int) -> int:
src\trade_guardian\infra\config.py:def policy_from_cfg_and_cli(cfg: Dict[str, Any], args) -> ShortLegPolicy:
src\trade_guardian\infra\rate_limit.py:    def __init__(self, throttle_sec: float):
src\trade_guardian\infra\rate_limit.py:    def sleep(self):
src\trade_guardian\infra\retry_option_chain.py:def _utc_now_iso() -> str:
src\trade_guardian\infra\retry_option_chain.py:def _safe_snippet(s: Any, max_len: int = 400) -> str:
src\trade_guardian\infra\retry_option_chain.py:def classify_empty_response(
src\trade_guardian\infra\retry_option_chain.py:def _write_jsonl(path: Path, record: Dict[str, Any]) -> None:
src\trade_guardian\infra\retry_option_chain.py:def fetch_with_retry_and_diagnostics(
src\trade_guardian\infra\retry_option_chain.py:def _sleep_backoff(attempt: int, retry: RetryConfig) -> None:
src\trade_guardian\infra\schwab_client.py:    def __init__(self, cfg: dict = None):
src\trade_guardian\infra\schwab_client.py:    def build_context(self, symbol: str, days: int = 600) -> Optional[Context]:
src\trade_guardian\infra\schwab_client.py:            print(f"âŒ [Error] build_context critical fail for {symbol}: {e}")
src\trade_guardian\infra\schwab_client.py:    def _headers(self):
src\trade_guardian\infra\schwab_client.py:    def get_quote(self, symbol: str) -> dict:
src\trade_guardian\infra\schwab_client.py:    def calculate_hv_percentile(self, symbol: str) -> HVInfo:
src\trade_guardian\infra\schwab_client.py:    def _fetch_calls_chain(self, symbol: str, from_d: str, to_d: str, range_val: str = "NTM") -> dict:
src\trade_guardian\infra\schwab_client.py:    def scan_atm_term(self, symbol: str, days: int, contract_type: str = "CALL") -> tuple[float, list[TermPoint], dict]:
src\trade_guardian\infra\schwab_token_manager.py:def fetch_schwab_token() -> str:
src\trade_guardian\infra\schwab_token_manager_legacy.py:def fetch_schwab_token() -> Optional[str]:
src\trade_guardian\infra\tickers.py:def load_tickers_csv(path: str) -> List[str]:
src\trade_guardian\strategies\auto.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\auto.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\auto.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian\strategies\base.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\base.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian\strategies\blueprint.py:def _extract_greeks_for(chain: Dict[str, Any], side: str, exp: str, strike: float) -> Dict[str, float]:
src\trade_guardian\strategies\blueprint.py:def _extract_mid_for(chain: Dict[str, Any], side: str, exp: str, strike: float) -> Optional[float]:
src\trade_guardian\strategies\blueprint.py:    def one_liner(self) -> str:
src\trade_guardian\strategies\blueprint.py:    def one_liner(self) -> str:
src\trade_guardian\strategies\blueprint.py:    def one_liner(self) -> str:
src\trade_guardian\strategies\blueprint.py:def build_diagonal_blueprint(
src\trade_guardian\strategies\blueprint.py:def build_straddle_blueprint(
src\trade_guardian\strategies\blueprint.py:def build_calendar_blueprint(
src\trade_guardian\strategies\calendar.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\calendar.py:    def _tag(self, regime: str, curvature: str) -> str:
src\trade_guardian\strategies\calendar.py:    def _clamp(x: float, lo: float, hi: float) -> float:
src\trade_guardian\strategies\calendar.py:    def _risk_score(
src\trade_guardian\strategies\calendar.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\calendar.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian\strategies\diagonal.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\diagonal.py:    def _clamp(x: float, lo: float, hi: float) -> float:
src\trade_guardian\strategies\diagonal.py:    def _find_strikes(self, ctx: Context, short_exp: str) -> Tuple[Optional[float], Optional[str], Optional[float]]:
src\trade_guardian\strategies\diagonal.py:            # LEAPS definition: usually > 1 year, but > 120 days is acceptable for diagonals
src\trade_guardian\strategies\diagonal.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\diagonal.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian\strategies\hv_calendar.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\hv_calendar.py:    def _hv_adjust(self, hv_rank: float) -> int:
src\trade_guardian\strategies\hv_calendar.py:    def _find_point_gamma(ctx: Context, exp: str, dte: int) -> float:
src\trade_guardian\strategies\hv_calendar.py:    def _best_effort_squeeze_ratio(ctx: Context) -> float:
src\trade_guardian\strategies\hv_calendar.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\hv_calendar.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian\strategies\long_gamma.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\long_gamma.py:    def _clamp(x: float, lo: float, hi: float) -> float:
src\trade_guardian\strategies\long_gamma.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\placeholder.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\placeholder.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\strategy2_stub.py:    def __init__(self, cfg: dict):
src\trade_guardian\strategies\strategy2_stub.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\strategy2_stub.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian.py:def run_guardian_loop():


================================================================================
FILE_PATH: create_tg_db.py
================================================================================
import sqlite3
import os
import sys
import argparse

def init_db(reset_mode=False):
    # ==========================================
    # 1. è·¯å¾„å®šä½é€»è¾‘
    # ==========================================
    # è·å–å½“å‰è„šæœ¬æ‰€åœ¨çš„æ ¹ç›®å½•
    project_root = os.path.dirname(os.path.abspath(__file__))
    
    # å®šä¹‰æ•°æ®åº“æ–‡ä»¶å¤¹å’Œæ–‡ä»¶è·¯å¾„
    db_folder = os.path.join(project_root, "db")
    db_path = os.path.join(db_folder, "trade_guardian.db")

    print(f"ğŸ“ Project Root: {project_root}")
    
    # 2. å¦‚æœ db æ–‡ä»¶å¤¹ä¸å­˜åœ¨ï¼Œåˆ›å»ºå®ƒ
    if not os.path.exists(db_folder):
        print(f"ğŸ› ï¸  Creating DB folder: {db_folder}")
        os.makedirs(db_folder)
    
    # ==========================================
    # 3. é‡ç½®é€»è¾‘ (Safety Guard)
    # ==========================================
    if os.path.exists(db_path):
        if reset_mode:
            try:
                os.remove(db_path)
                print(f"ğŸ’¥ [RESET MODE] Deleted old database: {db_path}")
            except Exception as e:
                print(f"âŒ Error deleting old DB: {e}")
                return
        else:
            print(f"ğŸ›¡ï¸  [SAFE MODE] Database exists. Keeping data. (Use --reset to wipe)")
    else:
        print(f"ğŸ†• Database not found. Creating new one.")

    print(f"ğŸ”— Connecting to database: {db_path}")
    conn = sqlite3.connect(db_path)
    c = conn.cursor()

    # ==========================================
    # 4. åˆ›å»ºè¡¨ç»“æ„ (Schema) - ä½¿ç”¨ IF NOT EXISTS
    # ==========================================

    # è¡¨ 1: Scan Batches (æ‰«ææ‰¹æ¬¡/ä¼šè¯)
    print("   ... Checking table: scan_batches")
    c.execute('''
        CREATE TABLE IF NOT EXISTS scan_batches (
            batch_id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp TEXT,           -- ç³»ç»Ÿå¯åŠ¨æ—¶é—´ (ISO æ ¼å¼)
            strategy_name TEXT,       -- è¿è¡Œçš„ç­–ç•¥ (auto/long_gamma/diagonal)
            market_vix REAL,          -- æ‰«ææ—¶çš„ VIX æŒ‡æ•°æ°´å¹³
            universe_size INTEGER,    -- æ‰«æçš„æ ‡çš„æ€»æ•°
            avg_abs_edge REAL,        -- å¸‚åœºå¹³å‡åç¦»å¼ºåº¦ (æ¸©åº¦è®¡)
            cheap_vol_pct REAL,       -- ä¾¿å®œè´§å æ¯” (Edge > 0)
            elapsed_time REAL         -- æ€»è¿è¡Œè€—æ—¶ (ç§’)
        )
    ''')

    # è¡¨ 2: Market Snapshots (è¡Œæƒ…å¿«ç…§)
    print("   ... Checking table: market_snapshots")
    c.execute('''
        CREATE TABLE IF NOT EXISTS market_snapshots (
            snapshot_id INTEGER PRIMARY KEY AUTOINCREMENT,
            batch_id INTEGER,         -- å…³è”æ‰«ææ‰¹æ¬¡
            symbol TEXT,              -- è‚¡ç¥¨ä»£ç 
            price REAL,               -- ç°ä»·
            iv_short REAL,            -- çŸ­ç«¯ IV (29 DTE)
            iv_base REAL,             -- é•¿ç«¯åŸºå‡† IV
            edge REAL,                -- Edge Value
            hv_rank REAL,             -- å†å²æ³¢åŠ¨ç‡æ’å
            regime TEXT,              -- æœŸé™ç»“æ„ (CONTANGO/BACKWARDATION)
            FOREIGN KEY(batch_id) REFERENCES scan_batches(batch_id)
        )
    ''')

    # è¡¨ 3: Trade Plans & Gates (æ‰§è¡Œè®¡åˆ’ä¸é£é™©é—¸é—¨)
    print("   ... Checking table: trade_plans")
    c.execute('''
        CREATE TABLE IF NOT EXISTS trade_plans (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            snapshot_id INTEGER,      -- å…³è”è¡Œæƒ…å¿«ç…§
            strategy_type TEXT,       -- å…·ä½“é‡‡ç”¨çš„å­ç­–ç•¥ (LG / PMCC)
            cal_score INTEGER,        -- ç­–ç•¥è¯„åˆ† (0-100)
            short_risk INTEGER,       -- é£é™©è¯„åˆ† (0-100)
            gate_status TEXT,         -- æ‰§è¡Œå›¾æ ‡ (âœ… / âš ï¸ / â›”)
            total_gamma REAL,         -- ç»„åˆæ€» Gamma
            est_debit REAL,           -- ä¼°ç®—æƒåˆ©é‡‘æˆæœ¬
            error_msg TEXT,           -- å¦‚æœè¢«æ‹’ç»ï¼Œè®°å½•åŸå›  (å¦‚ Debit > Width)
            blueprint_json TEXT,      -- å®Œæ•´çš„è“å›¾ç»“æ„ (JSON æ ¼å¼)
            tag TEXT,                 -- ç­–ç•¥æ ‡ç­¾ (LG-M-K)
            FOREIGN KEY(snapshot_id) REFERENCES market_snapshots(snapshot_id)
        )
    ''')

    conn.commit()
    
    # éªŒè¯è¡¨æ•°é‡
    c.execute("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%';")
    tables = c.fetchall()
    
    # éªŒè¯å…³é”®å­—æ®µæ˜¯å¦å­˜åœ¨ (Tag check)
    c.execute("PRAGMA table_info(trade_plans)")
    tp_info = c.fetchall()
    tp_cols = [row[1] for row in tp_info]
    
    conn.close()

    print(f"\nâœ… SUCCESS! Trade Guardian DB initialized with {len(tables)} tables:")
    for t in tables:
        print(f"   - {t[0]}")
    
    # ç®€å•çš„ Schema æ£€æŸ¥
    if 'tag' in tp_cols:
        print(f"ğŸ‰ Verification: 'tag' column exists.")
    else:
        print(f"âš ï¸  Verification Warning: 'tag' column MISSING! (You might need to run with --reset to apply new schema)")

    if 'short_risk' in tp_cols:
        print(f"ğŸ‰ Verification: 'short_risk' column exists.")
    else:
        print(f"âš ï¸  Verification Warning: 'short_risk' column MISSING!")

    print(f"\nğŸ¯ Database Location: {db_path}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Initialize Trade Guardian Database")
    parser.add_argument("--reset", action="store_true", help="âš ï¸  DANGER: Wipe existing database and start fresh")
    args = parser.parse_args()
    
    init_db(reset_mode=args.reset)

================================================================================
FILE_PATH: history_viewer.py
================================================================================
import os
import sqlite3
import pandas as pd
import sys
import time
from tabulate import tabulate
from colorama import Fore, Style, init

# åˆå§‹åŒ–é¢œè‰²ç¯å¢ƒ
init(autoreset=True)

class HistoryViewer:
    def __init__(self, db_path=None):
        if db_path:
            self.db_path = db_path
        else:
            # [FIX] (C) è·¯å¾„é”šå®šï¼šç¡®ä¿åœ¨ä»»ä½•ç›®å½•è¿è¡Œéƒ½æŒ‡å‘åŒä¸€ä¸ªåº“
            root = os.path.dirname(os.path.abspath(__file__))
            self.db_path = os.path.join(root, "db", "trade_guardian.db")


    def get_latest_radar(self, symbol=None, limit=20):
        conn = sqlite3.connect(self.db_path)
        try:
            batch_res = conn.execute("""
                SELECT b.batch_id, b.timestamp, b.market_vix 
                FROM scan_batches b
                JOIN market_snapshots s ON s.batch_id = b.batch_id
                ORDER BY b.batch_id DESC LIMIT 1
            """).fetchone()
            
            if not batch_res:
                return pd.DataFrame()
            
            latest_id, latest_time, current_vix = batch_res
            
            # [FIX] (F) Symbol è¿‡æ»¤ç”Ÿæ•ˆ
            filter_sql = "AND s.symbol = ?" if symbol else ""
            params = [latest_id, symbol, limit] if symbol else [latest_id, limit]
            
            query = f"""
            SELECT 
                s.symbol as Sym,
                s.price as Price,
                s.iv_short as IV_S,
                s.snapshot_id,
                COALESCE(p.gate_status, 'WAIT') as Gate,
                COALESCE(p.cal_score, 0) as Score,
                COALESCE(p.total_gamma, 0.0) as Gamma,
                COALESCE(p.tag, '') as Tag
            FROM market_snapshots s
            LEFT JOIN trade_plans p ON s.snapshot_id = p.snapshot_id
            WHERE s.batch_id = ? {filter_sql}
            ORDER BY Score DESC, IV_S DESC
            LIMIT ?
            """
            
            # è¿™é‡Œçš„ params å¿…é¡»è½¬æ¢æˆ tuple ä¼ ç»™ read_sql_query
            df = pd.read_sql_query(query, conn, params=tuple(params))
            
            if not df.empty:
                df['Time'] = latest_time # (B) æ­¤æ—¶å·²ç»æ˜¯ YYYY-MM-DD HH:MM:SS æ ¼å¼äº†
                df['VIX'] = current_vix
                df = self._process_logic(df, latest_id, conn)
            
            return df
        finally:
            conn.close()


    def _process_logic(self, df, latest_id, conn):
        """
        è®¡ç®—åŠ¨èƒ½ (Delta 15m / 1h)
        """
        # è·å–ä¸Šä¸€ä¸ª Batch çš„ VIX ç”¨äºè®¡ç®—å·®å€¼
        v_prev = conn.execute("SELECT market_vix FROM scan_batches WHERE batch_id = ?", (latest_id-1,)).fetchone()
        df['VIX_Î”'] = round(df['VIX'].iloc[0] - v_prev[0], 2) if v_prev else 0.0

        for i, row in df.iterrows():
            sym = row['Sym']
            # å°è¯•è·å–å†å² IV æ•°æ®
            res15 = conn.execute("SELECT iv_short FROM market_snapshots WHERE symbol=? AND batch_id=?", (sym, latest_id-1)).fetchone()
            res1h = conn.execute("SELECT iv_short FROM market_snapshots WHERE symbol=? AND batch_id=?", (sym, latest_id-4)).fetchone()

            d15 = round(row['IV_S'] - (res15[0] if res15 else row['IV_S']), 1)
            d1h = round(row['IV_S'] - (res1h[0] if res1h else row['IV_S']), 1)
            
            df.at[i, 'Î”15m'] = d15
            df.at[i, 'Î”1h'] = d1h

            # DNA åˆ¤å®š (ä»…ç”¨äºæ˜¾ç¤ºé¢œè‰²)
            dna_type = "QUIET"
            if d15 > 2.0: dna_type = "PULSE"
            elif d15 > 0.5: dna_type = "TREND"
            elif d15 < -1.0: dna_type = "CRUSH"
            
            df.at[i, 'DNA_Raw'] = dna_type
                
        return df

    def display(self, symbol=None):
        df = self.get_latest_radar(symbol=symbol)
        if df.empty:
            print(f"{Fore.RED}ğŸ“­ [Sync] Monitoring...{Style.RESET_ALL}")
            return

        formatted_rows = []
        for _, row in df.iterrows():
            # --- 1. æ•°æ®æ ¼å¼åŒ– (çº¯æ–‡æœ¬ï¼Œå›ºå®šå®½åº¦) ---
            p_str = f"{row['Price']:>10.2f}"
            iv_str = f"{row['IV_S']:>8.1f}%"
            d15_raw = f"{row['Î”15m']:>+6.1f}"
            d1h_raw = f"{row['Î”1h']:>+6.1f}"
            g_str = f"{row['Gamma']:>8.3f}"
            s_str = f"{row['Score']:>5}"
            
            # --- 2. é¢œè‰²æ¸²æŸ“ ---
            
            # åŠ¨èƒ½ (Î”15m)
            d15_render = d15_raw
            if row['Î”15m'] > 1.5: 
                d15_render = f"{Fore.RED}{d15_raw}{Style.RESET_ALL}"
            elif row['Î”15m'] < -1.5: 
                d15_render = f"{Fore.CYAN}{d15_raw}{Style.RESET_ALL}"

            # DNA çŠ¶æ€
            dna_raw = f"{row['DNA_Raw']:<6}"
            if row['DNA_Raw'] == "PULSE": dna_render = f"{Fore.CYAN}{dna_raw}{Style.RESET_ALL}"
            elif row['DNA_Raw'] == "TREND": dna_render = f"{Fore.GREEN}{dna_raw}{Style.RESET_ALL}"
            elif row['DNA_Raw'] == "CRUSH": dna_render = f"{Fore.YELLOW}{dna_raw}{Style.RESET_ALL}"
            else: dna_render = f"{Fore.WHITE}{dna_raw}{Style.RESET_ALL}"

            # Gate çŠ¶æ€ (åŒæ­¥ Orchestrator çš„é¢œè‰²é€»è¾‘)
            gate_raw = f"{row['Gate']:<6}"
            if row['Gate'] == "EXEC": gate_c = Fore.GREEN
            elif row['Gate'] == "LIMIT": gate_c = Fore.CYAN  # âœ… LIMIT æ˜¾ç¤ºä¸ºé’è‰²
            elif row['Gate'] == "FORBID": gate_c = Fore.RED
            else: gate_c = Fore.YELLOW # WAIT
            gate_render = f"{gate_c}{gate_raw}{Style.RESET_ALL}"

            # Tag æ¸²æŸ“ (âœ… å…³é”®ç‚¹)
            # ç¡®ä¿ Tag ä¸ä¸º None (æ•°æ®åº“è¯»å–å¯èƒ½ä¼šè¯»å‡º None)
            tag_val = row['Tag'] if row['Tag'] is not None else ""
            tag_render = f"{Fore.WHITE}{tag_val:<8}{Style.RESET_ALL}"

            formatted_rows.append([
                f"{Fore.LIGHTBLACK_EX}{row['Time']}{Style.RESET_ALL}",
                f"{Style.BRIGHT}{row['Sym']:<6}{Style.RESET_ALL}",
                dna_render,
                p_str,
                iv_str,
                d15_render,
                d1h_raw,
                g_str,
                f"{Fore.CYAN if row['Score'] >= 70 else Fore.WHITE}{s_str}{Style.RESET_ALL}",
                gate_render,
                tag_render  # âœ… æœ€åä¸€åˆ—
            ])

        # --- 3. å¤´éƒ¨ä¿¡æ¯ä¸æ‰“å° ---
        v_diff = df['VIX_Î”'].iloc[0]
        v_info = f" | VIX: {df['VIX'].iloc[0]} ({Fore.RED if v_diff > 0 else Fore.GREEN}{v_diff:+0.2f}{Style.RESET_ALL})"
        
        # è°ƒæ•´æ¨ªçº¿å®½åº¦ä»¥é€‚é…æ–°å¢çš„åˆ—
        print("\n" + "="*118)
        print(f"ğŸ“¡ DNA MOMENTUM RADAR | {df['Time'].iloc[0]}{v_info}")
        print("="*118)
        
        # å®šä¹‰è¡¨å¤´ï¼Œç¡®ä¿ä¸ row æ•°æ®åˆ—æ•°ä¸€è‡´
        headers = ["Time", "Sym", "DNA", "Price", "IV_S", "Î”15m", "Î”1h", "Gamma", "Score", "Gate", "Tag"]
        
        # stralign="left" é˜²æ­¢ tabulate è‡ªåŠ¨å±…ä¸­å¯¼è‡´é¢œè‰²ä»£ç é”™ä½
        print(tabulate(formatted_rows, headers=headers, tablefmt='psql', stralign="left", disable_numparse=True))
        print("\n" + "="*118)

        
if __name__ == "__main__":
    viewer = HistoryViewer()
    target_sym = sys.argv[1] if len(sys.argv) > 1 else None
    print(f"Starting Dashboard... (Target: {target_sym if target_sym else 'ALL'})")
    while True:
        try:
            viewer.display(symbol=target_sym)
            time.sleep(60)
        except KeyboardInterrupt:
            print("\nStopped.")
            break
        except Exception as e:
            # æ­¤æ—¶å¦‚æœå‡ºé”™ï¼Œè¯·å‘Šè¯‰æˆ‘é”™è¯¯ä¿¡æ¯ï¼Œä½†é€»è¾‘ä¸Šåº”è¯¥å·²ç»é—­ç¯
            print(f"Error: {e}")
            time.sleep(5)

================================================================================
FILE_PATH: pyproject.toml
================================================================================
[build-system]
requires = ["setuptools>=68"]
build-backend = "setuptools.build_meta"

[project]
name = "trade-guardian"
version = "0.1.0"
requires-python = ">=3.10"
dependencies = [
  "requests",
  "pandas",
  "numpy",
  "tabulate",
  "colorama",
]

[tool.setuptools]
package-dir = {"" = "src"}

[tool.setuptools.packages.find]
where = ["src"]


================================================================================
FILE_PATH: README.md
================================================================================


# ğŸ§  Trade Guardian (v2.0)

**Trade Guardian** æ˜¯ä¸€æ¬¾é¢å‘ä¸“ä¸šæœŸæƒäº¤æ˜“è€…çš„è‡ªåŠ¨åŒ–æ‰«æä¸æ‰§è¡Œè®¡åˆ’å·¥å…·ã€‚å®ƒä¸ä»…èƒ½å‘ç°å¸‚åœºä¸­å®šä»·åä½çš„æ³¢åŠ¨ç‡æœºä¼šï¼ˆEdgeï¼‰ï¼Œæ›´èƒ½é€šè¿‡å†…ç½®çš„ **Planner (è®¡åˆ’å™¨)** å¼ºåˆ¶æ‰§è¡Œç¡¬æ€§é£é™©æ‹¦æˆªã€‚

> **è®¾è®¡å“²å­¦**ï¼šScanner è´Ÿè´£æµ·é€‰æœºä¼šï¼ŒPlanner è´Ÿè´£ç¡®ä¿å¯äº¤æ˜“æ€§ä¸ç¡¬é£é™©é—¸é—¨ã€‚

---

## ğŸš€ æ ¸å¿ƒè¿›åŒ–åŠŸèƒ½

### 1. çœŸå®æ•°æ®é©±åŠ¨ (Schwab API)

ç³»ç»Ÿå·²å®Œå…¨æ‰“é€š **Schwab API**ï¼Œå®æ—¶è·å–ï¼š

* æ ‡çš„ç°ä»·ã€å†å²æ³¢åŠ¨ç‡ (HV) åŠ HV Rankã€‚
* ATM æœŸæƒé“¾ã€éšå«æ³¢åŠ¨ç‡ (IV) æœŸé™ç»“æ„åŠ Greeks (Gamma/Delta/Theta)ã€‚
* è‡ªåŠ¨é”å®šæµåŠ¨æ€§æœ€ä½³çš„ **æœˆåº¦æœŸæƒåˆçº¦ (Monthly OpEx)**ã€‚

### 2. å¢å¼ºå‹é£é™©å¼•æ“ (The Guardian)

* **Total Gamma ç›‘æµ‹**ï¼šè‡ªåŠ¨è®¡ç®—ç»„åˆï¼ˆå¦‚è·¨å¼ç»„åˆ Straddleï¼‰çš„æ€» Gammaï¼Œå¹¶è¿›è¡Œåˆ†çº§ï¼š
* **EXTREME â›”** (Î“ â‰¥ 0.20): æç«¯æ³¢åŠ¨é£é™©ã€‚
* **HIGH âš ï¸** (Î“ â‰¥ 0.12): é«˜é£é™©ï¼Œéœ€å¤§å¹…ç¼©å‡ä»“ä½ã€‚
* **ELEVATED ğŸ”¸** (Î“ â‰¥ 0.08): é¢„è­¦åŒºã€‚


* **PMCC å®‰å…¨é”**ï¼šç¡¬æ€§æ‰§è¡Œ `Debit < Width` æ£€æŸ¥ï¼Œè‡ªåŠ¨æ‹¦æˆªæ³¨å®šäºæŸçš„é”æ­»äº¤æ˜“ï¼ˆLocked Lossï¼‰ï¼Œå¹¶ç»™å‡ºä¿®æ­£å»ºè®®ã€‚

### 3. äº¤æ˜“å‘˜çœ‹æ¿å¼è¾“å‡º

* **Gate çŠ¶æ€åˆ—**ï¼šåœ¨æ‰«æç»“æœä¸­ç›´è§‚æ˜¾ç¤º `âœ… å¯æ‰§è¡Œ`ã€`âš ï¸ é«˜é£é™©`ã€`â›” å·²æ‹’ç»`ã€‚
* **Trader's Sort**ï¼šä¼˜å…ˆæ’åˆ—â€œé«˜ Edgeã€ä½ Riskã€Gate âœ…â€çš„æ ‡çš„ã€‚
* **Actionable Blueprints**ï¼šç”Ÿæˆå«å…·ä½“æ—¥æœŸã€è¡Œæƒä»·ã€æ–¹å‘åŠæˆæœ¬ä¼°ç®—çš„æ‰§è¡Œè“å›¾ã€‚

---

## ğŸ› ï¸ å®‰è£…ä¸é…ç½®

1. **ç¯å¢ƒè¦æ±‚**ï¼šPython 3.8+
2. **å®‰è£…ä¾èµ–**ï¼š
```bash
pip install requests pandas numpy

```


3. **æ•°æ®é…ç½®**ï¼š
* åœ¨ `data/tickers.csv` ä¸­å¡«å…¥ä½ æƒ³æ‰«æçš„è‚¡ç¥¨ä»£ç ï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰ã€‚
* ç¡®ä¿ `src/trade_guardian/infra/schwab_token_manager.py` èƒ½å¤Ÿè·å–æœ‰æ•ˆçš„ API Tokenã€‚



---

## ğŸ“– ä½¿ç”¨æŒ‡å—

### å¯åŠ¨å…¨è‡ªåŠ¨æ‰«æ

```bash
python src/trade_guardian.py scanlist --strategy auto --days 600 --detail --top 5

```

**å‚æ•°è¯´æ˜**ï¼š

* `--strategy auto`: åŒæ—¶è¿è¡Œ Long Gamma (Straddle) å’Œ Diagonal (PMCC) ç­–ç•¥ã€‚
* `--days 600`: æ‰«æè¿œç«¯æœŸæƒé“¾ï¼ˆç”¨äº PMCC å¯»æ‰¾ LEAPSï¼‰ã€‚
* `--detail`: è¾“å‡ºå…·ä½“çš„æ‰§è¡Œè“å›¾ï¼ˆActionable Blueprintsï¼‰ã€‚
* `--top 5`: ç»è¿‡æ’åºåï¼Œåªæ˜¾ç¤ºæœ€ä¼˜è´¨çš„å‰ 5 ä¸ªäº¤æ˜“è®¡åˆ’ã€‚

---

## ğŸ“Š è¾“å‡ºè§£è¯»

### æ‰«æè¡¨ (Scanner View)

| Sym | Px | ShortExp | DTE | ShortIV | Edge | Risk | Gate |
| --- | --- | --- | --- | --- | --- | --- | --- |
| AMD | 202.0 | 2026-01-16 | 29 | 45.2% | +0.13x | 20 | âœ… |
| ONDS | 7.87 | 2026-01-16 | 29 | 120.4% | +0.26x | 70 | âš ï¸ |
| MSTR | 159.2 | 2026-01-16 | 29 | 77.6% | +0.02x | 30 | â›” |

### æ‰§è¡Œè“å›¾ç¤ºä¾‹ (Execution Plan)

```text
 MSTR DIAGONAL    Est.Debit: $55.87
    +1 2026-06-18 111.0  CALL
    -1 2026-01-16 162.0  CALL
    ==============================
    â›” REJECTED: Debit > Width. Excess: $4.87.
    ==============================
    Strategy Gate: Blocked by Risk Policy.
       â€¢ Try buying deeper ITM LEAPS or RAISING Short Strike.

```

---

## ğŸ§¾ è¯Šæ–­æŒ‡æ ‡ (Diagnostics)

* **Avg |Edge|**: å¸‚åœºæ•´ä½“æ³¢åŠ¨ç‡åç¦»å¼ºåº¦ã€‚
* **Cheap Vol (%)**: å¸‚åœºä¸­å¤„äºâ€œä¾¿å®œâ€çŠ¶æ€ï¼ˆIV < HVï¼‰çš„æ ‡çš„æ¯”ä¾‹ï¼Œä½œä¸ºå¤šç©ºæƒ…ç»ªæ¸©åº¦è®¡ã€‚

---

## âš–ï¸ å…è´£å£°æ˜

æœ¬å·¥å…·ä»…ä¾›ç ”ç©¶ä¸å‚è€ƒä½¿ç”¨ï¼Œä¸æ„æˆä»»ä½•æŠ•èµ„å»ºè®®ã€‚æœŸæƒäº¤æ˜“æ¶‰åŠé«˜é£é™©ï¼Œåœ¨ä½¿ç”¨è“å›¾æ‰§è¡Œäº¤æ˜“å‰ï¼Œè¯·åŠ¡å¿…æ ¸å®å®æ—¶æŠ¥ä»·å¹¶è¿›è¡Œä¸ªäººé£é™©è¯„ä¼°ã€‚

---

**Current Version**: 2.0.0 | **Last Updated**: 2025-12-18

================================================================================
FILE_PATH: requirements.txt
================================================================================
requests
pandas
numpy
tabulate
colorama


================================================================================
FILE_PATH: TRADE GUARDIAN è·¯ç”±çŸ©é˜µ.md
================================================================================
**â€œShape Ã— Strategy Ã— Gateâ€ è·¯ç”±çŸ©é˜µ**ï¼ˆTrade Graduation / Tactical Mode ä¸“ç”¨ï¼‰ã€‚
**å…ˆå®šå½¢æ€(Shape)** â†’ **å†å®šç­–ç•¥(Route)** â†’ **å†å®šé—¨æ§›(Gate)** â†’ **æœ€åç»™æ‰§è¡ŒæŒ‡ä»¤**ã€‚

---

# TRADE GUARDIAN è·¯ç”±çŸ©é˜µï¼ˆBrain + Gate ç»Ÿä¸€ç‰ˆï¼‰

## 0) æ ¸å¿ƒè¾“å…¥ï¼ˆç³»ç»Ÿåªçœ‹è¿™å‡ é¡¹ï¼‰

* `em = edge_micro`ï¼ˆå‰ç«¯ç»“æ„ä¼˜åŠ¿ï¼‰
* `ek = edge_month`ï¼ˆåç«¯ç»“æ„ä¼˜åŠ¿ï¼‰
* `short_dte`ï¼ˆçŸ­è…¿ DTEï¼‰
* `regime`ï¼ˆBACKWARDATION / CONTANGO / FLATï¼‰
* `is_squeeze`ï¼ˆmicro_iv > month_iv * 1.05ï¼‰
* `curvature`ï¼ˆSPIKY_FRONT / NORMALï¼‰
* `momentum`ï¼ˆCRUSH / QUIET / TREND / PULSEï¼‰
* `est_gamma`ï¼ˆé£é™©ç¡¬é˜ˆå€¼ï¼‰
* Blueprint æ˜¯å¦æˆåŠŸï¼ˆbp.errorï¼‰

---

## 1) Shape åˆ†ç±»çŸ©é˜µï¼ˆå…ˆæŠŠåœ°å½¢è¯´æ¸…æ¥šï¼‰

æŒ‰ **ä¼˜å…ˆçº§** ä»ä¸Šåˆ°ä¸‹åŒ¹é…ï¼ˆå‘½ä¸­å³åœæ­¢ï¼‰ï¼š

| Priority | Shape        | åˆ¤å®šè§„åˆ™ï¼ˆå»ºè®®æ ‡å‡†ï¼‰                                               | äº¤æ˜“å«ä¹‰               |
| -------: | ------------ | -------------------------------------------------------- | ------------------ |
|        1 | **BACKWARD** | `regime == BACKWARDATION`                                | å€’æŒ‚ï¼Œå–è¿‘ç«¯=è‡ªæ€          |
|        2 | **FFBS**     | `ek >= 0.20 and em < 0.08`                               | å‰ç«¯å¹³ç¨³ã€åç«¯é™¡å³­ï¼šé»„é‡‘å¯¹è§’çº¿    |
|        3 | **SPIKE**    | `is_squeeze == True OR em >= 0.12`ï¼ˆ*ä¸è¦ç”¨ curvature å•ç‹¬è§¦å‘*ï¼‰ | å‰ç«¯æŒ¤å‹/äº‹ä»¶æ³¢ï¼šgamma é£é™©é«˜ |
|        4 | **STEEP**    | `ek >= 0.20`                                             | æ­£å¸¸åç«¯é™¡å³­ï¼Œæœ‰ç»“æ„å¯åƒ       |
|        5 | **MILD**     | `0.15 <= ek < 0.20`                                      | è½»åº¦ç»“æ„ï¼Œè¾¹ç¼˜ä¸€èˆ¬          |
|        6 | **FLAT**     | `ek < 0.15`                                              | ç»“æ„å¹³å¦ï¼Œé çº¯æ³¢åŠ¨          |

> å¤‡æ³¨ï¼šä½ ç°åœ¨è¾“å‡ºé‡Œ NVDAï¼ˆek=0.15ï¼‰åº”è¯¥æ›´åƒ **MILD** è€Œä¸æ˜¯ STEEPã€‚
> SPY é‚£ç§ â€œè¶…çŸ­ç«¯ä½IVå¯¼è‡´ curvature è™šè§¦å‘â€ ä¸åº”ç›´æ¥å˜ SPIKEâ€”â€”SPIKE å¿…é¡»é  em / squeeze ç¡®è®¤ã€‚

---

## 2) Routeï¼ˆç­–ç•¥è·¯ç”±ï¼‰çŸ©é˜µï¼šShape â†’ é€‰å“ªç§ç­–ç•¥

è¿™éƒ¨åˆ†å°±æ˜¯ä½  Brain V5 çš„â€œç»“æ„ä¼˜å…ˆâ€å“²å­¦ + äº¤æ˜“å‘˜ç°å®ï¼š

| Shape        | é»˜è®¤ç­–ç•¥ Route                    | åŸå› ï¼ˆäº¤æ˜“è¯­è¨€ï¼‰                     |
| ------------ | ----------------------------- | ---------------------------- |
| **BACKWARD** | **LGï¼ˆLong Gamma / Straddleï¼‰** | å€’æŒ‚æ—¶å–è¿‘ç«¯é£é™©çˆ†ç‚¸ï¼Œåªèƒ½ä¹° gamma é˜²å®ˆ      |
| **FFBS**     | **DIAGï¼ˆDiagonalï¼‰**            | å‰ç«¯ä½IV + åç«¯é«˜æº¢ä»·ï¼ŒTheta/Vega å·®æœ€è‚¥ |
| **STEEP**    | **DIAG ä¼˜å…ˆ**ï¼ˆè‹¥æ„å»ºå¤±è´¥â†’LGï¼‰         | æœ‰ç»“æ„å¯æ”¶å‰²ï¼Œä¸”å‰ç«¯æœªå¿…å±é™©               |
| **SPIKE**    | **LG ä¼˜å…ˆ**ï¼ˆç‰¹æ®Šæƒ…å†µæ‰ DIAGï¼‰         | å‰ç«¯æŒ¤å‹ï¼ŒçŸ­è…¿ gamma åå™¬æ¦‚ç‡é«˜          |
| **MILD**     | **LG ä¼˜å…ˆ**ï¼ˆé™¤é ek å¾ˆç¨³/ä½ æƒ³åŠ æ¡ä»¶ï¼‰     | ç»“æ„è¾¹ç¼˜ï¼Œåš DIAG æ€§ä»·æ¯”ä¸€èˆ¬            |
| **FLAT**     | **LG**                        | æ²¡ç»“æ„å°±èµŒæ³¢åŠ¨æ‰©å¼                     |

**è¡¥å……ï¼šDIAG æ„å»ºå¤±è´¥å…œåº•**

* `if diagonal.evaluate(ctx) å¤±è´¥ or metaç¼º long_strike` â†’ è‡ªåŠ¨å›è½ **LG**
  ï¼ˆä½ å·²ç»åšäº†ï¼‰

---

## 3) Gateï¼ˆæ”¾è¡ŒçŸ©é˜µï¼‰ï¼šRoute + Shape + Momentum â†’ WAIT / LIMIT / EXEC

Gate æ˜¯ â€œèƒ½ä¸èƒ½åš / æ€ä¹ˆåšâ€ çš„æœ€åè£åˆ¤ï¼Œåˆ†ä¸‰å±‚ï¼š

### 3.1 Hard Killï¼ˆæ— æ¡ä»¶ FORBIDï¼‰

| æ¡ä»¶                        | Gate       |
| ------------------------- | ---------- |
| `bp is None` æˆ– `bp.error` | **FORBID** |
| `est_gamma >= 0.30`       | **FORBID** |
| `momentum == CRUSH`       | **FORBID** |

---

### 3.2 ç»“æ„é—¨æ§›ï¼ˆSoft Gateï¼‰

ä½ ç°åœ¨çš„åº•çº¿å‚æ•°ï¼š

* `MICRO_MIN = 0.10`
* `MONTH_MIN = 0.15`

#### A) å¯¹ LGï¼ˆLong Gammaï¼‰

LG è¦æ±‚â€œå‰ç«¯ä¸èƒ½å¤ªçƒ‚â€ï¼Œå¦åˆ™ä¹°äº†ä¹Ÿæ˜¯ç£¨æŸï¼š

| æ¡ä»¶                                  | Gate     |
| ----------------------------------- | -------- |
| `em < MICRO_MIN AND ek < MONTH_MIN` | **WAIT** |
| å…¶å®ƒ                                  | è¿›å…¥åŠ¨èƒ½åˆ¤å®š   |

#### B) å¯¹ DIAGï¼ˆDiagonalï¼‰â€”â€”æ ¸å¿ƒï¼šçœ‹ ekï¼Œå¾®ç»“æ„è±å… em

| Shape                   | DIAG çš„ç»“æ„è¦æ±‚                            | Gate        |
| ----------------------- | ------------------------------------- | ----------- |
| **FFBS / STEEP**        | `ek >= MONTH_MIN`ï¼ˆè±å… emï¼‰              | è¿›å…¥åŠ¨èƒ½åˆ¤å®š      |
| **å…¶å®ƒï¼ˆFLAT/MILD/SPIKEï¼‰** | `ek >= MONTH_MIN AND em >= MICRO_MIN` | å¦åˆ™ **WAIT** |

---

### 3.3 åŠ¨èƒ½åˆ¤å®šï¼ˆEXEC vs LIMITï¼‰

åŠ¨èƒ½æ¥è‡ªä½ çš„ 15m IV å˜åŒ–ï¼ˆQUIET/TREND/PULSEï¼‰ï¼š

| Momentum          | Gate      | æ‰§è¡Œå«ä¹‰        |
| ----------------- | --------- | ----------- |
| **PULSE / TREND** | **EXEC**  | åŠ¨èƒ½ç¡®ç«‹ï¼šå¯ä»¥ä¸»åŠ¨æˆäº¤ |
| **QUIET**         | **LIMIT** | ç­‰è§¦å‘ï¼šæŒ‚å•æ½œä¼    |

---

## 4) æœ€é‡è¦çš„â€œäº¤æ˜“å‘˜è¡¥ä¸â€ï¼šSPIKE çš„ DIAG é™çº§è§„åˆ™ï¼ˆå¼ºçƒˆå»ºè®®ï¼‰

å› ä¸º SPIKE æ˜¯æœ€å®¹æ˜“æŠŠä½ ç‚¸æ‰çš„å½¢æ€ã€‚

### è§„åˆ™ï¼ˆæ¨èæœ€å°è¡¥ä¸ï¼‰

* å¦‚æœ `tag` æ˜¯ DIAG ä¸” `shape == SPIKE` ä¸” `short_dte <= 7` ä¸” `momentum == QUIET`
  â†’ **å¼ºåˆ¶ WAIT**ï¼ˆä¸å…è®¸ LIMIT è¢«åŠ¨åƒ gamma é£é™©ï¼‰

| æ¡ä»¶                                    | Gate               |
| ------------------------------------- | ------------------ |
| `DIAG & SPIKE & short_dte<=7 & QUIET` | **WAIT**           |
| `DIAG & SPIKE & (TREND/PULSE)`        | **EXEC**ï¼ˆåªæœ‰åŠ¨èƒ½ç¡®è®¤æ‰æ‰“ï¼‰ |

è¿™æ¡ä¼šè®© TSLA/QQQ/TQQQ è¿™ç§ â€œç»“æ„å¥½ä½†å‰ç«¯ä¸å®‰ç¨³â€ ä¸ä¼šå¤©å¤© LIMITã€‚

---

# æœ€ç»ˆæ€»è¡¨ï¼ˆä½ å¯ä»¥è´´ README çš„â€œå†³ç­–æ€»çŸ©é˜µâ€ï¼‰

æŒ‰å®é™…æ‰§è¡Œé¡ºåºï¼š

1. **Hard Kill**ï¼šbp/error, gamma, CRUSH â†’ FORBID
2. **Shape**ï¼šBACKWARD / FFBS / SPIKE / STEEP / MILD / FLAT
3. **Route**ï¼šBACKWARDâ†’LGï¼›FFBS/STEEPâ†’DIAGï¼›SPIKE/MILD/FLATâ†’LGï¼ˆSPIKE ç‰¹åˆ¤ï¼‰
4. **Gate-ç»“æ„**ï¼šDIAG çœ‹ ekï¼ˆFFBS/STEEP è±å… emï¼‰ï¼›LG çœ‹ em/ek åŒä½
5. **Gate-åŠ¨èƒ½**ï¼šTREND/PULSEâ†’EXECï¼›QUIETâ†’LIMIT
6. **SPIKE-DIAG é™çº§è¡¥ä¸**ï¼šSPIKE + DIAG + short_dte<=7 + QUIET â†’ WAIT

---

## å¿«é€Ÿ sanity checkï¼ˆç”¨ä½ å½“å‰è¾“å‡ºéªŒè¯ï¼‰

* **IWMï¼šFFBS + ek=0.24 + em=0.01**
  â†’ Route=DIAGï¼ŒGate ä¸æŸ¥ emï¼ˆè±å…ï¼‰â†’ QUIET â†’ LIMIT âœ…
* **SPYï¼šè¶…çŸ­ç«¯ä½IVï¼Œä½† em ä½ã€ek=0.17ï¼ˆMILDï¼‰**
  â†’ Route=LG â†’ em/ek æ˜¯å¦åŒä½ï¼Ÿä¸åŒä½ â†’ QUIET â†’ LIMITï¼ˆä½†ä½ ä¹Ÿå¯ä»¥è®© MILD é»˜è®¤ WAITï¼‰
* **TSLAï¼šSPIKE + DIAG + QUIET + short_dte=6**
  â†’ ä¼šè¢«â€œSPIKE-DIAG é™çº§è¡¥ä¸â€æ‰“å› WAITï¼ˆé¿å…æŒ‚å•è¢«åŠ¨åƒé£é™©ï¼‰âœ…

---


# ğŸ§  Trade Guardian: Decision Engine Logic

Trade Guardian é‡‡ç”¨ **"Shape-First" (å½¢æ€ä¼˜å…ˆ)** çš„å†³ç­–é€»è¾‘ï¼Œå°†æœŸæƒæœŸé™ç»“æ„æ•°æ®è½¬åŒ–ä¸ºå…·ä½“çš„æˆ˜æœ¯æŒ‡ä»¤ã€‚ç³»ç»Ÿä¸å†å•çº¯ä¾èµ–ç»å¯¹æ³¢åŠ¨ç‡æ•°å€¼ï¼Œè€Œæ˜¯ä¾èµ–**ç›¸å¯¹ç»“æ„ä¼˜åŠ¿**ã€‚

### æ ¸å¿ƒæµç¨‹
`Raw Data` $\to$ `Stabilized Edges` $\to$ `Shape Classifier` $\to$ `Strategy Route` $\to$ `Safety Gate` $\to$ `Action`

---

## 1. æ ¸å¿ƒè¾“å…¥ (Key Inputs)

ä¸ºäº†æ¶ˆé™¤çŸ­ç«¯å™ªéŸ³å¹¶è¿˜åŸçœŸå®åœ°å½¢ï¼Œç³»ç»Ÿåœ¨åŸå§‹æ•°æ®ä¹‹ä¸Šè¿›è¡Œäº†æ•°å­¦ç¨³å®šåŒ–å¤„ç†ï¼š

* **Edge Micro (`em`)**: å‰ç«¯ç»“æ„ä¼˜åŠ¿ã€‚
    * *Stabilizer V3*: é‡‡ç”¨ `1-10 DTE Median Base` æ¶ˆé™¤å•ç‚¹å™ªéŸ³ï¼Œå¹¶å¯¹ `< 6 DTE` è¿›è¡Œè¿ç»­å¹³æ»‘è¡°å‡ã€‚
* **Edge Month (`ek`)**: åç«¯ç»“æ„ä¼˜åŠ¿ã€‚
    * *Anchor*: åŠ¨æ€é”šå®š `30-45 DTE` æˆ˜æœ¯åŒºã€‚
* **Regime**: å¸‚åœºçŠ¶æ€ (`BACKWARDATION` / `CONTANGO` / `FLAT`).
* **Momentum**: 15åˆ†é’Ÿçº§åˆ« IV åŠ¨èƒ½ (`PULSE` / `TREND` / `QUIET` / `CRUSH`).

---

## 2. å½¢æ€åˆ†ç±»çŸ©é˜µ (Shape Matrix)

ç³»ç»ŸæŒ‰ **ä¼˜å…ˆçº§ (Priority)** ä¾æ¬¡è¯†åˆ«ä»¥ä¸‹æœŸé™ç»“æ„å½¢æ€ï¼Œå‘½ä¸­å³åœæ­¢ï¼š

| ä¼˜å…ˆçº§ | å½¢æ€ (Shape) | åˆ¤å®šè§„åˆ™ (ä¼ªä»£ç ) | äº¤æ˜“å«ä¹‰ |
| :---: | :--- | :--- | :--- |
| **1** | **BACKWARD** | `Regime == BACKWARDATION` | **å€’æŒ‚**ã€‚å–æ–¹ç¦åŒºï¼Œé˜²å¾¡æ¨¡å¼ã€‚ |
| **2** | **FFBS** | `ek >= 0.20` & `em < 0.08` | **å‰å¹³åé™¡** (Front-Flat Back-Steep)ã€‚é»„é‡‘å¯¹è§’çº¿å½¢æ€ã€‚ |
| **3** | **SPIKE** | `Squeeze` æˆ– `em >= 0.12` | **å‰ç«¯åˆºå¤´**ã€‚çŸ­æœŸ IV æš´æ¶¨ï¼ŒGamma é£é™©é«˜ã€‚ |
| **4** | **STEEP** | `ek >= 0.20` | **é™¡å³­**ã€‚æ ‡å‡†çš„æœŸé™ç»“æ„å¥—åˆ©æœºä¼šã€‚ |
| **5** | **MILD** | `0.15 <= ek < 0.20` | **æ¸©å’Œ**ã€‚ç»“æ„ä¸€èˆ¬ï¼Œå¤„äºä¸´ç•Œç‚¹ã€‚ |
| **6** | **FLAT** | `ek < 0.15` | **å¹³å¦**ã€‚æ— ç»“æ„ä¼˜åŠ¿ï¼Œçº¯æ³¢åŠ¨ç‡åšå¼ˆã€‚ |

---

## 3. ç­–ç•¥è·¯ç”± (Strategy Route)

åŸºäº **Brain V5 (ç»“æ„ä¼˜å…ˆï¼Œä½æ³¢å…œåº•)** å“²å­¦ï¼š

### ğŸŸ¢ AUTO-DIAG (Diagonal Strategy)
**è§¦å‘é€»è¾‘**ï¼šå½“ç»“æ„ä¼˜åŠ¿æ˜æ˜¾æ—¶è§¦å‘ã€‚
* **é€‚ç”¨å½¢æ€**ï¼š`FFBS`, `STEEP`, æˆ– `edge_month >= 0.20`ã€‚
* **æ ¸å¿ƒæ€æƒ³**ï¼šåªè¦å¡åº¦å¤Ÿé™¡ï¼Œå³ä½¿ç»å¯¹ IV è¾ƒä½ï¼Œä¹Ÿä¼˜å…ˆåˆ©ç”¨æ—¶é—´ä»·å€¼è¡°å‡å·®å¼‚ï¼ˆTheta/Vega Arbï¼‰è·åˆ©ã€‚

### ğŸ”µ AUTO-LG (Long Gamma / Straddle)
**è§¦å‘é€»è¾‘**ï¼šå½“ç»“æ„å¹³åº¸æˆ–æ³¢åŠ¨ç‡æä½æ—¶è§¦å‘ã€‚
* **é€‚ç”¨å½¢æ€**ï¼š`MILD`, `FLAT`, `BACKWARD`, `SPIKE` (é€šå¸¸), æˆ– `HV Rank < 30`ã€‚
* **æ ¸å¿ƒæ€æƒ³**ï¼šæ²¡æœ‰ç»“æ„ä¼˜åŠ¿æ—¶ï¼Œä¹°å…¥è·¨å¼æœŸæƒï¼ˆStraddleï¼‰åšå–æ³¢åŠ¨ç‡å›å½’æˆ–æ–¹å‘æ€§çªç ´ã€‚

---

## 4. å®‰å…¨é—¨é˜€ (Safety Gate V6)

Gate æ˜¯ç³»ç»Ÿçš„æœ€åä¸€é“é˜²çº¿ï¼Œå†³å®šæœ€ç»ˆçŠ¶æ€æ˜¯ `EXEC` (æ‰§è¡Œ)ã€`LIMIT` (æŒ‚å•) è¿˜æ˜¯ `WAIT` (è§‚æœ›)ã€‚

### ğŸ›‘ Hard Kill (ä¸€ç¥¨å¦å†³)
* **Blueprint Error**: å»ºä»“å¤±è´¥æˆ–æ•°æ®ç¼ºå¤± $\to$ `FORBID`
* **Gamma Risk**: `est_gamma >= 0.30` $\to$ `FORBID`
* **Vol Collapse**: `Momentum == CRUSH` $\to$ `FORBID`

### ğŸš§ Structural Gate (ç»“æ„æ”¾è¡Œ)

1.  **DIAG è±å…æƒ (The FFBS Privilege)**:
    * è‹¥å½¢æ€ä¸º **`FFBS`** æˆ– **`STEEP`**ï¼Œ**è±å…**å¯¹ Micro Edge (`em`) çš„æœ€ä½è¦æ±‚ã€‚
    * *ç†ç”±ï¼šæ­¤æ—¶å‰ç«¯è¶Šå¹³è¶Šå¥½ï¼Œä¸éœ€è¦å‰ç«¯æœ‰ Edgeã€‚*

2.  **SPIKE é™çº§ä¿æŠ¤ (Rule #4)**:
    * è‹¥å½¢æ€ä¸º **`SPIKE`** ä¸” `Short DTE <= 7` ä¸”åŠ¨èƒ½ä¸è¶³ (`QUIET`) $\to$ å¼ºåˆ¶ **`WAIT`**ã€‚
    * *ç†ç”±ï¼šå‰ç«¯æŒ¤å‹æ—¶æŒ‚ Limit å•å®¹æ˜“è¢«åŠ¨æˆäº¤å¹¶ç«‹åˆ»é­å— Gamma åå™¬ã€‚*

3.  **LG æ ‡å‡†**:
    * è‹¥ `em` å’Œ `ek` åŒä½ (`< Threshold`) $\to$ **`WAIT`**ã€‚

### ğŸš€ Momentum Gate (æ‰§è¡Œå±‚)

* **`PULSE` / `TREND`**: åŠ¨èƒ½ç¡®ç«‹ $\to$ **`EXEC`** (å»ºè®® Market æˆ– Mid+)
* **`QUIET`**: åŠ¨èƒ½æ²‰å¯‚ $\to$ **`LIMIT`** (å»ºè®® Mid-)

---

## 5. æœ¯è¯­å¯¹ç…§è¡¨

* **S_IV**: Short Leg IV (Base Denominator)
* **EdgM**: Micro Edge (Stabilized Front-end Slope)
* **EdgK**: Month Edge (Stabilized Back-end Slope)
* **Scr**: Score (ç»¼åˆè¯„åˆ†)

================================================================================
FILE_PATH: config\config.json
================================================================================
{
  "paths": {
    "tickers_csv": "data/tickers.csv",
    "cache_dir": "cache"
  },
  "scan": {
    "throttle_sec": 0.5,
    "contract_type": "ALL"
  },
  "rules": {
    "min_edge_short_base": 1.05
  },
  "policy": {
    "base_rank": 1,
    "min_dte": 3,
    "probe_count": 3
  },
  "strategies": {
    "hv_calendar": {
      "hv_rules": {
        "hv_low_rank": 20.0,
        "hv_mid_rank": 50.0,
        "hv_high_rank": 70.0,
        "hv_low_bonus": 10,
        "hv_mid_bonus": 4,
        "hv_high_penalty": -4,
        "hv_extreme_penalty": -10
      }
    }
  }
}

================================================================================
FILE_PATH: src\trade_guardian.py
================================================================================
import time
import sys
import os
from datetime import datetime

# ç¡®ä¿ src ç›®å½•åœ¨è·¯å¾„ä¸­ï¼Œä»¥ä¾¿æ­£ç¡®å¯¼å…¥
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from trade_guardian.app.cli import main

def run_guardian_loop():
    """
    å®ˆæŠ¤è€…æ¨¡å¼ï¼šæ¯ 15 åˆ†é’Ÿè‡ªåŠ¨æ‰§è¡Œä¸€æ¬¡å…¨é‡æ‰«æå¹¶å­˜åº“
    """
    INTERVAL = 15 * 60  # 15 åˆ†é’Ÿ (900ç§’)
    
    print("="*80)
    print(f"ğŸ›¡ï¸  TRADE GUARDIAN - DAEMON MODE ACTIVE")
    print(f"â° Polling Interval: {INTERVAL/60} minutes")
    print(f"ğŸ“‚ Project Root: {project_root}")
    print("="*80)
    
    try:
        while True:
            start_ts = time.time()
            now_str = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            # æ¨¡æ‹Ÿå‘½ä»¤è¡Œå‚æ•°ç»™ cli.main()
            # è¿™é‡Œä½ å¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´é»˜è®¤å‚æ•°
            sys.argv = [
                "trade_guardian.py", 
                "scanlist", 
                "--strategy", "auto", 
                "--days", "600", 
                "--detail",
                "--top", "10" # è‡ªåŠ¨æ¨¡å¼ä¸‹åªæ˜¾ç¤ºæœ€æœ‰ä»·å€¼çš„10ä¸ªè®¡åˆ’
            ]
            
            print(f"\nğŸ”„ [LOOP START] {now_str}")
            
            try:
                # æ‰§è¡ŒåŸæœ‰çš„ cli ä¸»å‡½æ•°
                main()
            except Exception as e:
                print(f"âŒ Session Execution Error: {e}")

            elapsed = time.time() - start_ts
            wait_time = max(0, INTERVAL - elapsed)
            
            next_run = datetime.fromtimestamp(time.time() + wait_time).strftime('%H:%M:%S')
            
            print(f"\nâœ… SESSION COMPLETE. Duration: {elapsed:.2f}s")
            print(f"â³ Sleeping {wait_time/60:.1f} min. Next run at: {next_run} (Ctrl+C to stop)")
            
            time.sleep(wait_time)
            
    except KeyboardInterrupt:
        print("\nğŸ›‘ Guardian daemon stopped by user. exiting...")
        sys.exit(0)

if __name__ == "__main__":
    # é€»è¾‘åˆ¤å®šï¼š
    # 1. å¦‚æœä½ è¾“å…¥ python src/trade_guardian.py scanlist ... (å¸¦å‚æ•°) -> è¿è¡Œä¸€æ¬¡å°±ç»“æŸ
    # 2. å¦‚æœä½ ç›´æ¥è¾“å…¥ python src/trade_guardian.py (ä¸å¸¦å‚æ•°) -> è¿›å…¥15åˆ†é’Ÿè½®è¯¢æ¨¡å¼
    if len(sys.argv) > 1:
        main()
    else:
        run_guardian_loop()

================================================================================
FILE_PATH: src\trade_guardian\__init__.py
================================================================================
__all__ = ["app", "domain", "infra", "strategies"]
__version__ = "0.1.0"


================================================================================
FILE_PATH: src\trade_guardian\app\cli.py
================================================================================
import argparse
import os
import time

from trade_guardian.infra.config import (
    DEFAULT_CONFIG,
    load_config,
    write_config_template,
    merge_config_paths,
    policy_from_cfg_and_cli,
)
from trade_guardian.infra.schwab_client import SchwabClient
from trade_guardian.domain.registry import StrategyRegistry
from trade_guardian.app.orchestrator import TradeGuardian


def main():
    parser = argparse.ArgumentParser("Trade Guardian")
    sub = parser.add_subparsers(dest="cmd", required=True)

    # ---------- initconfig ----------
    p_init = sub.add_parser("initconfig", help="Generate config/config.json template")
    p_init.add_argument("--path", type=str, default=None, help="Output path (default: ./config/config.json)")
    p_init.add_argument("--force", action="store_true", help="Overwrite if exists")

    # ---------- scanlist ----------
    p_scan = sub.add_parser("scanlist", help="Scan tickers.csv and output candidates")
    p_scan.add_argument("--config", type=str, default=None, help="Config path (default: ./config/config.json)")
    p_scan.add_argument("--autogen-config", action="store_true", help="Auto-generate config if missing")
    p_scan.add_argument("--no-autogen-config", action="store_true", help="Disable auto-generate config")

    p_scan.add_argument("--strategy", type=str, default="auto", help="Strategy name (default: auto)")
    p_scan.add_argument("--days", type=int, default=600)
    p_scan.add_argument("--csv", type=str, default=None, help="Tickers csv path")
    p_scan.add_argument("--min-score", type=int, default=60)
    p_scan.add_argument("--max-risk", type=int, default=70)
    p_scan.add_argument("--limit", type=int, default=0)
    p_scan.add_argument("--detail", action="store_true", help="Print blueprints and detailed logic")
    p_scan.add_argument("--top", type=int, default=None, help="Only show top N sorted blueprints")

    # Policy overrides
    p_scan.add_argument("--short-rank", type=int, default=None)
    p_scan.add_argument("--min-short-dte", type=int, default=None)
    p_scan.add_argument("--max-probe-rank", type=int, default=None)

    args = parser.parse_args()

    # å®šä½é¡¹ç›®æ ¹ç›®å½• (cli.py -> app -> trade_guardian -> src -> project_root)
    root = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "..", ".."))

    if args.cmd == "initconfig":
        out = args.path or os.path.join(root, "config", "config.json")
        os.makedirs(os.path.dirname(out), exist_ok=True)
        write_config_template(out, DEFAULT_CONFIG, overwrite=args.force)
        print(f"âœ… Wrote config template: {out}")
        return

    if args.cmd == "scanlist":
        # è®°å½•å¼€å§‹æ—¶é—´ï¼Œç”¨äºæ•°æ®åº“å­˜ç›˜
        start_ts = time.time()

        cfg_path = args.config or os.path.join(root, "config", "config.json")

        # æ£€æŸ¥æ˜¯å¦éœ€è¦è‡ªåŠ¨ç”Ÿæˆé…ç½®
        autogen_default = bool(DEFAULT_CONFIG.get("runtime", {}).get("autogen_config_if_missing", True))
        autogen = autogen_default
        if args.autogen_config: autogen = True
        if args.no_autogen_config: autogen = False

        if autogen and not os.path.exists(cfg_path):
            os.makedirs(os.path.dirname(cfg_path), exist_ok=True)
            write_config_template(cfg_path, DEFAULT_CONFIG, overwrite=False)

        # åŠ è½½ä¸åˆå¹¶è·¯å¾„
        cfg = load_config(cfg_path, DEFAULT_CONFIG)
        cfg = merge_config_paths(cfg, root, args.csv)

        # æ„å»ºç­–ç•¥å’Œå®¢æˆ·ç«¯
        policy = policy_from_cfg_and_cli(cfg, args)
        client = SchwabClient(cfg)
        registry = StrategyRegistry(cfg, policy)
        strategy = registry.get(args.strategy)

        # åˆå§‹åŒ–ä¸»æ§ç¨‹åº
        tg = TradeGuardian(client=client, cfg=cfg, policy=policy, strategy=strategy)
        
        # æ‰§è¡Œæ‰«æ
        # è¿™é‡Œè®¡ç®— elapsed (ç»è¿‡çš„æ—¶é—´)ï¼Œç¡®ä¿æ•°æ®åº“èƒ½è®°å½•è¿™æ¬¡ä»»åŠ¡è·‘äº†å¤šä¹…
        tg.scanlist(
            strategy_name=args.strategy,
            days=args.days,
            min_score=args.min_score,
            max_risk=args.max_risk,
            limit=args.limit,
            detail=args.detail,
            top=args.top,
            elapsed=0.0  # åˆå§‹è®¾ä¸º0ï¼ŒOrchestrator å†…éƒ¨ä¼šè®¡ç®—çœŸå®å€¼æˆ–ç”±è¿™é‡Œä¼ é€’
        )
        return


if __name__ == "__main__":
    main()

================================================================================
FILE_PATH: src\trade_guardian\app\orchestrator.py
================================================================================
from __future__ import annotations
import os
import sys
import time
import pandas as pd
import traceback
from typing import List, Tuple, Optional, Any
from colorama import Fore, Style

from trade_guardian.domain.models import Context, ScanRow, Blueprint, OrderLeg
from trade_guardian.app.persistence import PersistenceManager
from trade_guardian.strategies.blueprint import build_straddle_blueprint 
# [FIX] å¼•å…¥é™æµå™¨
from trade_guardian.infra.rate_limit import RateLimiter

# --- [äº¤æ˜“å‘˜åº•çº¿å‚æ•°] ---
MICRO_MIN = 0.10
MONTH_MIN = 0.15

class TradeGuardian:
    def __init__(self, client, cfg: dict, policy, strategy=None):
        self.client = client
        self.cfg = cfg
        self.policy = policy
        self.strategy = strategy 
        
        # [FIX] P0-2: ä» Config è¯»å–è·¯å¾„ï¼Œä¸å†ç¡¬ç¼–ç 
        self.tickers_path = cfg.get("paths", {}).get("tickers_csv", "data/tickers.csv")
        
        # [FIX] Part 2, Item 5: åˆå§‹åŒ–é™æµå™¨
        throttle = float(cfg.get("scan", {}).get("throttle_sec", 0.5))
        self.limiter = RateLimiter(throttle)
        
        self.db = PersistenceManager()
        self.last_batch_df: Optional[pd.DataFrame] = None 

    def _get_universe(self) -> List[str]:
        if not os.path.exists(self.tickers_path):
            # å°è¯• fallback åˆ°ç›¸å¯¹è·¯å¾„
            fallback = os.path.join("data", "tickers.csv")
            if os.path.exists(fallback):
                self.tickers_path = fallback
            else:
                print(f"\nâŒ [CRITICAL ERROR] Tickers file NOT FOUND at {self.tickers_path}")
                sys.exit(1)
                
        df = pd.read_csv(self.tickers_path, header=None)
        # ç®€å•çš„æ¸…æ´—
        return df[0].dropna().apply(lambda x: str(x).strip().upper()).tolist()

    def scanlist(self, strategy_name: str = "auto", days: int = 600, 
                 min_score: int = 60, max_risk: int = 70, detail: bool = False,
                 limit: int = None, **kwargs):
        
        # [FIX] Issue B: å¼€å§‹è®¡æ—¶
        start_ts = time.time()

        try:
            vix_q = self.client.get_quote("$VIX")
            current_vix = vix_q.get("lastPrice", 0.0) 
        except: current_vix = 0.0
        
        tickers = self._get_universe()
        if limit: tickers = tickers[:limit]

        db_results_pack = []  
        strict_results = [] 
        current_rows_for_next_batch = [] 
        
        # DNA -> Shape (Display Structure Shape)
        FMT = "{sym:<5} {px:<7} {sexp:<11} {sdte:<3} {siv:>6} | {mexp:<11} {mdte:<3} {miv:>6} {em:>5} | {kexp:<11} {kdte:<3} {kiv:>6} {ek:>5} | {sc:>4} {shp:<8} {gate:<6}   {tag:<8}"
        
        HEADER = FMT.format(
            sym="Sym", px="Px", sexp="ShortExp", sdte="D", siv="S_IV",
            mexp="MicroExp", mdte="D", miv="M_IV", em="EdgM",
            kexp="MonthExp", kdte="D", kiv="K_IV", ek="EdgK",
            sc="Scr", shp="Shape", gate="Gate", tag="Tag"
        )
        WIDTH = len(HEADER)

        print("\n" + "=" * WIDTH)
        print(f"ğŸ§  TRADE GUARDIAN :: GRADUATION BUILD | VIX: {current_vix:.2f} | Strategy: {strategy_name}")
        print("-" * WIDTH)
        print(HEADER)
        print("-" * WIDTH)

        for ticker in tickers:
            # [FIX] Part 2, Item 5: å¾ªç¯å†…é™æµ
            self.limiter.sleep()

            try:
                # 1. æ„å»ºä¸Šä¸‹æ–‡
                ctx = self.client.build_context(ticker, days=days)
                if not ctx: continue
                
                # 2. ç­–ç•¥è·¯ç”±
                # [FIX] P0-2: ä¼˜å…ˆä½¿ç”¨ä¼ å…¥çš„ strategy å¯¹è±¡ï¼Œå¦åˆ™æ ¹æ®åç§°åŠ è½½
                current_strategy = self.strategy if self.strategy else self._load_strategy(strategy_name)
                row = current_strategy.evaluate(ctx)
                if not row: continue

                # 3. åŠ¨èƒ½è®¡ç®— (Momentum)
                iv_diff = 0.0
                if self.last_batch_df is not None:
                    prev = self.last_batch_df[self.last_batch_df['symbol'] == row.symbol]
                    if not prev.empty:
                        # è¿™é‡Œçš„æ¯”è¾ƒéå¸¸åŸºç¡€ï¼Œåç»­å¯ä»¥æ”¹ä¸º % change
                        iv_diff = row.short_iv - prev.iloc[0]['iv']
                
                mom_type = "QUIET"
                if iv_diff > 2.0: mom_type = "PULSE"
                elif iv_diff > 0.5: mom_type = "TREND"
                elif iv_diff < -1.0: mom_type = "CRUSH"
                
                row.meta["delta_15m"] = iv_diff
                row.meta["momentum"] = mom_type

                # 4. å½¢æ€åˆ†ç±» (Shape Classifier) - [FIX] P0-3: ä¸¥æ ¼å¯¹é½è·¯ç”±çŸ©é˜µ
                tsf = ctx.tsf or {}
                regime = str(tsf.get("regime", "FLAT"))
                is_squeeze = bool(tsf.get("is_squeeze", False))
                # curvature = str(tsf.get("curvature", "NORMAL")) # çŸ©é˜µè¯´ä¸è¦å•çœ‹è¿™ä¸ª
                
                em = float(row.meta.get("edge_micro", 0) or 0)
                ek = float(row.meta.get("edge_month", 0) or 0)
                
                shape = "FLAT"
                if regime == "BACKWARDATION":
                    shape = "BACKWARD"
                elif ek >= 0.20 and em < 0.08:
                    shape = "FFBS" # é»„é‡‘å¯¹è§’çº¿
                elif is_squeeze or em >= 0.12: # [FIX] çŸ©é˜µè§„åˆ™ï¼šSPIKE å¿…é¡»é  em æˆ– squeeze
                    shape = "SPIKE"
                elif ek >= 0.20: # [FIX] çŸ©é˜µè§„åˆ™ï¼šSTEEP >= 0.20
                    shape = "STEEP"
                elif 0.15 <= ek < 0.20: # [FIX] çŸ©é˜µè§„åˆ™ï¼šMILD åŒºé—´
                    shape = "MILD"
                else:
                    shape = "FLAT"
                
                row.meta["shape"] = shape
                
                # 5. è·å–è“å›¾
                bp = getattr(row, 'blueprint', None)
                if not bp:
                    bp = self.plan(ctx, row) 
                
                # 6. é£æ§é—¨æ§› (Gate V6)
                gate = self._get_gate_status(row, bp, mom_type) 
                
                db_results_pack.append((row, ctx, bp, gate)) 
                current_rows_for_next_batch.append({'symbol': row.symbol, 'iv': row.short_iv})
                
                if gate != "FORBID":
                    strict_results.append((row, ctx, bp, gate, mom_type))

                # 7. æ‰“å°
                if gate == "EXEC": g_color = Fore.GREEN
                elif gate == "LIMIT": g_color = Fore.CYAN
                elif gate == "FORBID": g_color = Fore.RED
                else: g_color = Fore.YELLOW
                
                gate_display = f"{g_color}{gate:<6}{Style.RESET_ALL}"
                
                # Tag å¯èƒ½ä¸ºç©ºçš„å¤„ç†
                tag_str = str(row.tag) if row.tag else ""

                print(FMT.format(
                    sym=row.symbol,
                    px=f"{row.price:.1f}",
                    sexp=row.short_exp,
                    sdte=row.short_dte,
                    siv=f"{int(row.short_iv)}%",
                    mexp=str(row.meta.get("micro_exp", "N/A")),
                    mdte=str(row.meta.get("micro_dte", 0)),
                    miv=f"{int(row.meta.get('micro_iv', 0))}%",
                    em=f"{em:.2f}",
                    kexp=str(row.meta.get("month_exp", "N/A")),
                    kdte=str(row.meta.get("month_dte", 0)),
                    kiv=f"{int(row.meta.get('month_iv', 0))}%",
                    ek=f"{ek:.2f}",
                    sc=row.cal_score,
                    shp=shape, 
                    gate=gate_display, 
                    tag=tag_str
                ))

            except Exception as e:
                print(f"âŒ CRASH on {ticker}: {e}")
                # traceback.print_exc() 
                continue

        # [FIX] (A) æ ¸å¿ƒä¿®å¤ï¼šæ›´æ–° last_batch_dfï¼Œå¦åˆ™åŠ¨èƒ½(Momentum)æ°¸è¿œç®—ä¸å‡ºæ¥
        if current_rows_for_next_batch:
            self.last_batch_df = pd.DataFrame(current_rows_for_next_batch)
        
        # è®¡ç®—ç»Ÿè®¡æŒ‡æ ‡ (ä¿æŒä½ ä¹‹å‰çš„ç»Ÿè®¡é€»è¾‘)
        elapsed = time.time() - start_ts
        valid_rows = [item[0] for item in db_results_pack]
        avg_abs_edge = 0.0
        cheap_vol_pct = 0.0
        
        if valid_rows:
            total_abs_edge = sum(abs(r.edge) for r in valid_rows)
            avg_abs_edge = total_abs_edge / len(valid_rows)
            cheap_count = sum(1 for r in valid_rows if r.edge > 0)
            cheap_vol_pct = cheap_count / len(valid_rows)

        # ä¿å­˜ä¼šè¯
        self.db.save_scan_session(
            strategy_name, 
            current_vix, 
            len(tickers), 
            avg_abs_edge, 
            cheap_vol_pct, 
            elapsed, 
            db_results_pack
        )
        
        if detail and strict_results:
            print(f"\nğŸš€ Actionable Blueprints (Tactical Mode)")
            print("-" * WIDTH)
            for row, ctx, bp, gate, dna in strict_results:
                self._print_enhanced_blueprint(bp, row, dna, gate)
        print("-" * WIDTH)

    def _get_gate_status(self, row: ScanRow, bp: Optional[Blueprint], dna_type: str) -> str:
        est_gamma = row.meta.get("est_gamma", 0.0)
        
        # --- Layer 1: Hard Kill (ç»å¯¹é£æ§) ---
        if not bp or bp.error: return "FORBID"
        if est_gamma >= 0.30: return "FORBID" 
        if dna_type == "CRUSH": return "FORBID" 
        
        em = row.meta.get("edge_micro", 0)
        ek = row.meta.get("edge_month", 0)
        shape = row.meta.get("shape", "FLAT")
        tag = row.tag or ""
        short_dte = row.short_dte
        
        # --- Layer 2: Strategy & Shape Gate (ç»“æ„é—¨æ§›) ---
        
        if "DIAG" in tag:
            # [DIAG æ ¸å¿ƒ] çœ‹åç«¯ç»“æ„ (ek)
            if ek < MONTH_MIN:
                return "WAIT"
            
            # [å½¢æ€ç‰¹åˆ¤]
            # A. FFBS / STEEP: å®Œç¾å½¢æ€ï¼Œè±å…å‰ç«¯å¾®ç»“æ„è¦æ±‚ (em)
            if shape in ["FFBS", "STEEP"]:
                pass 
            
            # B. SPIKE: å‰ç«¯æŒ¤å‹ï¼Œé£é™©æé«˜ -> é™çº§ä¿æŠ¤ (Rule #4)
            elif shape == "SPIKE":
                if short_dte <= 7 and dna_type == "QUIET":
                    return "WAIT"
                # å¦‚æœæ˜¯ SPIKE ä½† em æå·® (ç†è®ºä¸Š SPIKE em åº”è¯¥é«˜ï¼Œè¿™é‡Œæ˜¯å…œåº•)
                if em < MICRO_MIN:
                    return "WAIT"

            # C. å…¶ä»–å½¢æ€ (FLAT/MILD): å¿…é¡»åŒè¾¹è¾¾æ ‡
            else:
                if em < MICRO_MIN:
                    return "WAIT"

        else:
            # [LG æ ¸å¿ƒ] å‰ç«¯ä¸èƒ½å¤ªçƒ‚ï¼Œæˆ–è€…çº¯åšä½æ³¢
            # å¦‚æœ em å’Œ ek åŒä½ï¼Œä¸”æ²¡æœ‰ç‰¹æ®ŠåŸå› ï¼ŒWAIT
            if em < MICRO_MIN and ek < MONTH_MIN:
                return "WAIT"

        # --- Layer 3: Momentum Gate (åŠ¨èƒ½æ‰§è¡Œ) ---
        if dna_type in ["PULSE", "TREND"]:
            return "EXEC"
        else:
            return "LIMIT"
        

    def plan(self, ctx: Context, row: ScanRow) -> Optional[Blueprint]:
        bp = build_straddle_blueprint(
            symbol=ctx.symbol,
            underlying=ctx.price,
            chain=ctx.raw_chain,
            exp=row.short_exp
        )
        if bp:
            bp.note = "Fallback Gamma Plan"
            return bp
        return Blueprint(ctx.symbol, "STRADDLE", [], 0.0, "Build Failed", error="No Pricing Data")

    def _print_enhanced_blueprint(self, bp: Blueprint, row: ScanRow, dna: str, gate: str):
        tactic = ""
        if gate == "LIMIT":
            tactic = f"{Fore.CYAN}[æŒ‚å•æ½œä¼] Limit @ Mid-$0.05 | ç­‰å¾… DNA æ¿€æ´»{Style.RESET_ALL}"
        elif gate == "EXEC":
            tactic = f"{Fore.GREEN}[ç«‹å³æ‰§è¡Œ] Market/Mid+$0.02 | åŠ¨èƒ½ç¡®ç«‹{Style.RESET_ALL}"
        elif gate == "WAIT":
             tactic = f"{Fore.YELLOW}[ä¿æŒå…³æ³¨] å°šæœªè¾¾åˆ°å…¥åœºæ ‡å‡†{Style.RESET_ALL}"

        print(f" {Fore.WHITE}{bp.symbol:<5} | Gate: {gate:<5} | Debit: ${bp.est_debit} | Gamma: {row.meta.get('est_gamma', 0):.4f}")
        print(f"    Edges: Micro {row.meta.get('edge_micro', 0):.2f} / Month {row.meta.get('edge_month', 0):.2f}")
        
        shape = row.meta.get("shape", "")
        mom = row.meta.get("momentum", "QUIET")
        print(f"    Shape: {shape:<8} | Momentum: {mom}")
        
        if "DIAG" in (row.tag or "") and shape == "FFBS":
            print(f"    âœ… {Fore.GREEN}FFBS (Front-Flat Back-Steep): å®Œç¾å¯¹è§’çº¿å½¢æ€ï¼Œå‰ç«¯å®‰ç¨³ï¼Œåç«¯é«˜æº¢ä»·ã€‚{Style.RESET_ALL}")
        
        print(f"    ğŸ‘‰ {tactic}")
        
        if bp.legs:
            for leg in bp.legs:
                action_sym = '+' if leg.action == 'BUY' else '-'
                print(f"       {action_sym}{leg.ratio} {leg.exp} {leg.strike:<6} {leg.type}")
        else:
            print(f"       [ERROR] No Legs: {bp.error}")
        print(f"    {'='*80}")

    def _load_strategy(self, name: str):
        # [FIX] å¦‚æœéœ€è¦åŠ¨æ€åŠ è½½ï¼Œè¿™é‡Œä½¿ç”¨ Registry ä¼šæ›´å¥½ï¼Œä½†æš‚æ—¶ä¿æŒåŸæ ·ä»¥æœ€å°åŒ–æ”¹åŠ¨
        from trade_guardian.strategies.auto import AutoStrategy
        return AutoStrategy(self.cfg, self.policy)

================================================================================
FILE_PATH: src\trade_guardian\app\persistence.py
================================================================================
import sqlite3
import os
from datetime import datetime

class PersistenceManager:
    def __init__(self, db_path=None):
        # [FIX] (C) è·¯å¾„é”šå®šï¼šæ— è®ºåœ¨å“ªé‡Œè¿è¡Œï¼Œéƒ½å®šä½åˆ°é¡¹ç›®æ ¹ç›®å½•ä¸‹çš„ db æ–‡ä»¶å¤¹
        if db_path:
            self.db_path = db_path
        else:
            # å½“å‰æ–‡ä»¶åœ¨ src/trade_guardian/app/
            base_dir = os.path.dirname(os.path.abspath(__file__))
            # å›é€€ 3 å±‚åˆ°é¡¹ç›®æ ¹ç›®å½• (src/trade_guardian/app -> src/trade_guardian -> src -> root)
            project_root = os.path.abspath(os.path.join(base_dir, "..", "..", ".."))
            self.db_path = os.path.join(project_root, "db", "trade_guardian.db")

        # ç¡®ä¿å­˜æ”¾ç›®å½•å­˜åœ¨
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)


    # [FIX] Issue B: æ¥æ”¶ç»Ÿè®¡å‚æ•° (avg_edge, cheap_vol, elapsed)
    def save_scan_session(self, strategy_name, vix, count, avg_edge, cheap_vol, elapsed, results_pack):
        """ä¿å­˜å•æ¬¡æ‰«æçš„æ‰€æœ‰ç»“æœ"""
        conn = sqlite3.connect(self.db_path)
        c = conn.cursor()
        
        try:
            # [FIX] (B) æ—¶é—´æ ¼å¼ä¿®å¤ï¼šSQLite å¯¹ ISO 8601 (å¸¦T) æ”¯æŒä¸å¥½ï¼Œæ”¹ç”¨ç©ºæ ¼åˆ†éš”
            current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            c.execute("""INSERT INTO scan_batches 
                      (timestamp, strategy_name, market_vix, universe_size, avg_abs_edge, cheap_vol_pct, elapsed_time) 
                      VALUES (?, ?, ?, ?, ?, ?, ?)""",
                      (current_time, strategy_name, vix, count, avg_edge, cheap_vol, elapsed))
            batch_id = c.lastrowid
            
            for item in results_pack:
                row, ctx, bp, gate = item
                
                # [FIX] (D) è¡¥å…¨å­—æ®µï¼šå†™å…¥ hv_rank å’Œ regimeï¼Œé˜²æ­¢æ•°æ®ä¸¢å¤±
                # æ³¨æ„ï¼šè¿™é‡Œéœ€è¦ create_tg_db.py é‡Œ market_snapshots è¡¨ç»“æ„é…åˆ (ä½ ä¹‹å‰çš„ schema å·²ç»æœ‰äº†)
                c.execute("""INSERT INTO market_snapshots 
                          (batch_id, symbol, price, iv_short, iv_base, edge, hv_rank, regime) 
                          VALUES (?, ?, ?, ?, ?, ?, ?, ?)""",
                          (batch_id, row.symbol, row.price, row.short_iv, row.base_iv, row.edge, row.hv_rank, row.regime))
                snap_id = c.lastrowid
                
                tag_val = row.tag 
                est_gamma = row.meta.get("est_gamma", 0.0)
                est_debit = bp.est_debit if bp else 0.0
                strat_name = bp.strategy if bp else "NONE"
                
                c.execute("""INSERT INTO trade_plans 
                          (snapshot_id, strategy_type, cal_score, short_risk, gate_status, est_debit, total_gamma, tag) 
                          VALUES (?, ?, ?, ?, ?, ?, ?, ?)""",
                          (snap_id, strat_name, row.cal_score, row.short_risk, gate, est_debit, est_gamma, tag_val))
                
            conn.commit()
            print(f"ğŸ’¾ [DB] Saved Batch {batch_id}: {count} items | AvgEdge: {avg_edge:.2f} | Time: {elapsed:.1f}s")
            
        except Exception as e:
            import traceback
            traceback.print_exc()
            print(f"âŒ [DB Error] Save failed: {e}")
        finally:
            conn.close()

================================================================================
FILE_PATH: src\trade_guardian\app\renderer.py
================================================================================
from __future__ import annotations
import os
from typing import List, Optional, Any
from trade_guardian.domain.models import ScanRow

# === 1. å®šä¹‰é¢œè‰²ä»£ç  ===
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    WARNING = '\033[93m' # é»„è‰²
    FAIL = '\033[91m'    # çº¢è‰²
    ENDC = '\033[0m'     # é‡ç½®é¢œè‰²
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

# è®© Windows ç»ˆç«¯æ”¯æŒ ANSI é¢œè‰²
os.system('')

class ScanlistRenderer:
    def __init__(self, cfg=None, policy=None, hv_cache_path: Optional[str] = None):
        self.cfg = cfg
        self.policy = policy
        self.hv_cache_path = hv_cache_path

    def _sanitize_int(self, value: Any, default: int = 0) -> int:
        """é˜²å¾¡æ€§ç¼–ç¨‹ï¼šç¡®ä¿è¿”å›çš„ä¸€å®šæ˜¯ int"""
        try:
            if isinstance(value, int): return value
            if isinstance(value, str) and value.isdigit(): return int(value)
            if isinstance(value, list): return self._sanitize_int(value[0], default) if value else default
            return default
        except:
            return default

    # [ä¸»æ¸²æŸ“å…¥å£]
    def render(self, 
               strict: List[ScanRow], 
               auto_adjusted: List[ScanRow], 
               watch: List[ScanRow], 
               days: int, 
               min_score: int = 0, 
               max_risk: int = 100, 
               detail: bool = False, 
               universe_size: int = 0,
               top: Any = 0, 
               **kwargs): # åæ‰æ‰€æœ‰æœªå®šä¹‰çš„å‚æ•°
        
        # æ¸…ç† top å‚æ•°
        safe_top = self._sanitize_int(top, 0)
        
        # æ‰“å°å¤´éƒ¨ä¿¡æ¯
        print("")
        print("=" * 95)
        print(f"ğŸ§  {Colors.HEADER}TRADE GUARDIAN :: SCANLIST (days={days}){Colors.ENDC}")
        print("=" * 95)
        
        # ç»Ÿè®¡ä¿¡æ¯
        adjusted_list = auto_adjusted if auto_adjusted else []
        total = universe_size if universe_size > 0 else (len(strict) + len(adjusted_list) + len(watch))
        
        print(f"Universe size: {total} | Strict: {len(strict)} | AutoAdjusted: {len(adjusted_list)} | Watch: {len(watch)} | Errors: 0")
        print(f"Strict Filter: score >= {min_score}, short_risk <= {max_risk}")
        if self.hv_cache_path:
            print(f"Throttle: 0.50s/ticker | HV cache: {self.hv_cache_path}")
        
        # æ‰“å°è¡¨æ ¼
        if strict:
            self._print_table(f"âœ… {Colors.GREEN}Strict Candidates (actionable now){Colors.ENDC}", strict)
            if detail:
                self._print_details("Top details (per-row explain)", strict)
                # æ‰“å°è“å›¾ (å»æ‰äº† Strategy #3 çš„æ–‡å­—)
                self._print_blueprints(f"ğŸš€ {Colors.CYAN}Actionable Blueprints{Colors.ENDC}", strict)

        if adjusted_list:
            self._print_table("ğŸ¤– Auto-Adjusted Candidates", adjusted_list)

        if watch:
            self._print_table("ğŸ‘€ Watchlist", watch)

    # [è¯Šæ–­ä¿¡æ¯å…¥å£]
    def render_diagnostics(self, strict: List[ScanRow], **kwargs):
        if not strict: return

        print(f"\nğŸ§¾ Diagnostics")
        avg_score = sum(r.cal_score for r in strict) / len(strict)
        
        # è®¡ç®—å¹³å‡ Edge
        valid_edges = [r.edge for r in strict if r.edge > 0]
        avg_edge = sum(valid_edges) / len(valid_edges) if valid_edges else 0.0
        
        print(f"   â€¢ Avg Score: {avg_score:.1f} | Avg Edge: {avg_edge:.2f}x")

    # [å†…éƒ¨ helper] æ‰“å°è¡¨æ ¼
    def _print_table(self, title: str, rows: List[ScanRow]):
        if not rows: return
        if title: print(f"\n{title}")
        
        header = f"{'Sym':<6} {'Px':<7} {'ShortExp':<10} {'ShortDTE':>8} {'ShortIV':>8} {'BaseIV':>8} {'Edge':>7} {'HV%':>5} {'Score':>7} {'Risk':>6} {'Tag':<11}"
        print(header)
        print("-" * len(header))
        
        for r in rows:
            # IV ä¿®æ­£ï¼šé™¤ä»¥ 100
            short_iv_val = r.short_iv / 100.0
            base_iv_val = r.base_iv / 100.0
            
            row_str = (
                f"{r.symbol:<6} "
                f"{r.price:<7.2f} "
                f"{r.short_exp:<10} "
                f"{r.short_dte:>8} "
                f"{short_iv_val:>8.1%} "
                f"{base_iv_val:>8.1%} "
                f"{r.edge:>6.2f}x "
                f"{r.hv_rank:>4.0f}% "
                f"{r.cal_score:>7} "
                f"{r.short_risk:>6} "
                f"{r.tag:<11}"
            )
            print(row_str)

    # [å†…éƒ¨ helper] æ‰“å°è¯¦æƒ…
    def _print_details(self, title: str, rows: List[ScanRow]):
        print(f"\n{title}")
        print("Explain legend")
        print("  score parts: b=base, rg=regime, ed=edge, hv=HV-rank slot, cv=curvature, pen=penalties")
        print("  risk  parts: b=base, dte=time-to-expiry, gm=gamma proxy, cv=curvature risk, rg=regime risk, pen=penalties")
        
        for r in rows:
            bd = r.score_breakdown
            rbd = r.risk_breakdown
            print(f"\n  {Colors.BOLD}{r.symbol:<6}{Colors.ENDC} score={r.cal_score:<3} [b{bd.base:+} rg{bd.regime:+} ed{bd.edge:+} hv{bd.hv:+} cv{bd.curvature:+} pen{bd.penalties:+}] | edge={r.edge:.2f}x tag={r.tag} hv={r.hv_rank:.0f}%")
            print(f"         risk={r.short_risk:<3} [b{rbd.base:+} dte{rbd.dte:+} gm{rbd.gamma:+} cv{rbd.curvature:+} rg{rbd.regime:+}] | short={r.short_exp} d{r.short_dte}")

    # [å†…éƒ¨ helper] æ‰“å°è“å›¾ (åŒ…å« Greeks)
    def _print_blueprints(self, title: str, rows: List[ScanRow]):
        valid_rows = [r for r in rows if getattr(r, 'blueprint', None)]
        if not valid_rows: return

        print(f"\n{title}")
        print("-" * 95)
        for r in valid_rows:
            bp = r.blueprint
            
            # æ‘˜è¦è¡Œ
            line = bp.one_liner()
            if "est_debit=" in line:
                parts = line.split("est_debit=")
                line = f"{parts[0]}{Colors.CYAN}est_debit={parts[1]}{Colors.ENDC}"
            print(f"  {line}")
            
            # Note è¡Œ
            note = getattr(bp, "note", "")
            if note:
                if "WARNING" in note or "Risk" in note:
                    print(f"    Note: {Colors.FAIL}{note}{Colors.ENDC}")
                elif "Healthy" in note:
                    print(f"    Note: {Colors.GREEN}{note}{Colors.ENDC}")
                else:
                    print(f"    Note: {note}")

            # è…¿éƒ¨è¯¦æƒ… (å¸¦ Greeks)
            if hasattr(bp, "short_exp") and hasattr(bp, "long_exp"):
                # Diagonal / PMCC / Calendar
                if hasattr(bp, "short_strike") and hasattr(bp, "long_strike"):
                     # PMCC
                     s_delta = bp.short_greeks.get("delta", 0) if getattr(bp, "short_greeks", None) else 0
                     l_delta = bp.long_greeks.get("delta", 0) if getattr(bp, "long_greeks", None) else 0
                     print(f"    Legs: +{bp.long_exp} ({bp.long_strike}C) [Î”{l_delta:.2f}]")
                     print(f"          -{bp.short_exp} ({bp.short_strike}C) [Î”{s_delta:.2f}]")
                else:
                     # Calendar
                     print(f"    Legs: -{bp.short_exp} / +{bp.long_exp} @ Strike {bp.strike}")
            
            elif hasattr(bp, "exp"):
                # Straddle
                atm_gamma = bp.greeks.get("gamma", 0) if getattr(bp, "greeks", None) else 0
                atm_delta = bp.greeks.get("delta", 0) if getattr(bp, "greeks", None) else 0
                print(f"    Legs: +{bp.exp} CALL & PUT @ Strike {bp.strike} [Î”{atm_delta:.2f} Î“{atm_gamma:.3f}]")
            
            else:
                print(f"    Legs: (Unknown structure)")

        print("-" * 95)
        print("")

================================================================================
FILE_PATH: src\trade_guardian\app\__init__.py
================================================================================


================================================================================
FILE_PATH: src\trade_guardian\domain\features.py
================================================================================
from __future__ import annotations

from typing import Dict, List

from trade_guardian.domain.models import HVInfo, TermPoint
from trade_guardian.domain.policy import ShortLegPolicy


class TSFeatureBuilder:
    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy

    @staticmethod
    def _eligible_points(term: List[TermPoint], min_dte: int) -> List[TermPoint]:
        return [p for p in term if p.dte >= min_dte]

    @staticmethod
    def _baseline_iv(term: List[TermPoint], fallback_iv: float) -> float:
        mids = [p.iv for p in term if 30 <= p.dte <= 90 and p.iv > 0]
        if mids:
            return float(sum(mids) / len(mids))
        return float(fallback_iv)

    def build(self, term: List[TermPoint], hv: HVInfo, rank: int) -> Dict[str, object]:
        if not term:
            return {"status": "Error", "msg": "Empty term structure"}

        eligible = self._eligible_points(term, self.policy.min_dte)
        if not eligible:
            return {"status": "Error", "msg": f"No eligible expiries (min_dte={self.policy.min_dte})"}

        if rank < 0 or rank >= len(eligible):
            return {"status": "Error", "msg": f"Rank out of range: rank={rank} eligible={len(eligible)}"}

        short = eligible[rank]
        base_iv = self._baseline_iv(term, fallback_iv=short.iv)

        # regime: compare base vs short
        if base_iv > short.iv * 1.03:
            regime = "CONTANGO"
        elif short.iv > base_iv * 1.03:
            regime = "BACKWARDATION"
        else:
            regime = "FLAT"

        # curvature: compare rank0 (nearest eligible) vs short
        front = eligible[0]
        squeeze_ratio = (front.iv / base_iv) if base_iv > 0 else 0.0

        # spiky front when rank0 materially richer than short rank
        curv = "SPIKY_FRONT" if (front.iv > short.iv * 1.20 and front.dte < 14) else "NORMAL"

        edge = (short.iv / base_iv) if base_iv > 0 else 0.0

        return {
            "status": "Success",
            "regime": regime,
            "curvature": curv,
            "short_exp": short.exp,
            "short_dte": short.dte,
            "short_iv": short.iv,
            "base_iv": base_iv,
            "edge": edge,
            "squeeze_ratio": squeeze_ratio,
        }


================================================================================
FILE_PATH: src\trade_guardian\domain\hv.py
================================================================================
from __future__ import annotations

from trade_guardian.domain.models import HVInfo
from trade_guardian.infra.cache import JsonDailyCache
from trade_guardian.infra.schwab_client import SchwabClient


class HVService:
    def __init__(self, client: SchwabClient, cache: JsonDailyCache):
        self.client = client
        self.cache = cache

    def get_hv(self, symbol: str) -> HVInfo:
        cached = self.cache.get(symbol)
        if cached:
            return HVInfo(**cached)

        hv = self.client.calculate_hv_percentile(symbol)
        # store even if partial to avoid repeated API spam
        self.cache.set(symbol, hv.__dict__)
        return hv


================================================================================
FILE_PATH: src\trade_guardian\domain\models.py
================================================================================
from __future__ import annotations
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any

# --- åŸºç¡€è®¾æ–½ç±» (ç”¨äº SchwabClient ç­‰) ---

@dataclass
class HVInfo:
    """Historical Volatility Data Container"""
    current_hv: float = 0.0
    hv_rank: float = 0.0
    hv_percentile: float = 0.0
    high_52w: float = 0.0
    low_52w: float = 0.0
    status: str = "Success"
    msg: str = ""
    hv_low: float = 0.0
    hv_high: float = 0.0
    p50: float = 0.0
    p75: float = 0.0
    p90: float = 0.0

@dataclass
class TermPoint:
    """Term Structure Point (ç”¨äº term structure è®¡ç®—)"""
    exp: str = "" 
    exp_date: str = "" 
    dte: int = 0
    iv: float = 0.0
    strike: float = 0.0
    mark: float = 0.0
    delta: float = 0.0
    theta: float = 0.0
    gamma: float = 0.0

# --- æ ¸å¿ƒåˆ†æç±» ---

@dataclass
class IVData:
    rank: float = 0.0
    percentile: float = 0.0
    current_iv: float = 0.0
    hv_rank: float = 0.0
    current_hv: float = 0.0

@dataclass
class Context:
    symbol: str
    price: float
    iv: IVData
    hv: IVData
    tsf: dict  # Term Structure Factors
    raw_chain: dict
    metrics: Any = None 
    # [FIX] P0-1: å¢åŠ  term å­—æ®µï¼Œé˜²æ­¢ Calendar ç­–ç•¥æŠ¥é”™
    term: List[TermPoint] = field(default_factory=list) 

@dataclass
class ScoreBreakdown:
    base: int = 0
    regime: int = 0
    edge: int = 0
    hv: int = 0
    curvature: int = 0
    penalties: int = 0

@dataclass
class RiskBreakdown:
    base: int = 0
    dte: int = 0
    gamma: int = 0
    regime: int = 0
    curvature: int = 0
    penalties: int = 0

@dataclass
class ScanRow:
    symbol: str
    price: float
    short_exp: str
    short_dte: int
    short_iv: float
    base_iv: float
    edge: float
    hv_rank: float
    regime: str
    curvature: str
    tag: str
    cal_score: int
    short_risk: int
    score_breakdown: ScoreBreakdown
    risk_breakdown: RiskBreakdown
    meta: Dict[str, Any] = field(default_factory=dict)
    # å…è®¸åŠ¨æ€æŒ‚è½½ blueprint
    blueprint: Optional[Blueprint] = None

@dataclass
class Recommendation:
    strategy: str
    symbol: str
    action: str
    rationale: str
    entry_price: float
    score: int
    conviction: str
    meta: dict

# --- æ‰§è¡Œè“å›¾ç±» (Orchestrator éœ€è¦) ---

@dataclass
class OrderLeg:
    """å®šä¹‰æœŸæƒç­–ç•¥çš„ä¸€æ¡è…¿"""
    symbol: str
    action: str      # BUY / SELL
    ratio: int       # e.g. 1
    exp: str         # Expiry Date (YYYY-MM-DD)
    strike: float
    type: str        # CALL / PUT

@dataclass
class Blueprint:
    """å®šä¹‰æœ€ç»ˆç”Ÿæˆçš„æ‰§è¡Œè“å›¾"""
    symbol: str
    strategy: str
    legs: List[OrderLeg] = field(default_factory=list)
    est_debit: float = 0.0
    note: str = ""
    gamma_exposure: float = 0.0
    error: Optional[str] = None
    # å…è®¸åŠ¨æ€æŒ‚è½½ greeks å­—å…¸
    short_greeks: Dict[str, float] = field(default_factory=dict)
    long_greeks: Dict[str, float] = field(default_factory=dict)
    greeks: Dict[str, float] = field(default_factory=dict)

    def one_liner(self) -> str:
        return f"{self.symbol} {self.strategy} | est_debit={self.est_debit}"

================================================================================
FILE_PATH: src\trade_guardian\domain\policy.py
================================================================================
from dataclasses import dataclass
from typing import List


@dataclass(frozen=True)
class ShortLegPolicy:
    base_rank: int = 1
    min_dte: int = 3
    max_probe_rank: int = 3  # count, e.g. 3 => ranks base..base+2

    def probe_ranks(self) -> List[int]:
        if self.max_probe_rank <= 1:
            return [self.base_rank]
        return list(range(self.base_rank, self.base_rank + self.max_probe_rank))


================================================================================
FILE_PATH: src\trade_guardian\domain\registry.py
================================================================================
from __future__ import annotations

from trade_guardian.domain.policy import ShortLegPolicy

from trade_guardian.strategies.auto import AutoStrategy  # <--- æ–°å¢
from trade_guardian.strategies.calendar import CalendarStrategy
from trade_guardian.strategies.hv_calendar import HVCalendarStrategy
from trade_guardian.strategies.long_gamma import LongGammaStrategy
from trade_guardian.strategies.diagonal import DiagonalStrategy



class StrategyRegistry:
    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy

    def get(self, name: str):
        n = (name or "").strip().lower()

        if n in ("calendar", "cal"):
            return CalendarStrategy(self.cfg, self.policy)

        if n in ("hv_calendar", "hvcal", "hv"):
            return HVCalendarStrategy(self.cfg, self.policy)
            
        if n in ("long_gamma", "gamma", "straddle", "lg"):
            return LongGammaStrategy(self.cfg, self.policy)
        
        if n in ("diagonal", "pmcc", "diag"):
            return DiagonalStrategy(self.cfg, self.policy)
        
        # æ³¨å†Œ auto
        if n in ("auto", "smart", "default"):
            return AutoStrategy(self.cfg, self.policy)
        
        # [FIX] Minor: ä¿®æ­£æŠ¥é”™ä¿¡æ¯ï¼ŒåŒ…å« diagonal å’Œ auto
        raise KeyError(f"Unknown strategy: {name}. Available: calendar, hv_calendar, long_gamma, diagonal, auto")

================================================================================
FILE_PATH: src\trade_guardian\domain\scoring.py
================================================================================
from __future__ import annotations

from dataclasses import dataclass

from trade_guardian.domain.models import ScoreBreakdown


@dataclass(frozen=True)
class ScoringRules:
    # core
    min_edge_short_base: float = 1.05

    # HV-aware (Strategy #2)
    hv_enabled: bool = False
    hv_low_rank: float = 20.0
    hv_mid_rank: float = 50.0
    hv_high_rank: float = 70.0

    hv_low_bonus: int = 10     # hv_rank <= low
    hv_mid_bonus: int = 4      # (low, mid]
    hv_high_penalty: int = -4  # (mid, high]
    hv_extreme_penalty: int = -10  # > high


class Scoring:
    def __init__(self, rules: ScoringRules):
        self.rules = rules

    def _hv_points(self, hv_rank: float) -> int:
        """
        HV scoring (explainable bucket model):
          - low hv_rank: calendars generally benefit from "room for vol expansion"
          - high hv_rank: you're paying rich vol; calendar can become "chasing vol"
        """
        if not self.rules.hv_enabled:
            return 0

        r = float(hv_rank)
        if r <= self.rules.hv_low_rank:
            return int(self.rules.hv_low_bonus)
        if r <= self.rules.hv_mid_rank:
            return int(self.rules.hv_mid_bonus)
        if r <= self.rules.hv_high_rank:
            return int(self.rules.hv_high_penalty)
        return int(self.rules.hv_extreme_penalty)

    def score_calendar(self, regime: str, curvature: str, edge: float, hv_rank: float) -> tuple[int, ScoreBreakdown]:
        """
        Keep simple & explainable:
          base 50
          +curv bonus when SPIKY_FRONT
          edge: reward if >= min_edge_short_base, penalty if weak
          regime: penalize CONTANGO a bit, neutral FLAT, small bonus BACKWARDATION
          hv: optional bucketed adjustment (Strategy #2)
        """
        bd = ScoreBreakdown(base=50)

        # regime
        if regime == "CONTANGO":
            bd.regime = -8
        elif regime == "BACKWARDATION":
            bd.regime = +4
        else:
            bd.regime = 0

        # curvature
        bd.curvature = +6 if curvature == "SPIKY_FRONT" else 0

        # edge
        if edge >= self.rules.min_edge_short_base:
            bd.edge = +8
        elif edge >= 1.0:
            bd.edge = -8
        else:
            bd.edge = -14

        # hv (strategy #2)
        bd.hv = self._hv_points(hv_rank)

        total = bd.base + bd.regime + bd.edge + bd.hv + bd.curvature + bd.penalties
        return int(total), bd


================================================================================
FILE_PATH: src\trade_guardian\domain\__init__.py
================================================================================



================================================================================
FILE_PATH: src\trade_guardian\infra\cache.py
================================================================================
from __future__ import annotations

import json
import os
from datetime import datetime
from typing import Any, Dict, Optional


class JsonDailyCache:
    """
    Simple daily cache. Resets automatically each day by storing a date stamp.
    """
    def __init__(self, path: str):
        self.path = path
        self._data: Dict[str, Any] = {}
        self._load()

    def _load(self):
        if not os.path.exists(self.path):
            self._data = {"_date": self._today(), "items": {}}
            return
        try:
            with open(self.path, "r", encoding="utf-8") as f:
                self._data = json.load(f)
        except Exception:
            self._data = {"_date": self._today(), "items": {}}

        if self._data.get("_date") != self._today():
            self._data = {"_date": self._today(), "items": {}}

    def _save(self):
        os.makedirs(os.path.dirname(self.path), exist_ok=True)
        with open(self.path, "w", encoding="utf-8") as f:
            json.dump(self._data, f, indent=2)

    @staticmethod
    def _today() -> str:
        return datetime.now().strftime("%Y-%m-%d")

    def get(self, key: str) -> Optional[dict]:
        return self._data.get("items", {}).get(key)

    def set(self, key: str, value: dict) -> None:
        self._data.setdefault("items", {})[key] = value
        self._save()


================================================================================
FILE_PATH: src\trade_guardian\infra\config.py
================================================================================
from __future__ import annotations

import json
import os
from typing import Any, Dict, Optional

from trade_guardian.domain.policy import ShortLegPolicy

DEFAULT_CONFIG: Dict[str, Any] = {
    "paths": {
        "tickers_csv": "data/tickers.csv",
        "cache_dir": "cache",
    },
    "scan": {
        "throttle_sec": 0.50,
        "contract_type": "ALL",
    },
    "rules": {
        "min_edge_short_base": 1.05,
    },
    "policy": {
        "base_rank": 1,
        "min_dte": 3,
        # å…¼å®¹ä¸¤ç§å†™æ³•ï¼šprobe_count / max_probe_rank
        # - probe_count=3 => æ¢æµ‹ base..base+2
        "probe_count": 3,
        # "max_probe_rank": 3,
    },
    "strategies": {
        "hv_calendar": {
            "hv_rules": {
                "hv_low_rank": 20.0,
                "hv_mid_rank": 50.0,
                "hv_high_rank": 70.0,
                "hv_low_bonus": 10,
                "hv_mid_bonus": 4,
                "hv_high_penalty": -4,
                "hv_extreme_penalty": -10,
            }
        }
    },
}


def _deep_merge(a: Dict[str, Any], b: Dict[str, Any]) -> Dict[str, Any]:
    out = dict(a)
    for k, v in b.items():
        if isinstance(v, dict) and isinstance(out.get(k), dict):
            out[k] = _deep_merge(out[k], v)  # type: ignore[arg-type]
        else:
            out[k] = v
    return out


def load_config(path: str, default_cfg: Dict[str, Any]) -> Dict[str, Any]:
    if not os.path.exists(path):
        return dict(default_cfg)
    with open(path, "r", encoding="utf-8") as f:
        user_cfg = json.load(f)
    if not isinstance(user_cfg, dict):
        return dict(default_cfg)
    return _deep_merge(default_cfg, user_cfg)


def write_config_template(path: str, default_cfg: Dict[str, Any], overwrite: bool = False) -> None:
    if os.path.exists(path) and not overwrite:
        return
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        json.dump(default_cfg, f, indent=2, ensure_ascii=False)


def merge_config_paths(cfg: Dict[str, Any], root: str, csv_override: Optional[str]) -> Dict[str, Any]:
    out = dict(cfg)
    out.setdefault("paths", {})
    paths = dict(out["paths"])

    if csv_override:
        paths["tickers_csv"] = csv_override

    tickers_csv = paths.get("tickers_csv", "data/tickers.csv")
    if not os.path.isabs(tickers_csv):
        tickers_csv = os.path.join(root, tickers_csv)
    paths["tickers_csv"] = os.path.normpath(tickers_csv)

    cache_dir = paths.get("cache_dir", "cache")
    if not os.path.isabs(cache_dir):
        cache_dir = os.path.join(root, cache_dir)
    paths["cache_dir"] = os.path.normpath(cache_dir)

    out["paths"] = paths
    return out


def _resolve_probe_count(pcfg: Dict[str, Any], base_rank: int) -> int:
    """
    Return probe_count (>=1).
    æ”¯æŒï¼š
      - policy.probe_count
      - policy.max_probe_rank (inclusive)
    """
    if "probe_count" in pcfg and pcfg.get("probe_count") is not None:
        try:
            c = int(pcfg["probe_count"])
            return max(1, c)
        except Exception:
            return 3

    if "max_probe_rank" in pcfg and pcfg.get("max_probe_rank") is not None:
        try:
            mx = int(pcfg["max_probe_rank"])
            # max_probe_rank is inclusive absolute rank; convert to count
            return max(1, (mx - int(base_rank) + 1))
        except Exception:
            return 3

    return 3


def policy_from_cfg_and_cli(cfg: Dict[str, Any], args) -> ShortLegPolicy:
    """
    Build ShortLegPolicy from config + CLI overrides.

    CLI args:
      --short-rank
      --min-short-dte
      --max-probe-rank   (meaning: absolute inclusive rank upper bound)
    """
    pcfg = (cfg.get("policy", {}) or {})

    base_rank = int(pcfg.get("base_rank", 1))
    min_dte = int(pcfg.get("min_dte", 3))
    probe_count = _resolve_probe_count(pcfg, base_rank)

    # CLI overrides
    if getattr(args, "short_rank", None) is not None:
        base_rank = int(args.short_rank)
    if getattr(args, "min_short_dte", None) is not None:
        min_dte = int(args.min_short_dte)

    if getattr(args, "max_probe_rank", None) is not None:
        mx = int(args.max_probe_rank)
        probe_count = max(1, (mx - int(base_rank) + 1))

    # âœ… ç”¨ä½ç½®å‚æ•°ï¼šé¿å… dataclass å­—æ®µåå˜åŒ–å¯¼è‡´çš„ keyword å´©æºƒ
    # çº¦å®šï¼šShortLegPolicy(base_rank, min_dte, probe_count)
    return ShortLegPolicy(int(base_rank), int(min_dte), int(probe_count))


================================================================================
FILE_PATH: src\trade_guardian\infra\rate_limit.py
================================================================================
import time


class RateLimiter:
    def __init__(self, throttle_sec: float):
        self.throttle_sec = float(throttle_sec)

    def sleep(self):
        if self.throttle_sec > 0:
            time.sleep(self.throttle_sec)


================================================================================
FILE_PATH: src\trade_guardian\infra\retry_option_chain.py
================================================================================
from __future__ import annotations

import json
import logging
import random
import time
from dataclasses import dataclass, asdict
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Callable, Dict, Optional, Tuple

log = logging.getLogger(__name__)


@dataclass(frozen=True)
class RetryConfig:
    max_attempts: int = 3
    base_sleep_s: float = 0.5      # first backoff
    max_sleep_s: float = 4.0       # cap
    jitter_s: float = 0.15         # random +/- jitter
    timeout_s: float = 10.0        # if your client supports timeout, pass it through


@dataclass
class FetchAttemptRecord:
    ts_utc: str
    symbol: str
    provider: str
    attempt: int
    max_attempts: int
    ok: bool

    # request parameters you care about
    request_params: Dict[str, Any]

    # response/exception info
    reason: str = ""               # classified reason string
    http_status: Optional[int] = None
    error: str = ""                # exception message if any
    response_meta: Dict[str, Any] = None  # optional: headers, request_id, etc.
    response_snippet: str = ""     # short text snippet (safe length)


class OptionChainFetchError(RuntimeError):
    pass


def _utc_now_iso() -> str:
    return datetime.now(timezone.utc).isoformat(timespec="seconds")


def _safe_snippet(s: Any, max_len: int = 400) -> str:
    if s is None:
        return ""
    try:
        txt = s if isinstance(s, str) else json.dumps(s, ensure_ascii=False)
    except Exception:
        txt = repr(s)
    txt = txt.replace("\n", " ").replace("\r", " ")
    return txt[:max_len]


def classify_empty_response(
    *,
    payload: Any,
    http_status: Optional[int] = None,
    error: Optional[BaseException] = None,
) -> str:
    """
    Return a stable machine-readable reason.
    Keep this conservative: it's for diagnostics, not logic.
    """
    if error is not None:
        msg = str(error).lower()
        if "timeout" in msg:
            return "timeout"
        if "rate" in msg or "429" in msg:
            return "rate_limited"
        if "403" in msg or "forbidden" in msg:
            return "forbidden"
        if "401" in msg or "unauthorized" in msg:
            return "unauthorized"
        if "not found" in msg or "404" in msg:
            return "not_found"
        if "connection" in msg or "ssl" in msg:
            return "network_error"
        return "exception"

    if http_status is not None:
        if http_status == 204:
            return "no_content"
        if http_status == 404:
            return "not_found"
        if http_status == 401:
            return "unauthorized"
        if http_status == 403:
            return "forbidden"
        if http_status == 429:
            return "rate_limited"
        if 500 <= http_status <= 599:
            return "server_error"
        if 400 <= http_status <= 499:
            return "client_error"

    # payload-level hints
    if payload is None:
        return "payload_none"
    if isinstance(payload, (list, tuple)) and len(payload) == 0:
        return "payload_empty_list"
    if isinstance(payload, dict) and len(payload.keys()) == 0:
        return "payload_empty_dict"

    # common shapes: provider returns {"errors":[...]} or {"message": "..."}
    if isinstance(payload, dict):
        if "error" in payload:
            return "payload_error_field"
        if "errors" in payload and payload.get("errors"):
            return "payload_errors"
        if "message" in payload and payload.get("message"):
            return "payload_message"
        # option-chain typical: chain/expirations missing
        for k in ("callExpDateMap", "putExpDateMap", "options", "data"):
            if k in payload and not payload.get(k):
                return f"payload_missing_{k}"

    return "unknown_empty_or_unexpected"


def _write_jsonl(path: Path, record: Dict[str, Any]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("a", encoding="utf-8") as f:
        f.write(json.dumps(record, ensure_ascii=False) + "\n")


def fetch_with_retry_and_diagnostics(
    *,
    symbol: str,
    provider: str,
    request_params: Dict[str, Any],
    fetch_fn: Callable[[Dict[str, Any]], Tuple[Any, Optional[int], Dict[str, Any]]],
    # fetch_fn contract:
    #   input: request_params
    #   return: (payload, http_status, response_meta)
    #   - http_status may be None if not available
    #   - response_meta may include request_id, headers, url, etc.
    retry: RetryConfig = RetryConfig(),
    diag_jsonl_path: Path = Path("cache") / "option_chain_failures.jsonl",
    # If True: only retry on transient reasons; if False: retry all failures
    retry_only_transient: bool = True,
) -> Any:
    """
    This function is meant to sit in your infra layer.
    It does:
      - retry/backoff
      - classify failures and write JSONL diagnostic records
    """

    transient_reasons = {
        "timeout",
        "network_error",
        "server_error",
        "rate_limited",
        "no_content",
        "unknown_empty_or_unexpected",
        "payload_none",
        "payload_empty_list",
        "payload_empty_dict",
    }

    last_error: Optional[BaseException] = None
    last_reason = "unknown"
    last_status: Optional[int] = None
    last_meta: Dict[str, Any] = {}

    for attempt in range(1, retry.max_attempts + 1):
        try:
            payload, http_status, response_meta = fetch_fn(request_params)
            last_status = http_status
            last_meta = response_meta or {}

            # treat "empty payload" as failure that can be retried (often transient)
            is_empty = payload is None
            if not is_empty and isinstance(payload, (list, tuple, dict)):
                is_empty = (len(payload) == 0)

            if is_empty:
                reason = classify_empty_response(payload=payload, http_status=http_status)
                last_reason = reason

                rec = FetchAttemptRecord(
                    ts_utc=_utc_now_iso(),
                    symbol=symbol,
                    provider=provider,
                    attempt=attempt,
                    max_attempts=retry.max_attempts,
                    ok=False,
                    request_params=request_params,
                    reason=reason,
                    http_status=http_status,
                    error="",
                    response_meta=response_meta or {},
                    response_snippet=_safe_snippet(payload),
                )
                _write_jsonl(diag_jsonl_path, asdict(rec))

                # decide retry
                if attempt < retry.max_attempts and (not retry_only_transient or reason in transient_reasons):
                    _sleep_backoff(attempt, retry)
                    continue

                raise OptionChainFetchError(f"{symbol}: empty option chain payload ({reason})")

            # success
            return payload

        except Exception as e:
            last_error = e
            reason = classify_empty_response(payload=None, http_status=last_status, error=e)
            last_reason = reason

            rec = FetchAttemptRecord(
                ts_utc=_utc_now_iso(),
                symbol=symbol,
                provider=provider,
                attempt=attempt,
                max_attempts=retry.max_attempts,
                ok=False,
                request_params=request_params,
                reason=reason,
                http_status=last_status,
                error=str(e),
                response_meta=last_meta or {},
                response_snippet="",
            )
            _write_jsonl(diag_jsonl_path, asdict(rec))

            if attempt < retry.max_attempts and (not retry_only_transient or reason in transient_reasons):
                _sleep_backoff(attempt, retry)
                continue

            raise

    # should never reach
    if last_error is not None:
        raise last_error
    raise OptionChainFetchError(f"{symbol}: failed to fetch option chain ({last_reason})")


def _sleep_backoff(attempt: int, retry: RetryConfig) -> None:
    # exponential backoff with jitter
    base = retry.base_sleep_s * (2 ** (attempt - 1))
    sleep_s = min(retry.max_sleep_s, base)
    sleep_s += random.uniform(-retry.jitter_s, retry.jitter_s)
    sleep_s = max(0.0, sleep_s)
    time.sleep(sleep_s)


================================================================================
FILE_PATH: src\trade_guardian\infra\schwab_client.py
================================================================================
from __future__ import annotations

import requests
import numpy as np
import pandas as pd
import traceback
from datetime import datetime, timedelta, date
from urllib.parse import quote
from typing import Optional, Any, List

from trade_guardian.domain.models import Context, IVData, HVInfo, TermPoint
from trade_guardian.infra.schwab_token_manager import fetch_schwab_token

# --- Helper Functions (ç‰©ç†ç‰¹å¾è¾…åŠ©) ---
def _to_date(iso: str) -> date:
    return datetime.strptime(iso, "%Y-%m-%d").date()

def is_third_friday(d: date) -> bool:
    """åˆ¤æ–­æ˜¯å¦ä¸ºæ ‡å‡†æœˆåº¦æœŸæƒ (ç¬¬ä¸‰ä¸ªå‘¨äº”)"""
    return d.weekday() == 4 and 15 <= d.day <= 21

def get_series_kind(exp_str: str) -> str:
    """æ ¹æ®åˆ°æœŸæ—¥åˆ¤æ–­åˆçº¦ç±»å‹ï¼šMONTHLY, WEEKLY, DAILY"""
    d = _to_date(exp_str)
    if is_third_friday(d): return "MONTHLY"
    if d.weekday() == 4: return "WEEKLY"
    return "DAILY"

class SchwabClient:
    OPTION_CHAIN_URL = "https://api.schwabapi.com/marketdata/v1/chains"
    QUOTE_URL_TEMPLATE = "https://api.schwabapi.com/marketdata/v1/quotes?symbols={symbols}&fields=quote"
    PRICE_HISTORY_URL = "https://api.schwabapi.com/marketdata/v1/pricehistory"

    def __init__(self, cfg: dict = None):
        self.cfg = cfg or {}

    def build_context(self, symbol: str, days: int = 600) -> Optional[Context]:
        """
        [Tactical Refactor] Curve-Driven Context Builder
        ä¼˜åŒ–ç›®æ ‡ï¼šåœ¨æ‰«æå…¨é‡åœ°å½¢çš„åŸºç¡€ä¸Šï¼Œå¼•å…¥æˆ˜æœ¯åå¥½ (Tactical Bias)
          1. Micro: ä¼˜å…ˆæ•æ‰å•ä½æ—¶é—´å†…çš„ IV çˆ†å‘åŠ› (Front Momentum)
          2. Month: åœ¨å¹³ç¨³åŒºåŸºç¡€ä¸Šï¼Œæƒ©ç½šè¿‡è¿œçš„ DTEï¼Œé”šå®š 35DTE æˆ˜æœ¯åŒº
        """
        try:
            # 1. è·å– HV æ•°æ®
            hv_info = self.calculate_hv_percentile(symbol)
            if getattr(hv_info, 'status', '') == "Error":
                hv_info = HVInfo(current_hv=0.0, hv_rank=50.0)

            # 2. è·å–å…¨é‡æœŸæƒé“¾
            try:
                price, term_points, raw_chain = self.scan_atm_term(symbol, days)
            except Exception as e:
                return None

            if not term_points or len(term_points) < 3:
                return None

            # 3. æ’åº
            term_points.sort(key=lambda x: x.dte)

            # =================================================================
            # ç®—æ³• A: ç¡®å®š Short Leg (æ‰§è¡Œè…¿)
            # é€»è¾‘ï¼š1-10 DTE ä¸­æœ€è¿‘çš„é 0DTE
            # =================================================================
            short_candidates = [p for p in term_points if 1 <= p.dte <= 10]
            if short_candidates:
                short_point = min(short_candidates, key=lambda x: x.dte)
            else:
                short_point = term_points[0]
            
            short_kind = get_series_kind(short_point.exp)
            short_iv_base = short_point.iv if short_point.iv > 0 else 1.0

            # =================================================================
            # ç®—æ³• B: å¯»æ‰¾ Micro Anchor (å¼•å…¥å‰ç«¯çˆ†å‘åŠ›è¯„åˆ†)
            # é€»è¾‘ï¼šåœ¨ 1-15 DTE ä¸­ï¼Œä¼˜å…ˆæ‰¾å±€éƒ¨æ³¢å³°ï¼›è‹¥æ— ï¼Œæ‰¾å•ä½æ—¶é—´ IV å¢å¹…æœ€å¤§çš„ç‚¹
            # =================================================================
            micro_pool = [p for p in term_points if 1 <= p.dte <= 15]
            micro_point = None

            if len(micro_pool) >= 2:
                # 1. ä¼˜å…ˆï¼šå¯»æ‰¾å±€éƒ¨æå¤§å€¼ (Local Maxima) -> æ˜¾æ€§æŒ¤å‹
                local_maxima = []
                for i in range(1, len(micro_pool) - 1):
                    if micro_pool[i].iv > micro_pool[i-1].iv and micro_pool[i].iv > micro_pool[i+1].iv:
                        local_maxima.append(micro_pool[i])
                
                if local_maxima:
                    micro_point = max(local_maxima, key=lambda x: x.iv)
                else:
                    # 2. å…œåº•ï¼šæ— å±€éƒ¨å³°å€¼æ—¶ï¼Œå¯»æ‰¾ "å•ä½æ—¶é—´çˆ†å‘åŠ›" æœ€å¼ºçš„ç‚¹
                    # å…¬å¼ï¼šScore = (IV - ShortIV) / sqrt(DTE)
                    # é¿å…æ— è„‘é€‰æœ€è¿œç«¯ï¼Œè€Œæ˜¯é€‰æ›²çº¿æœ€é™¡å³­çš„é‚£ä¸€æ®µ
                    def _momentum_score(p):
                        d_eff = max(1, p.dte)
                        return (p.iv - short_iv_base) / np.sqrt(d_eff)
                    
                    micro_point = max(micro_pool, key=_momentum_score)
            
            # Fallback
            if not micro_point or micro_point.dte <= short_point.dte:
                candidates = [p for p in term_points if p.dte > short_point.dte and p.dte <= 21]
                if candidates:
                    micro_point = min(candidates, key=lambda x: abs(x.dte - 10))
                else:
                    micro_point = short_point

            # =================================================================
            # ç®—æ³• C: å¯»æ‰¾ Month Anchor (æˆ˜æœ¯çª—å£ä¿®æ­£)
            # é€»è¾‘ï¼šä¼˜å…ˆåœ¨ 25-45 DTE (æˆ˜æœ¯åŒº) å¯»æ‰¾é”šç‚¹ï¼›è‹¥æ— æ•°æ®ï¼Œå†æ‰©è‡³ 25-90 DTE
            # =================================================================
            month_pool = [p for p in term_points if 25 <= p.dte <= 45]
            if len(month_pool) < 3:
                month_pool = [p for p in term_points if 25 <= p.dte <= 90]
            
            month_point = None
            
            # ä½¿ç”¨ç®€å•çš„è·ç¦»+å¹³ç¨³åº¦æ‰“åˆ† (ä¿æŒåŸé€»è¾‘ï¼Œä½†æ± å­å˜äº†)
            TARGET_MONTH = 35.0
            LAMBDA_DIST = 0.35 

            if len(month_pool) >= 3:
                scored_candidates = []
                for i in range(1, len(month_pool) - 1):
                    window = [month_pool[i-1].iv, month_pool[i].iv, month_pool[i+1].iv]
                    sd = np.std(window)
                    dist_penalty = abs(month_pool[i].dte - TARGET_MONTH) / TARGET_MONTH
                    score = sd + (LAMBDA_DIST * dist_penalty)
                    scored_candidates.append((score, sd, month_pool[i]))
                
                scored_candidates.sort(key=lambda x: x[0])
                top_5 = scored_candidates[:min(5, len(scored_candidates))]
                
                # åœ¨ä¼˜èƒœç»„é‡Œä¼˜å…ˆé€‰ Monthly
                best_monthly = next((p for sc, sd, p in top_5 if get_series_kind(p.exp) == "MONTHLY"), None)
                month_point = best_monthly if best_monthly else top_5[0][2]
            else:
                # Fallback
                fallback_candidates = [p for p in term_points if p.dte >= 20]
                if fallback_candidates:
                    month_point = min(fallback_candidates, key=lambda x: abs(x.dte - 30))
                else:
                    month_point = term_points[-1]


            # =================================================================
            # 4. æ•°æ®ç»„è£…ä¸ Edge ç¨³å¥è®¡ç®— (Stabilizer V3)
            # =================================================================
            short_iv = short_point.iv
            micro_iv = micro_point.iv
            month_iv = month_point.iv

            if short_iv <= 0: short_iv = 1.0
            if month_iv <= 0: month_iv = 1.0

            # ç»“æ„åˆ¤å®š
            is_squeeze = True if (micro_iv > month_iv * 1.05) else False
            
            regime = "FLAT"
            if short_iv > month_iv * 1.03: regime = "BACKWARDATION"
            elif month_iv > short_iv * 1.03: regime = "CONTANGO"

            curvature = "NORMAL"
            if micro_iv > short_iv * 1.10: curvature = "SPIKY_FRONT"

            # [Edge Stabilizer V3]
            # 1. Short Base (Median): è¿™é‡Œçš„ Short IV å®¹æ˜“å—å•æ—¥äº‹ä»¶å½±å“å‡ºç°æ¯›åˆºã€‚
            #    ä½¿ç”¨ 1-10 DTE åŒºé—´çš„ä¸­ä½æ•°ä½œä¸ºæ›´ç¨³å¥çš„"çŸ­æœŸåŸºå‡†"ã€‚
            short_band = [p.iv for p in term_points if 1 <= p.dte <= 10 and p.iv > 0]
            short_base = np.median(short_band) if short_band else short_iv

            # 2. Mixed Denominator: é˜²æ­¢åˆ†æ¯è¿‡å°ï¼ŒåŒæ—¶ä¹Ÿé˜²æ­¢ä½æ³¢ç¯å¢ƒä¸‹ Edge è¢«è¿‡åº¦å‹ç¼©ã€‚
            #    ä½¿ç”¨ (Base + Far) / 2 ä½œä¸ºåˆ†æ¯ï¼Œå¹¶ä¿ç•™ 12.0 çš„ç¡¬åœ°æ¿ã€‚
            IV_FLOOR = 12.0
            denom_micro = max(0.5 * (short_base + micro_iv), IV_FLOOR)
            denom_month = max(0.5 * (short_base + month_iv), IV_FLOOR)
            
            edge_micro_raw = (micro_iv - short_base) / denom_micro
            edge_month_raw = (month_iv - short_base) / denom_month
            
            # 3. Extended Soft Decay: å°†è¡°å‡èŒƒå›´æ‰©è‡³ 6 DTE (å‘¨æƒè¦†ç›–åŒº)
            #    ç³»æ•°ä» 0.7 èµ·æ­¥ (sqrt(1/6)=0.4å¤ªç‹ äº†ï¼Œæˆ‘ä»¬è®¾æ­»åº•çº¿)
            DECAY_CUTOFF = 6.0
            stabilizer = 1.0
            
            if short_point.dte < DECAY_CUTOFF:
                # å¹³æ»‘å› å­
                raw_decay = np.sqrt(max(1, short_point.dte) / DECAY_CUTOFF)
                # é™åˆ¶èŒƒå›´ [0.7, 1.0]ï¼Œé¿å…å¯¹ 1-2 DTE æƒ©ç½šè¿‡é‡å¯¼è‡´å®Œå…¨ä¸å¯äº¤æ˜“
                stabilizer = max(0.7, min(1.0, raw_decay))
                
                edge_micro_raw *= stabilizer
                edge_month_raw *= stabilizer

            # [DEBUG] æ‰“å°è°ƒè¯•ä¿¡æ¯ï¼ŒéªŒè¯æ•°å€¼æ˜¯å¦åˆç† (æ­£å¼ç‰ˆå¯æ³¨é‡Š)
            # print(f"[DBG] {symbol:<5} DTE:{short_point.dte} Base:{short_base:.1f}% M_IV:{month_iv:.1f}% Stab:{stabilizer:.2f} Edge:{edge_month_raw:.2f}")

            tsf = {
                "regime": regime,
                "curvature": curvature,
                "is_squeeze": is_squeeze,

                # Anchor Points
                "short_exp": short_point.exp, "short_dte": short_point.dte, "short_iv": short_point.iv, "short_kind": short_kind,
                "micro_exp": micro_point.exp, "micro_dte": micro_point.dte, "micro_iv": micro_point.iv,
                "month_exp": month_point.exp, "month_dte": month_point.dte, "month_iv": month_point.iv,

                # Stabilized Edges
                "edge_micro": edge_micro_raw,
                "edge_month": edge_month_raw,
            }
            
            # 5. è¿”å› Context
            iv_data = IVData(
                rank=hv_info.hv_rank, percentile=0.0, current_iv=short_iv, 
                hv_rank=hv_info.hv_rank, current_hv=hv_info.current_hv
            )
            
            class Metrics: pass
            metrics = Metrics()
            metrics.gamma = short_point.gamma
            metrics.delta = short_point.delta
            metrics.theta = short_point.theta

            # [FIX] P0-1: è¿™é‡Œå¢åŠ äº† term=term_points
            return Context(
                symbol=symbol, 
                price=price, 
                iv=iv_data, 
                hv=iv_data, 
                tsf=tsf, 
                raw_chain=raw_chain, 
                metrics=metrics,
                term=term_points 
            )
        
        except Exception as e:
            return None

    # --- åŸºç¡€ API æ–¹æ³•ä¿æŒä¸å˜ ---
    def _headers(self):
        token = fetch_schwab_token()
        if not token: raise ValueError("Token fetch failed")
        return {"Authorization": f"Bearer {token}", "Accept": "application/json"}

    def get_quote(self, symbol: str) -> dict:
        encoded = quote(symbol, safe="")
        url = self.QUOTE_URL_TEMPLATE.format(symbols=encoded)
        resp = requests.get(url, headers=self._headers(), timeout=20)
        return resp.json().get(symbol, {}).get("quote", {}) or {}

    def calculate_hv_percentile(self, symbol: str) -> HVInfo:
        try:
            params = {"symbol": symbol, "periodType": "year", "period": 2, "frequencyType": "daily", "frequency": 1}
            resp = requests.get(self.PRICE_HISTORY_URL, headers=self._headers(), params=params, timeout=30)
            data = resp.json()
            candles = data.get("candles") or []
            if not candles: return HVInfo(status="Error")

            df = pd.DataFrame(candles)
            df["close"] = df["close"].astype(float)
            df["log_ret"] = np.log(df["close"] / df["close"].shift(1))
            df["hv"] = df.dropna(subset=["log_ret"])["log_ret"].rolling(window=20).std() * np.sqrt(252) * 100
            
            current_hv = float(df["hv"].iloc[-1])
            recent = df["hv"].dropna().tail(252)
            hv_low, hv_high = float(recent.min()), float(recent.max())
            hv_rank = (current_hv - hv_low) / (hv_high - hv_low) * 100.0 if hv_high > hv_low else 0.0
            
            return HVInfo(status="Success", current_hv=current_hv, hv_rank=hv_rank, hv_low=hv_low, hv_high=hv_high)
        except: return HVInfo(status="Error")

    def _fetch_calls_chain(self, symbol: str, from_d: str, to_d: str, range_val: str = "NTM") -> dict:
        params = {"symbol": symbol, "contractType": "ALL", "strategy": "SINGLE", "range": range_val, "fromDate": from_d, "toDate": to_d}
        resp = requests.get(self.OPTION_CHAIN_URL, headers=self._headers(), params=params, timeout=30)
        return resp.json() if resp.status_code == 200 else {}

    def scan_atm_term(self, symbol: str, days: int) -> tuple[float, list[TermPoint], dict]:
        """ä¸€æ¬¡æ€§è·å–æœªæ¥ N å¤©çš„å…¨é‡æœŸæƒé“¾"""
        q = self.get_quote(symbol)
        price = float(q.get("lastPrice") or 0.0)
        if price == 0: raise RuntimeError(f"No price for {symbol}")

        from_date = datetime.now().strftime("%Y-%m-%d")
        to_date = (datetime.now() + timedelta(days=days)).strftime("%Y-%m-%d")
        
        chain = self._fetch_calls_chain(symbol, from_date, to_date, range_val="ALL")
        call_map = chain.get("callExpDateMap") or {}

        term: list[TermPoint] = []
        for date_str, strikes_map in sorted(call_map.items()):
            parts = date_str.split(":")
            date_iso, dte = parts[0], int(parts[1])
            
            best_strike, min_dist, best_data = 0.0, 1e18, None
            for s_str, contracts in strikes_map.items():
                s_val = float(s_str)
                dist = abs(s_val - price)
                if dist < min_dist:
                    c = contracts[0]
                    iv = float(c.get("volatility", 0) or 0.0)
                    if iv > 0:
                        if iv < 5.0: iv *= 100.0
                        min_dist, best_strike = dist, s_val
                        best_data = {
                            "iv": iv, "mark": float(c.get("mark") or 0.0), 
                            "delta": float(c.get("delta") or 0.0), 
                            "theta": float(c.get("theta") or 0.0), 
                            "gamma": float(c.get("gamma") or 0.0)
                        }
            if best_data:
                term.append(TermPoint(exp=date_iso, dte=dte, strike=best_strike, **best_data))
        
        return price, term, chain

================================================================================
FILE_PATH: src\trade_guardian\infra\schwab_token_manager.py
================================================================================
# trade_guardian/infra/schwab_token_manager.py
from __future__ import annotations

import os

def fetch_schwab_token() -> str:
    """
    Resolve Schwab OAuth access token.
    Priority:
      1) env SCHWAB_ACCESS_TOKEN
      2) legacy module shipped with this project: schwab_token_manager_legacy.py
      3) legacy global module name: schwab_token_manager (if user has it on PYTHONPATH)
    """
    tok = os.getenv("SCHWAB_ACCESS_TOKEN", "").strip()
    if tok:
        return tok

    # local legacy copy (recommended)
    try:
        from .schwab_token_manager_legacy import fetch_schwab_token as legacy_fetch
        tok = (legacy_fetch() or "").strip()
        if tok:
            return tok
    except Exception:
        pass

    # global legacy name (optional)
    try:
        from schwab_token_manager import fetch_schwab_token as global_fetch  # type: ignore
        tok = (global_fetch() or "").strip()
        if tok:
            return tok
    except Exception:
        pass

    raise RuntimeError(
        "Schwab token not found. "
        "Set env SCHWAB_ACCESS_TOKEN, or copy your old schwab_token_manager.py into "
        "trade_guardian/infra/schwab_token_manager_legacy.py."
    )


================================================================================
FILE_PATH: src\trade_guardian\infra\schwab_token_manager_legacy.py
================================================================================
# File: schwab_token_manager.py

import requests
import json
from typing import Optional

# --- Configuration for API Token Server ---
TOKEN_SERVER = "http://127.0.0.1:5000" # Your local token server URL

def fetch_schwab_token() -> Optional[str]:
    """
    Fetches the Schwab API access token from the local token server.
    This is a central utility function to be used by other data fetcher modules.
    """
    try:
        resp = requests.get(f"{TOKEN_SERVER}/token")
        resp.raise_for_status()
        token_data = resp.json()
        access_token = token_data.get("access_token")
        if not access_token:
            print("Error: 'access_token' key not found in token server response.")
            return None
        return access_token
    except requests.exceptions.RequestException as e:
        print(f"Error fetching Schwab token: {e}")
    except json.JSONDecodeError:
        print(f"Error decoding JSON from token server. Response: {resp.text}")
    return None

# --- Main block for standalone testing ---
if __name__ == "__main__":
    print("--- Testing Schwab Token Manager ---")
    token = fetch_schwab_token()
    if token:
        print("Successfully fetched an access token.")
        # print(f"Token (first 15 chars): {token[:15]}...") # Uncomment for more verbose testing
    else:
        print("Failed to fetch an access token.")
    print("--- Test Complete ---")

================================================================================
FILE_PATH: src\trade_guardian\infra\tickers.py
================================================================================
# src/trade_guardian/infra/tickers.py
from __future__ import annotations

from typing import List
import csv
import os
import re

_VALID = re.compile(r"^[A-Z0-9\.\-\_]+$")  # allow BRK.B, etc.

def load_tickers_csv(path: str) -> List[str]:
    """
    Load tickers from a csv where each line contains a symbol (or first column is symbol).
    Skips:
      - blank lines
      - comment lines starting with # or //
      - header-like tokens: SYMBOL, TICKER, SYM
      - invalid symbols
    """
    if not os.path.exists(path):
        raise FileNotFoundError(f"tickers.csv not found: {path}")

    out: List[str] = []
    with open(path, "r", newline="", encoding="utf-8-sig") as f:
        reader = csv.reader(f)
        for row in reader:
            if not row:
                continue
            sym = (row[0] or "").strip().upper()
            if not sym:
                continue
            if sym.startswith("#") or sym.startswith("//"):
                continue
            if sym in {"SYMBOL", "TICKER", "SYM"}:
                continue
            if not _VALID.match(sym):
                continue
            out.append(sym)

    # de-dup while keeping order
    seen = set()
    uniq: List[str] = []
    for s in out:
        if s not in seen:
            uniq.append(s)
            seen.add(s)
    return uniq


================================================================================
FILE_PATH: src\trade_guardian\infra\__init__.py
================================================================================



================================================================================
FILE_PATH: src\trade_guardian\strategies\auto.py
================================================================================
from __future__ import annotations

from typing import Optional, Tuple

from trade_guardian.domain.models import Context, Recommendation, ScanRow
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.strategies.base import Strategy
from trade_guardian.strategies.diagonal import DiagonalStrategy
from trade_guardian.strategies.long_gamma import LongGammaStrategy


class AutoStrategy(Strategy):
    """
    Strategy #5: Auto / Smart Router (Brain V5 - Structure First)
    
    Philosophy:
      - Structure Trumps Volatility: If the Term Structure offers a good edge (>0.20),
        we prioritize Diagonal spreads to harvest Theta/Vega differential, even if IV is low.
      - Low Vol Fallback: Only when structure is flat do we revert to Long Gamma (Straddle)
        to play for pure expansion.
    
    Routing Order:
      1. Backwardation -> LG (Defense)
      2. Edge > 0.20   -> DIAG (Attack Structure)
      3. HV < 30       -> LG (Attack Vol Floor)
      4. Default       -> LG
    """
    name = "auto"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy
        self.diagonal = DiagonalStrategy(cfg, policy)
        self.long_gamma = LongGammaStrategy(cfg, policy)

    def evaluate(self, ctx: Context) -> ScanRow:
        hv_rank = float(ctx.hv.hv_rank)
        tsf = ctx.tsf
        regime = str(tsf.get("regime", "FLAT"))
        edge_month = float(tsf.get("edge_month", 0.0))

        # --- å†³ç­–é€»è¾‘ (Brain V5) ---
        
        # 1. [å€’æŒ‚ä¿æŠ¤] Backwardation -> å¼ºåˆ¶ Long Gamma
        # è¿™ç§æ—¶å€™å–è¿‘ç«¯æ˜¯è‡ªæ€ï¼Œå¿…é¡»é˜²å®ˆ
        if regime == "BACKWARDATION":
            row = self.long_gamma.evaluate(ctx)
            row.tag = f"AUTO-LG"
            return row

        # 2. [ç»“æ„ä¼˜å…ˆ] åªè¦ Edge è¶³å¤Ÿå¥½ (> 0.20)ï¼Œä¼˜å…ˆåš Diagonal
        # å³ä½¿ HV å¾ˆä½ï¼Œä¼˜ç§€çš„ç»“æ„ä¹Ÿèƒ½æä¾›æ¯” Straddle æ›´å¥½çš„ç›ˆäºæ¯”
        # (åŒ…å«äº† > 0.35 çš„è¶…çº§ç»“æ„æƒ…å†µ)
        if edge_month >= 0.20:
            row_diag = self.diagonal.evaluate(ctx)
            # åªæœ‰æ„å»ºæˆåŠŸæ‰è¿”å›ï¼Œå¦åˆ™æ‰ä¸‹å»èµ°å…œåº•
            if row_diag and row_diag.meta and "long_strike" in row_diag.meta:
                row_diag.tag = f"AUTO-DIAG" 
                return row_diag

        # 3. [ä½æ³¢åšå¼ˆ] ç»“æ„å¹³åº¸ï¼Œä½†æ³¢åŠ¨ç‡åœ¨åœ°æ¿ -> å¼ºåˆ¶ Long Gamma
        # NVDA (Edge 0.16) ä¼šè½åˆ°è¿™é‡Œ
        if hv_rank < 30:
            row = self.long_gamma.evaluate(ctx)
            row.tag = f"AUTO-LG" 
            return row
        
        # 4. [é»˜è®¤å…œåº•] ç»“æ„å¹³å¦ä¸”æ³¢åŠ¨ç‡ä¸­ç­‰ -> Long Gamma
        row = self.long_gamma.evaluate(ctx)
        row.tag = f"AUTO-LG"
        return row

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        row = self.evaluate(ctx)
        if "DIAG" in row.tag:
            return self.diagonal.recommend(ctx, min_score, max_risk)
        else:
            return self.long_gamma.recommend(ctx, min_score, max_risk)

================================================================================
FILE_PATH: src\trade_guardian\strategies\base.py
================================================================================
from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Optional, Tuple

from trade_guardian.domain.models import Context, Recommendation, ScanRow


class Strategy(ABC):
    name: str = "base"

    @abstractmethod
    def evaluate(self, ctx: Context) -> ScanRow:
        raise NotImplementedError

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        """
        Optional: probe ranks to find a tradable short leg.
        For strategies that don't support probing, return (None, "-").
        """
        return None, "-"


================================================================================
FILE_PATH: src\trade_guardian\strategies\blueprint.py
================================================================================
from typing import Optional, Dict, Any
from trade_guardian.domain.models import Blueprint, OrderLeg

# [è¾…åŠ©å‡½æ•°] ä¿æŒä¸å˜
def _extract_greeks_for(chain: Dict[str, Any], side: str, exp: str, strike: float) -> Dict[str, float]:
    """å°è¯•ä»åŸå§‹æ•°æ®ä¸­æå– Delta/Gamma/Theta"""
    side_map_key = "callExpDateMap" if side.upper() == "CALL" else "putExpDateMap"
    exp_map = chain.get(side_map_key, {})
    
    target_key = None
    for k in exp_map.keys():
        if k.startswith(exp):
            target_key = k
            break
    
    if not target_key: return {}
    
    strikes = exp_map[target_key]
    quote = None
    strike_str = f"{strike:.1f}"
    if strike_str in strikes:
        quote = strikes[strike_str][0]
    else:
        for s_str, q_list in strikes.items():
            if abs(float(s_str) - strike) < 0.01:
                quote = q_list[0]
                break
    
    if not quote: return {}

    return {
        "delta": float(quote.get("delta", 0.0)),
        "gamma": float(quote.get("gamma", 0.0)),
        "theta": float(quote.get("theta", 0.0))
    }

def _extract_mid_for(chain: Dict[str, Any], side: str, exp: str, strike: float) -> Optional[float]:
    side_map = chain.get("callExpDateMap" if side == "CALL" else "putExpDateMap", {})
    for k in side_map:
        if k.startswith(exp):
            strikes = side_map[k]
            for s_key, quotes in strikes.items():
                if abs(float(s_key) - strike) < 0.01:
                    q = quotes[0]
                    if "mark" in q: return float(q["mark"])
                    if "bid" in q and "ask" in q: return (float(q["bid"]) + float(q["ask"])) / 2.0
    return None

# =========================================================
# æ ¸å¿ƒä¿®æ”¹ï¼šåºŸå¼ƒç§æœ‰ Blueprint ç±»ï¼Œç»Ÿä¸€è¿”å› domain.models.Blueprint
# =========================================================

def build_diagonal_blueprint(
    *,
    symbol: str,
    underlying: float,
    chain: Dict[str, Any],
    short_exp: str,
    long_exp: str,
    target_short_strike: float,
    target_long_strike: float,
    side: str = "CALL",
) -> Optional[Blueprint]:
    
    short_mid = _extract_mid_for(chain, side=side, exp=short_exp, strike=target_short_strike)
    long_mid = _extract_mid_for(chain, side=side, exp=long_exp, strike=target_long_strike)

    est_debit = 0.0
    error_msg = None
    note = ""
    width = abs(target_short_strike - target_long_strike)

    if isinstance(short_mid, (int, float)) and isinstance(long_mid, (int, float)):
        est_debit = float(long_mid - short_mid)
        
        # å®½å®¹çš„é£æ§é€»è¾‘ï¼šåªè®°å½• Noteï¼Œä¸æŠ¥é”™
        if est_debit > width:
            excess = est_debit - width
            note = f"âš ï¸ High Debit (Net Risk: -${excess:.2f}). Vega Play."
        else:
            note = f"Healthy PMCC Setup. Width={width:.2f}"
    else:
        # ä»·æ ¼ç¼ºå¤±
        error_msg = "Missing pricing data"

    # æ„é€ æ ‡å‡† Legs
    legs = [
        OrderLeg(symbol=symbol, action="BUY", ratio=1, exp=long_exp, strike=target_long_strike, type=side),
        OrderLeg(symbol=symbol, action="SELL", ratio=1, exp=short_exp, strike=target_short_strike, type=side)
    ]

    return Blueprint(
        symbol=symbol,
        strategy="DIAGONAL",
        legs=legs,
        est_debit=round(est_debit, 2),
        note=note,
        error=error_msg
    )

def build_straddle_blueprint(
    *,
    symbol: str,
    underlying: float,
    chain: Dict[str, Any],
    exp: str,
) -> Optional[Blueprint]:
    
    # æŸ¥æ‰¾ ATM Strike
    call_map = chain.get("callExpDateMap", {})
    target_key = None
    for k in call_map:
        if k.startswith(exp):
            target_key = k
            break
    if not target_key: return None
    
    strikes = sorted([float(s) for s in call_map[target_key].keys()])
    strike = min(strikes, key=lambda x: abs(x - underlying))
    
    call_mid = _extract_mid_for(chain, "CALL", exp, strike)
    put_mid = _extract_mid_for(chain, "PUT", exp, strike)
    
    est_debit = 0.0
    if call_mid and put_mid:
        est_debit = call_mid + put_mid
        
    legs = [
        OrderLeg(symbol=symbol, action="BUY", ratio=1, exp=exp, strike=strike, type="CALL"),
        OrderLeg(symbol=symbol, action="BUY", ratio=1, exp=exp, strike=strike, type="PUT")
    ]

    return Blueprint(
        symbol=symbol,
        strategy="STRADDLE",
        legs=legs,
        est_debit=round(est_debit, 2),
        note="ATM Straddle"
    )

def build_calendar_blueprint(
    *,
    symbol: str,
    underlying: float,
    chain: Dict[str, Any],
    short_exp: str,
    long_exp: str,
    prefer_side: str = "CALL"
) -> Optional[Blueprint]:
    
    call_map = chain.get("callExpDateMap", {})
    target_key = None
    for k in call_map:
        if k.startswith(short_exp):
            target_key = k
            break
    if not target_key: return None
    strikes = sorted([float(s) for s in call_map[target_key].keys()])
    strike = min(strikes, key=lambda x: abs(x - underlying))
    
    short_mid = _extract_mid_for(chain, prefer_side, short_exp, strike)
    long_mid = _extract_mid_for(chain, prefer_side, long_exp, strike)
    
    est_debit = 0.0
    if short_mid and long_mid:
        est_debit = long_mid - short_mid
        
    legs = [
        OrderLeg(symbol=symbol, action="BUY", ratio=1, exp=long_exp, strike=strike, type=prefer_side),
        OrderLeg(symbol=symbol, action="SELL", ratio=1, exp=short_exp, strike=strike, type=prefer_side)
    ]

    return Blueprint(
        symbol=symbol,
        strategy="CALENDAR",
        legs=legs,
        est_debit=round(est_debit, 2),
        note="ATM Calendar"
    )

================================================================================
FILE_PATH: src\trade_guardian\strategies\calendar.py
================================================================================
from __future__ import annotations

from typing import Optional, Tuple

from trade_guardian.domain.models import (
    Context,
    Recommendation,
    ScanRow,
    ScoreBreakdown,
    RiskBreakdown,
)
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.domain.scoring import Scoring, ScoringRules


class CalendarStrategy:
    name = "calendar"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy
        rules = ScoringRules(min_edge_short_base=float(cfg["rules"]["min_edge_short_base"]))
        self.scoring = Scoring(rules)

    def _tag(self, regime: str, curvature: str) -> str:
        t = "F" if regime == "FLAT" else ("C" if regime == "CONTANGO" else "B")
        if curvature == "SPIKY_FRONT":
            t += "S"
        return t

    @staticmethod
    def _clamp(x: float, lo: float, hi: float) -> float:
        return max(lo, min(hi, x))

    def _risk_score(
        self,
        ctx: Context,
        *,
        short_dte: int,
        short_gamma: float,
        rank0_dte: int,
        rank0_gamma: float,
        regime: str,
        curvature: str,
        squeeze_ratio: float,
    ) -> tuple[int, RiskBreakdown]:
        """
        Continuous & explainable risk model (0..100):

        base: start at 35 (not 50) so the system has headroom.
        dte: continuous decay with DTE (shorter => higher risk)
        gamma: continuous penalty based on gamma normalized vs front (or max)
        curvature: continuous penalty based on squeeze_ratio (only when SPIKY_FRONT)
        regime: small penalty (BACKWARDATION > CONTANGO > FLAT)
        """
        bd = RiskBreakdown(base=35)

        # -------- DTE penalty (continuous) --------
        # Target behavior (approx):
        #   dte ~ 1-3  => big penalty
        #   dte ~ 6    => medium
        #   dte ~ 10   => smaller
        #   dte >= 21  => near 0
        d = float(max(0, short_dte))
        # smooth curve: 0..~22 then clamp
        dte_pen = 26.0 / (1.0 + (d / 6.5) ** 1.25)  # d=6 => ~14-16 ; d=10 => ~9-11 ; d=20 => ~4
        # extra caution if front expiry is extremely close (weekly Friday effect / 0DTE clusters)
        front_pen = 0.0
        if rank0_dte <= 1:
            front_pen = 6.0
        elif rank0_dte <= 3:
            front_pen = 3.0

        bd.dte = int(round(self._clamp(dte_pen + front_pen, 0.0, 30.0)))

        # -------- Gamma penalty (continuous) --------
        # Normalize gamma: if we have rank0_gamma use it; otherwise fall back to max gamma in eligible term
        denom = rank0_gamma if rank0_gamma and rank0_gamma > 0 else 0.0
        if denom <= 0:
            # fallback: max gamma among term points we have
            try:
                denom = max(float(p.gamma) for p in ctx.term if p.gamma is not None)  # type: ignore
            except Exception:
                denom = 0.0

        g = float(short_gamma) if short_gamma is not None else 0.0
        g_norm = (g / denom) if denom > 0 else 0.0
        g_norm = self._clamp(g_norm, 0.0, 2.0)  # allow >1 if short gamma > front (rare but possible)

        # penalty curve: small when g_norm <=0.3, grows faster after 0.6
        # map roughly into 0..22
        gamma_pen = 22.0 * (g_norm ** 0.75)
        bd.gamma = int(round(self._clamp(gamma_pen, 0.0, 22.0)))

        # -------- Curvature penalty (continuous) --------
        # Use squeeze_ratio: (rank0_iv / base_iv) as a "front spike" severity.
        # Only penalize meaningfully if SPIKY_FRONT and squeeze is above mild threshold.
        curv_pen = 0.0
        if curvature == "SPIKY_FRONT":
            sr = float(squeeze_ratio) if squeeze_ratio is not None else 0.0
            # thresholded linear ramp:
            #  sr <= 1.10 => ~0
            #  sr 1.10..1.80 => 0..10
            curv_pen = 10.0 * self._clamp((sr - 1.10) / 0.70, 0.0, 1.0)

        # [FIX] Issue A: å­—æ®µåä¿®æ­£ä¸º curvature (åŸä¸º curv)
        bd.curvature = int(round(self._clamp(curv_pen, 0.0, 10.0)))

        # -------- Regime penalty (small, not dominating) --------
        # BACKWARDATION means front richer -> short leg can be more dangerous (bigger adverse gamma & gap risk).
        if regime == "BACKWARDATION":
            bd.regime = 4
        elif regime == "CONTANGO":
            bd.regime = 2
        else:
            bd.regime = 0

        # -------- Penalties slot (reserved) --------
        bd.penalties = 0

        # [FIX] Issue A: æ±‡æ€»è®¡ç®—ä¹ŸåŒæ­¥ä¿®æ­£
        total = bd.base + bd.dte + bd.gamma + bd.curvature + bd.regime + bd.penalties
        return int(self._clamp(float(total), 0.0, 100.0)), bd

    def evaluate(self, ctx: Context) -> ScanRow:
        tsf = ctx.tsf
        regime = str(tsf["regime"])
        curvature = str(tsf["curvature"])
        short_exp = str(tsf["short_exp"])
        short_dte = int(tsf["short_dte"])
        short_iv = float(tsf["short_iv"])
        base_iv = float(tsf["base_iv"])
        edge = float(tsf["edge"])
        squeeze_ratio = float(tsf.get("squeeze_ratio", 0.0))

        eligible = [p for p in ctx.term if p.dte >= self.policy.min_dte]
        if not eligible:
            # fallback: no eligible list, treat chosen short as the only reference
            rank0_dte = short_dte
            rank0_gamma = 0.0
            short_gamma = 0.0
        else:
            # rank0 refers to nearest *eligible* expiry (respect MIN_SHORT_DTE policy)
            rank0 = eligible[0]
            rank0_dte = int(rank0.dte)
            rank0_gamma = float(rank0.gamma) if rank0.gamma is not None else 0.0

            # find the chosen short point in eligible chain by matching exp or dte
            short_point = None
            for p in eligible:
                if str(p.exp) == short_exp:
                    short_point = p
                    break
            if short_point is None:
                # fallback by dte match
                for p in eligible:
                    if int(p.dte) == short_dte:
                        short_point = p
                        break
            short_gamma = float(short_point.gamma) if (short_point and short_point.gamma is not None) else 0.0

        score, bd = self.scoring.score_calendar(
            regime=regime,
            curvature=curvature,
            edge=edge,
            hv_rank=ctx.hv.hv_rank,
        )

        risk, rbd = self._risk_score(
            ctx,
            short_dte=short_dte,
            short_gamma=short_gamma,
            rank0_dte=rank0_dte,
            rank0_gamma=rank0_gamma,
            regime=regime,
            curvature=curvature,
            squeeze_ratio=squeeze_ratio,
        )

        tag = self._tag(regime, curvature)

        return ScanRow(
            symbol=ctx.symbol,
            price=float(ctx.price),
            short_exp=short_exp,
            short_dte=short_dte,
            short_iv=short_iv,
            base_iv=base_iv,
            edge=edge,
            hv_rank=float(ctx.hv.hv_rank),
            regime=regime,
            curvature=curvature,
            tag=tag,
            cal_score=int(score),
            short_risk=int(risk),
            score_breakdown=bd,
            risk_breakdown=rbd,
        )

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        """
        Probe ranks base..base+N-1 and return first rank with risk<=max_risk AND score>=min_score.
        If none, return (None, summary).
        """
        ranks = self.policy.probe_ranks()
        eligible = [p for p in ctx.term if p.dte >= self.policy.min_dte]
        if not eligible:
            return None, "-"

        # constants for risk computation
        regime = str(ctx.tsf["regime"])
        curvature = str(ctx.tsf["curvature"])
        squeeze_ratio = float(ctx.tsf.get("squeeze_ratio", 0.0))

        rank0 = eligible[0]
        rank0_dte = int(rank0.dte)
        rank0_gamma = float(rank0.gamma) if rank0.gamma is not None else 0.0

        best_attempt: Optional[Recommendation] = None
        best_summary = "-"

        for rk in ranks:
            if rk < 0 or rk >= len(eligible):
                continue

            p = eligible[rk]
            base_iv = float(ctx.tsf["base_iv"])
            edge = (float(p.iv) / base_iv) if base_iv > 0 else 0.0

            score, bd = self.scoring.score_calendar(
                regime=regime,
                curvature=curvature,
                edge=edge,
                hv_rank=ctx.hv.hv_rank,
            )

            short_gamma = float(p.gamma) if p.gamma is not None else 0.0
            risk, rbd = self._risk_score(
                ctx,
                short_dte=int(p.dte),
                short_gamma=short_gamma,
                rank0_dte=rank0_dte,
                rank0_gamma=rank0_gamma,
                regime=regime,
                curvature=curvature,
                squeeze_ratio=squeeze_ratio,
            )

            tag = self._tag(regime, curvature)

            # [FIX] Issue E: Correctly construct Recommendation object with meta dict
            if score >= min_score and risk <= max_risk:
                meta_data = {
                    "rank": int(rk),
                    "exp": str(p.exp),
                    "dte": int(p.dte),
                    "iv": float(p.iv),
                    "tag": tag,
                    "risk_breakdown": rbd,
                    "squeeze_ratio": squeeze_ratio
                }
                
                rec = Recommendation(
                    strategy="CALENDAR",
                    symbol=ctx.symbol,
                    action="OPEN",
                    rationale=f"Score {score} > {min_score}",
                    entry_price=ctx.price,
                    score=int(score),
                    conviction="MEDIUM",
                    meta=meta_data
                )
                summary = f"ok rk{rk} {p.exp} d{p.dte} e{edge:.2f} s{score} r{risk} {tag}"
                return rec, summary

            # Track best attempt
            if best_attempt is None or score > best_attempt.score:
                meta_data = {
                    "rank": int(rk),
                    "exp": str(p.exp),
                    "dte": int(p.dte),
                    "iv": float(p.iv),
                    "tag": tag,
                    "risk_breakdown": rbd,
                    "squeeze_ratio": squeeze_ratio
                }
                
                best_attempt = Recommendation(
                    strategy="CALENDAR",
                    symbol=ctx.symbol,
                    action="WATCH",
                    rationale="Best attempt",
                    entry_price=ctx.price,
                    score=int(score),
                    conviction="LOW",
                    meta=meta_data
                )
                best_summary = f"best rk{rk} {p.exp} d{p.dte} e{edge:.2f} s{score} r{risk} {tag}"

        return None, best_summary

================================================================================
FILE_PATH: src\trade_guardian\strategies\diagonal.py
================================================================================
from __future__ import annotations

from typing import Optional, Tuple, List, Dict, Any

from trade_guardian.domain.models import (
    Context,
    Recommendation,
    ScanRow,
    ScoreBreakdown,
    RiskBreakdown,
)
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.strategies.base import Strategy
from trade_guardian.strategies.blueprint import build_diagonal_blueprint


class DiagonalStrategy(Strategy):
    """
    Strategy #6: Tactical Diagonal (Lightweight)
    
    Logic:
      - Long Leg: Uses the 'Month Anchor' (~30-45 DTE) found by Curve Analysis.
      - Short Leg: Uses the 'Short Anchor' (1-10 DTE).
      - Strikes: 
          Long @ ATM/ITM (High Vega, Low Delta Cost)
          Short @ OTM (Income)
      - Goal: Capture Term Structure Edge without the heavy capital of PMCC LEAPS.
    """
    name = "diagonal"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy

    @staticmethod
    def _clamp(x: float, lo: float, hi: float) -> float:
        return max(lo, min(hi, x))
    
    def _find_strikes(self, ctx: Context) -> Tuple[Optional[float], Optional[str], Optional[float]]:
        """
        å¯»æ‰¾è½»é‡çº§ Diagonal çš„è¡Œæƒä»·ç»“æ„ï¼š
        Long: Month Exp @ First ITM or ATM
        Short: Short Exp @ First OTM
        """
        price = ctx.price
        chain = ctx.raw_chain
        tsf = ctx.tsf
        
        # 1. é”å®šåˆ°æœŸæ—¥ (ç›´æ¥å¤ç”¨ Curve ç®—æ³•çš„ç»“æœ)
        short_exp = tsf.get("short_exp")
        long_exp = tsf.get("month_exp") # ä½¿ç”¨ä¼˜åŒ–è¿‡çš„ 35DTE é”šç‚¹ï¼Œä¸å†æ˜¯ LEAPS

        if not short_exp or not long_exp:
            return None, None, None
        
        # 2. è·å– Strike Map
        call_map = chain.get("callExpDateMap", {})
        
        # è¾…åŠ©å‡½æ•°ï¼šæ‰¾ç‰¹å®šæ—¥æœŸçš„ strikes
        def get_strikes_for_exp(exp_date_str):
            # æ¨¡ç³ŠåŒ¹é…æ—¥æœŸå‰ç¼€
            for k, v in call_map.items():
                if k.startswith(exp_date_str):
                    return sorted([float(s) for s in v.keys()])
            return []

        short_strikes = get_strikes_for_exp(short_exp)
        long_strikes = get_strikes_for_exp(long_exp)

        if not short_strikes or not long_strikes:
            return None, None, None

        # 3. é€‰æ‹©è¡Œæƒä»· (Tactical Light Setup)
        
        # Short Leg: å–å‡ºç¬¬ä¸€æ¡£è™šå€¼ (OTM)
        # é€»è¾‘ï¼šæ‰¾ > Price çš„æœ€å° Strike
        short_strike = next((s for s in short_strikes if s > price * 1.005), None)
        
        # Long Leg: ä¹°å…¥ç¬¬ä¸€æ¡£å®å€¼ (ITM) æˆ– å¹³å€¼ (ATM)
        # é€»è¾‘ï¼šæ‰¾ <= Price çš„æœ€å¤§ Strike
        # è¿™é‡Œç”¨ <= Price ç¡®ä¿æ˜¯ ITM æˆ– ATMï¼Œæ¯” OTM çš„ Short è…¿ä½ï¼Œæ„æˆæ­£å‘å¯¹è§’
        long_strike_candidates = [s for s in long_strikes if s <= price]
        long_strike = long_strike_candidates[-1] if long_strike_candidates else long_strikes[0]

        # [ä¿åº•é€»è¾‘] ç¡®ä¿ Long Strike < Short Strike (Call Diagonal è§„åˆ™)
        if long_strike >= short_strike:
            # å°è¯•ä¸‹ç§» Long Strike
            lower = [s for s in long_strikes if s < short_strike]
            if lower:
                long_strike = lower[-1]
            else:
                # å®åœ¨æ²¡ç©ºé—´ (æ¯”å¦‚è‚¡ä»·æ­£å¥½å¡åœ¨ä¸¤ä¸ª Strike ä¸­é—´)ï¼Œåš Calendar (åŒä»·)
                # Calendar ä¹Ÿæ˜¯ä¸€ç§ç‰¹æ®Šçš„ Diagonal
                long_strike = short_strike

        return short_strike, long_exp, long_strike

    def evaluate(self, ctx: Context) -> ScanRow:
        tsf = ctx.tsf
        hv_rank = float(ctx.hv.hv_rank)
        price = float(ctx.price)
        
        # åŸºç¡€æ•°æ®
        short_iv = float(tsf.get("short_iv", 0))
        edge_month = float(tsf.get("edge_month", 0)) # è¿™æ˜¯å…³é”® Edge
        
        # å¯»æ‰¾ç»“æ„
        short_strike, long_exp, long_strike = self._find_strikes(ctx)
        
        # --- Scoring ---
        bd = ScoreBreakdown(base=50)
        
        # Edge é©±åŠ¨ (æƒé‡æœ€å¤§)
        bd.edge = int(self._clamp(edge_month * 80, -20, 40))
        
        # ç»“æ„åˆ†
        if short_strike and long_strike:
            bd.base += 10 # æˆåŠŸæ„å»ºç»“æ„å¥–åŠ±
        else:
            bd.penalties = -999 # æ„å»ºå¤±è´¥

        # è´Ÿ Edge æƒ©ç½š (Backwardation ä¸é€‚åˆåš Diagonal)
        if edge_month < 0:
            bd.regime = -30

        score = bd.base + bd.regime + bd.edge + bd.hv + bd.curvature + bd.penalties
        
        # --- Risk ---
        # å¤ç”¨ Long Gamma çš„é£é™©é€»è¾‘ï¼Œå› ä¸ºè½»é‡çº§ Diagonal é£é™©ç‰¹å¾ç±»ä¼¼
        risk = 30
        if edge_month < 0: risk += 40
        
        tag = "DIAG"
        if edge_month > 0.15: tag += "+"

        row = ScanRow(
            symbol=ctx.symbol,
            price=price,
            short_exp=str(tsf.get("short_exp")),
            short_dte=int(tsf.get("short_dte", 0)),
            short_iv=short_iv,
            base_iv=float(tsf.get("month_iv", 0)),
            edge=edge_month,
            hv_rank=hv_rank,
            regime=str(tsf.get("regime")),
            curvature=str(tsf.get("curvature")),
            tag=tag,
            cal_score=int(self._clamp(float(score), 0, 100)),
            short_risk=int(self._clamp(float(risk), 0, 100)),
            score_breakdown=bd,
            risk_breakdown=RiskBreakdown(base=risk),
        )

        # æ„å»ºè“å›¾ (åœ¨æ­¤å¤„ç”Ÿæˆï¼Œæ–¹ä¾¿ Orchestrator ç›´æ¥å–ç”¨)
        if short_strike and long_strike:
            bp = build_diagonal_blueprint(
                symbol=ctx.symbol,
                underlying=price,
                chain=ctx.raw_chain,
                short_exp=str(tsf.get("short_exp")),
                long_exp=long_exp,
                target_short_strike=short_strike,
                target_long_strike=long_strike,
                side="CALL"
            )
            row.blueprint = bp
            
            # Meta æ•°æ®ç”¨äºå‰ç«¯æ˜¾ç¤º
            # Meta æ•°æ®ç”¨äºå‰ç«¯æ˜¾ç¤º
        row.meta = {
            "strategy": "diagonal",
            "short_strike": short_strike,
            "long_exp": long_exp,
            "long_strike": long_strike,
            "est_gamma": float(ctx.metrics.gamma) if ctx.metrics else 0.0,
            
            # å®Œæ•´é€ä¼  TSF æ•°æ®
            "micro_exp": tsf.get("micro_exp"),
            "micro_dte": tsf.get("micro_dte"),
            "micro_iv": tsf.get("micro_iv"),
            "edge_micro": float(tsf.get("edge_micro", 0)), # <--- è¡¥ä¸Šäº†ï¼
            
            "month_exp": tsf.get("month_exp"),
            "month_dte": tsf.get("month_dte"),
            "month_iv": tsf.get("month_iv"),
            "edge_month": edge_month,
        }
            
        return row

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        row = self.evaluate(ctx)
        
        if row.cal_score < min_score:
            return None, "Score too low"
            
        if not row.blueprint:
            return None, "Structure build failed"

        rec = Recommendation(
            strategy="DIAGONAL",
            symbol=ctx.symbol,
            action="OPEN DIAGONAL",
            rationale=f"Tactical Diagonal: Edge {row.edge:.2f}",
            entry_price=ctx.price,
            score=row.cal_score,
            conviction="HIGH",
            meta=row.meta
        )
        return rec, "OK"

================================================================================
FILE_PATH: src\trade_guardian\strategies\hv_calendar.py
================================================================================
from __future__ import annotations

from typing import Optional, Tuple

from trade_guardian.domain.models import Context, Recommendation, ScanRow
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.domain.scoring import Scoring, ScoringRules

# å¤ç”¨ calendar çš„é£é™©è¿ç»­æ¨¡å‹ + explainï¼ˆrisk_breakdownï¼‰
from trade_guardian.strategies.calendar import CalendarStrategy


class HVCalendarStrategy(CalendarStrategy):
    """
    Strategy #2: HV-aware calendar
      - score: calendar score + hv adjust (å†™å…¥ score_breakdown.hv)
      - risk : å¤ç”¨ CalendarStrategy._risk_scoreï¼ˆä½ å½“å‰ç‰ˆæœ¬éœ€è¦ gamma/squeeze ç­‰è¾“å…¥ï¼‰
    """
    name = "hv_calendar"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        super().__init__(cfg, policy)

        rules = ScoringRules(min_edge_short_base=float(cfg["rules"]["min_edge_short_base"]))
        self.scoring = Scoring(rules)

        hv_cfg = ((cfg.get("strategies", {}) or {}).get("hv_calendar", {}) or {})
        hv_rules = (hv_cfg.get("hv_rules", {}) or {})

        self.hv_low_rank = float(hv_rules.get("hv_low_rank", 20.0))
        self.hv_mid_rank = float(hv_rules.get("hv_mid_rank", 50.0))
        self.hv_high_rank = float(hv_rules.get("hv_high_rank", 70.0))

        self.hv_low_bonus = int(hv_rules.get("hv_low_bonus", 10))
        self.hv_mid_bonus = int(hv_rules.get("hv_mid_bonus", 4))
        self.hv_high_penalty = int(hv_rules.get("hv_high_penalty", -4))
        self.hv_extreme_penalty = int(hv_rules.get("hv_extreme_penalty", -10))

    def _hv_adjust(self, hv_rank: float) -> int:
        if hv_rank <= self.hv_low_rank:
            return self.hv_low_bonus
        if hv_rank <= self.hv_mid_rank:
            return self.hv_mid_bonus
        if hv_rank <= self.hv_high_rank:
            return 0
        if hv_rank <= 90.0:
            return self.hv_high_penalty
        return self.hv_extreme_penalty

    @staticmethod
    def _find_point_gamma(ctx: Context, exp: str, dte: int) -> float:
        """
        Best-effort: åœ¨ ctx.term é‡ŒæŒ‰ exp+dte æ‰¾å¯¹åº”ç‚¹çš„ gammaã€‚
        æ‰¾ä¸åˆ°å°±é€€åŒ–ä¸º 0.0ï¼ˆé£é™©æ¨¡å‹ä»å¯è·‘ï¼Œåªæ˜¯ gamma åˆ†é¡¹ä¼šåå°/ä¸º 0ï¼‰ã€‚
        """
        for p in ctx.term:
            if str(p.exp) == str(exp) and int(p.dte) == int(dte):
                try:
                    return float(getattr(p, "gamma", 0.0) or 0.0)
                except Exception:
                    return 0.0
        return 0.0

    @staticmethod
    def _best_effort_squeeze_ratio(ctx: Context) -> float:
        """
        squeeze_ratio åœ¨ä½ é¡¹ç›®é‡Œå¯èƒ½ï¼š
          - å·²ç»ç”± TSFeatureBuilder å†™å…¥ ctx.tsf["squeeze_ratio"]
          - æˆ–è€…æ²¡æœ‰ï¼ˆæ—©å…ˆè¾“å‡ºæ›¾å‡ºç° N/Aï¼‰
        è¿™é‡Œç»Ÿä¸€è¿”å› floatï¼Œç¼ºå¤±å°± 0.0ã€‚
        """
        try:
            v = ctx.tsf.get("squeeze_ratio", 0.0)  # type: ignore
            return float(v) if v is not None else 0.0
        except Exception:
            return 0.0

    def evaluate(self, ctx: Context) -> ScanRow:
        tsf = ctx.tsf
        regime = str(tsf["regime"])
        curvature = str(tsf["curvature"])
        short_exp = str(tsf["short_exp"])
        short_dte = int(tsf["short_dte"])
        short_iv = float(tsf["short_iv"])
        base_iv = float(tsf["base_iv"])
        edge = float(tsf["edge"])
        hv_rank = float(ctx.hv.hv_rank)

        # ---------------- score (HV-aware) ----------------
        score, bd = self.scoring.score_calendar(
            regime=regime,
            curvature=curvature,
            edge=edge,
            hv_rank=hv_rank,
        )
        hv_adj = self._hv_adjust(hv_rank)
        bd.hv = int(hv_adj)
        score = int(score + hv_adj)

        # ---------------- risk (reuse calendar continuous model) ----------------
        eligible = [p for p in ctx.term if int(p.dte) >= int(self.policy.min_dte)]
        rank0_dte = int(eligible[0].dte) if eligible else int(short_dte)
        rank0_gamma = float(getattr(eligible[0], "gamma", 0.0) or 0.0) if eligible else 0.0

        short_gamma = self._find_point_gamma(ctx, exp=short_exp, dte=short_dte)
        squeeze_ratio = self._best_effort_squeeze_ratio(ctx)

        # âœ… å…³é”®ï¼šä¸¥æ ¼æŒ‰ä½ å½“å‰ calendar.py çš„ keyword-only å‚æ•°ç­¾åè°ƒç”¨
        risk, rbd = self._risk_score(
            ctx,
            short_dte=short_dte,
            short_gamma=short_gamma,
            rank0_dte=rank0_dte,
            rank0_gamma=rank0_gamma,
            regime=regime,
            curvature=curvature,
            squeeze_ratio=squeeze_ratio,
        )

        tag = self._tag(regime, curvature)

        row = ScanRow(
            symbol=ctx.symbol,
            price=float(ctx.price),
            short_exp=short_exp,
            short_dte=short_dte,
            short_iv=short_iv,
            base_iv=base_iv,
            edge=edge,
            hv_rank=hv_rank,
            regime=regime,
            curvature=curvature,
            tag=tag,
            cal_score=int(score),
            short_risk=int(risk),
            score_breakdown=bd,
        )

        # renderer ç”¨ getattrï¼Œæ‰€ä»¥æˆ‘ä»¬ç”¨ setattr æŒ‚ä¸Š explain å­—æ®µ
        setattr(row, "risk_breakdown", rbd)
        setattr(row, "squeeze_ratio", squeeze_ratio)

        return row

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        ranks = self.policy.probe_ranks()
        eligible = [p for p in ctx.term if int(p.dte) >= int(self.policy.min_dte)]
        if not eligible:
            return None, "-"

        hv_rank = float(ctx.hv.hv_rank)
        hv_adj = self._hv_adjust(hv_rank)
        squeeze_ratio = self._best_effort_squeeze_ratio(ctx)

        rank0_dte = int(eligible[0].dte)
        rank0_gamma = float(getattr(eligible[0], "gamma", 0.0) or 0.0)

        best: Optional[Recommendation] = None
        best_summary = "-"

        for rk in ranks:
            if rk < 0 or rk >= len(eligible):
                continue

            p = eligible[rk]

            base_iv = float(ctx.tsf["base_iv"])
            edge = (float(p.iv) / base_iv) if base_iv > 0 else 0.0

            regime = str(ctx.tsf["regime"])
            curvature = str(ctx.tsf["curvature"])

            score, bd = self.scoring.score_calendar(regime=regime, curvature=curvature, edge=edge, hv_rank=hv_rank)
            bd.hv = int(hv_adj)
            score = int(score + hv_adj)

            short_gamma = float(getattr(p, "gamma", 0.0) or 0.0)

            risk, rbd = self._risk_score(
                ctx,
                short_dte=int(p.dte),
                short_gamma=short_gamma,
                rank0_dte=rank0_dte,
                rank0_gamma=rank0_gamma,
                regime=regime,
                curvature=curvature,
                squeeze_ratio=squeeze_ratio,
            )

            tag = self._tag(regime, curvature)

            if score >= min_score and risk <= max_risk:
                rec = Recommendation(
                    rec_rank=int(rk),
                    rec_exp=str(p.exp),
                    rec_dte=int(p.dte),
                    rec_iv=float(p.iv),
                    rec_edge=float(edge),
                    rec_score=int(score),
                    rec_risk=int(risk),
                    rec_tag=tag,
                    rec_breakdown=bd,
                )
                setattr(rec, "risk_breakdown", rbd)
                setattr(rec, "squeeze_ratio", squeeze_ratio)

                summary = f"ok rk{rk} {p.exp} d{p.dte} e{edge:.2f} s{score} r{risk} {tag}"
                return rec, summary

            if best is None or score > best.rec_score:
                best = Recommendation(
                    rec_rank=int(rk),
                    rec_exp=str(p.exp),
                    rec_dte=int(p.dte),
                    rec_iv=float(p.iv),
                    rec_edge=float(edge),
                    rec_score=int(score),
                    rec_risk=int(risk),
                    rec_tag=tag,
                    rec_breakdown=bd,
                )
                setattr(best, "risk_breakdown", rbd)
                setattr(best, "squeeze_ratio", squeeze_ratio)
                best_summary = f"best rk{rk} {p.exp} d{p.dte} e{edge:.2f} s{score} r{risk} {tag}"

        return None, best_summary


================================================================================
FILE_PATH: src\trade_guardian\strategies\long_gamma.py
================================================================================
from __future__ import annotations
from trade_guardian.domain.models import Context, ScanRow, ScoreBreakdown, RiskBreakdown
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.strategies.base import Strategy

class LongGammaStrategy(Strategy):
    name = "long_gamma"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy

    @staticmethod
    def _clamp(x: float, lo: float, hi: float) -> float:
        return max(lo, min(hi, x))

    def evaluate(self, ctx: Context) -> ScanRow:
        tsf = ctx.tsf
        symbol = ctx.symbol
        
        # 1. æå–ä¸‰ç‚¹æ•°æ®
        short_iv = float(tsf.get("short_iv", 0.0))
        edge_micro = float(tsf.get("edge_micro", 0.0))
        edge_month = float(tsf.get("edge_month", 0.0))
        
        # 2. è¯„åˆ†é€»è¾‘ (åŒå› å­é©±åŠ¨)
        score = 60
        # Micro Edge: çŸ­æœŸå¿…é¡»ä¾¿å®œ (æƒé‡ 40%)
        score += int(self._clamp(edge_micro * 40, -20, 20))
        # Month Edge: ç»“æ„å¿…é¡»æ”¯æ’‘ (æƒé‡ 60%)
        score += int(self._clamp(edge_month * 60, -20, 30))
        
        score = self._clamp(score, 0, 100)

        # 3. æ„é€  Gate ä¿¡å· (ä¸‰æ®µå¼é£æ§)
        gate = "WAIT"
        dna = "QUIET" # ç¨å Orchestrator ä¼šæ›´æ–°åŠ¨èƒ½
        
        # åŸºç¡€é—¨æ§›
        if score > 75 and edge_micro > 0.05 and edge_month > 0.10:
            gate = "READY" # ä»‹äº WAIT å’Œ EXEC ä¹‹é—´ï¼Œç­‰å¾…åŠ¨èƒ½è§¦å‘
        
        if symbol in ["TSLL", "TQQQ", "SOXL", "ONDS", "SMCI", "IWM"]:
            gate = "FORBID"

        # 4. æ„é€  Tag
        tag = "LG"
        if edge_micro > 0.15: tag += "-M" # Micro æå¥½
        if edge_month > 0.30: tag += "-K" # Month æå¥½ (K=Structure)

        # 5. è¿”å› ScanRow (meta æºå¸¦å…¨é‡åŒåŸºå‡†æ•°æ®)
        bd = ScoreBreakdown(base=60) 
        rbd = RiskBreakdown(base=20)
        
        row = ScanRow(
            symbol=symbol,
            price=float(ctx.price),
            short_exp=tsf.get("short_exp", ""),
            short_dte=int(tsf.get("short_dte", 0)),
            short_iv=short_iv,
            base_iv=tsf.get("month_iv", 0.0), # å…¼å®¹è€å­—æ®µ
            edge=edge_month,                 # å…¼å®¹è€å­—æ®µ
            hv_rank=50.0,
            regime="NORMAL",
            curvature="FLAT",
            tag=tag,
            cal_score=int(score),
            short_risk=20,
            score_breakdown=bd,
            risk_breakdown=rbd,
        )
        
        # å°†åŒåŸºå‡†æ”¾å…¥ metaï¼Œä¾› UI æ¸²æŸ“
        row.meta = {
            "micro_exp": tsf.get("micro_exp"),
            "micro_dte": tsf.get("micro_dte"),
            "micro_iv": tsf.get("micro_iv"),
            "edge_micro": edge_micro,
            
            "month_exp": tsf.get("month_exp"),
            "month_dte": tsf.get("month_dte"),
            "month_iv": tsf.get("month_iv"),
            "edge_month": edge_month,
            
            "est_gamma": float(ctx.metrics.gamma) * 2.0 if ctx.metrics else 0.0,
            "strike": round(float(ctx.price), 1)
        }
        return row

================================================================================
FILE_PATH: src\trade_guardian\strategies\placeholder.py
================================================================================
from __future__ import annotations

from trade_guardian.domain.models import Context, ScanRow, ScoreBreakdown
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.strategies.base import Strategy


class PlaceholderStrategy(Strategy):
    """
    Strategy #2/#3 placeholder.
    Exists to prove the framework: registry, CLI, orchestrator wiring.
    Not intended for trading logic.
    """
    name = "placeholder"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy

    def evaluate(self, ctx: Context) -> ScanRow:
        bd = ScoreBreakdown(base=0)
        return ScanRow(
            symbol=ctx.symbol,
            price=float(ctx.price),
            short_exp=ctx.tsf.get("short_exp", ""),
            short_dte=int(ctx.tsf.get("short_dte", 0)),
            short_iv=float(ctx.tsf.get("short_iv", 0.0)),
            base_iv=float(ctx.tsf.get("base_iv", 0.0)),
            edge=float(ctx.tsf.get("edge", 0.0)),
            hv_rank=float(ctx.hv.hv_rank),
            regime=str(ctx.tsf.get("regime", "FLAT")),
            curvature=str(ctx.tsf.get("curvature", "NORMAL")),
            tag="NA",
            cal_score=0,
            short_risk=100,
            score_breakdown=bd,
        )


================================================================================
FILE_PATH: src\trade_guardian\strategies\strategy2_stub.py
================================================================================
from typing import Optional, Tuple

from trade_guardian.domain.models import Context, ScanRow, Recommendation, ScoreBreakdown


class Strategy2Stub:
    """
    Reserved for strategy #2. Framework is in place.
    This stub intentionally does not implement real logic yet.
    """
    name = "strategy2"

    def __init__(self, cfg: dict):
        self.cfg = cfg

    def evaluate(self, ctx: Context) -> ScanRow:
        raise NotImplementedError("strategy2 is not implemented yet.")

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        return None, "-"


================================================================================
FILE_PATH: src\trade_guardian\strategies\__init__.py
================================================================================


================================================================================
FILE_PATH: src\trade_guardian.egg-info\dependency_links.txt
================================================================================



================================================================================
FILE_PATH: src\trade_guardian.egg-info\requires.txt
================================================================================
requests
pandas
numpy
tabulate
colorama


================================================================================
FILE_PATH: src\trade_guardian.egg-info\SOURCES.txt
================================================================================
pyproject.toml
src/trade_guardian/__init__.py
src/trade_guardian.egg-info/PKG-INFO
src/trade_guardian.egg-info/SOURCES.txt
src/trade_guardian.egg-info/dependency_links.txt
src/trade_guardian.egg-info/requires.txt
src/trade_guardian.egg-info/top_level.txt
src/trade_guardian/app/__init__.py
src/trade_guardian/app/cli.py
src/trade_guardian/app/orchestrator.py
src/trade_guardian/app/renderer.py
src/trade_guardian/domain/__init__.py
src/trade_guardian/domain/features.py
src/trade_guardian/domain/hv.py
src/trade_guardian/domain/models.py
src/trade_guardian/domain/policy.py
src/trade_guardian/domain/registry.py
src/trade_guardian/domain/scoring.py
src/trade_guardian/infra/__init__.py
src/trade_guardian/infra/cache.py
src/trade_guardian/infra/config.py
src/trade_guardian/infra/rate_limit.py
src/trade_guardian/infra/schwab_client.py
src/trade_guardian/infra/schwab_token_manager.py
src/trade_guardian/infra/tickers.py
src/trade_guardian/strategies/__init__.py
src/trade_guardian/strategies/base.py
src/trade_guardian/strategies/calendar.py
src/trade_guardian/strategies/placeholder.py
src/trade_guardian/strategies/strategy2_stub.py

================================================================================
FILE_PATH: src\trade_guardian.egg-info\top_level.txt
================================================================================
trade_guardian

