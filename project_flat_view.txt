PROJECT_ROOT: D:\workspace\trade_guardian
GENERATED_BY: merge_project.py
================================================================================


================================================================================
FILE_PATH: build_context.txt
================================================================================
create_tg_db.py:def init_db():
history_viewer.py:    def __init__(self, db_path="db/trade_guardian.db"):
history_viewer.py:    def get_latest_radar(self, symbol=None, limit=20):
history_viewer.py:    def _process_logic(self, df, latest_id, conn):
history_viewer.py:    def display(self, symbol=None):
merge_project.py:def is_text_file(file_path):
merge_project.py:def merge_project_files():
src\trade_guardian\app\cli.py:    DEFAULT_CONFIG,
src\trade_guardian\app\cli.py:def main():
src\trade_guardian\app\cli.py:    p_init.add_argument("--path", type=str, default=None, help="Output path (default: ./config/config.json)")
src\trade_guardian\app\cli.py:    p_scan.add_argument("--config", type=str, default=None, help="Config path (default: ./config/config.json)")
src\trade_guardian\app\cli.py:    p_scan.add_argument("--strategy", type=str, default="auto", help="Strategy name (default: auto)")
src\trade_guardian\app\cli.py:    p_scan.add_argument("--days", type=int, default=600)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--csv", type=str, default=None, help="Tickers csv path")
src\trade_guardian\app\cli.py:    p_scan.add_argument("--min-score", type=int, default=60)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--max-risk", type=int, default=70)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--limit", type=int, default=0)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--top", type=int, default=None, help="Only show top N sorted blueprints")
src\trade_guardian\app\cli.py:    p_scan.add_argument("--short-rank", type=int, default=None)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--min-short-dte", type=int, default=None)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--max-probe-rank", type=int, default=None)
src\trade_guardian\app\cli.py:        write_config_template(out, DEFAULT_CONFIG, overwrite=args.force)
src\trade_guardian\app\cli.py:        autogen_default = bool(DEFAULT_CONFIG.get("runtime", {}).get("autogen_config_if_missing", True))
src\trade_guardian\app\cli.py:        autogen = autogen_default
src\trade_guardian\app\cli.py:            write_config_template(cfg_path, DEFAULT_CONFIG, overwrite=False)
src\trade_guardian\app\cli.py:        cfg = load_config(cfg_path, DEFAULT_CONFIG)
src\trade_guardian\app\orchestrator.py:    def __init__(self, client, cfg: dict, policy, strategy=None):
src\trade_guardian\app\orchestrator.py:    def _get_universe(self) -> List[str]:
src\trade_guardian\app\orchestrator.py:    def scanlist(self, strategy_name: str = "auto", days: int = 600, 
src\trade_guardian\app\orchestrator.py:                ctx = self.client.build_context(ticker, days=days)
src\trade_guardian\app\orchestrator.py:    def _get_gate_status(self, row: ScanRow, bp: Optional[Blueprint], dna_type: str) -> str:
src\trade_guardian\app\orchestrator.py:    def _print_enhanced_blueprint(self, bp: Blueprint, row: ScanRow, dna: str):
src\trade_guardian\app\orchestrator.py:    def _get_temp(self, dna):
src\trade_guardian\app\orchestrator.py:    def plan(self, ctx: Context, row: ScanRow) -> Optional[Blueprint]:
src\trade_guardian\app\orchestrator.py:    def _load_strategy(self, name: str):
src\trade_guardian\app\persistence.py:    def __init__(self, db_path: str = None):
src\trade_guardian\app\persistence.py:    def save_scan_session(self, 
src\trade_guardian\app\persistence.py:    def check_iv_spikes(self, current_batch_id: int, threshold: float = 3.0) -> List[Tuple[str, float]]:
src\trade_guardian\app\persistence.py:    def get_latest_drift_1h(self, symbol: str) -> float:
src\trade_guardian\app\renderer.py:    def __init__(self, cfg=None, policy=None, hv_cache_path: Optional[str] = None):
src\trade_guardian\app\renderer.py:    def _sanitize_int(self, value: Any, default: int = 0) -> int:
src\trade_guardian\app\renderer.py:            if isinstance(value, list): return self._sanitize_int(value[0], default) if value else default
src\trade_guardian\app\renderer.py:            return default
src\trade_guardian\app\renderer.py:            return default
src\trade_guardian\app\renderer.py:    def render(self, 
src\trade_guardian\app\renderer.py:    def render_diagnostics(self, strict: List[ScanRow], **kwargs):
src\trade_guardian\app\renderer.py:    def _print_table(self, title: str, rows: List[ScanRow]):
src\trade_guardian\app\renderer.py:    def _print_details(self, title: str, rows: List[ScanRow]):
src\trade_guardian\app\renderer.py:    def _print_blueprints(self, title: str, rows: List[ScanRow]):
src\trade_guardian\domain\features.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\domain\features.py:    def _eligible_points(term: List[TermPoint], min_dte: int) -> List[TermPoint]:
src\trade_guardian\domain\features.py:    def _baseline_iv(term: List[TermPoint], fallback_iv: float) -> float:
src\trade_guardian\domain\features.py:    def build(self, term: List[TermPoint], hv: HVInfo, rank: int) -> Dict[str, object]:
src\trade_guardian\domain\hv.py:    def __init__(self, client: SchwabClient, cache: JsonDailyCache):
src\trade_guardian\domain\hv.py:    def get_hv(self, symbol: str) -> HVInfo:
src\trade_guardian\domain\models.py:    meta: Dict[str, Any] = field(default_factory=dict)
src\trade_guardian\domain\models.py:    legs: List[OrderLeg] = field(default_factory=list)
src\trade_guardian\domain\policy.py:    def probe_ranks(self) -> List[int]:
src\trade_guardian\domain\registry.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\domain\registry.py:    def get(self, name: str):
src\trade_guardian\domain\registry.py:        if n in ("auto", "smart", "default"):
src\trade_guardian\domain\scoring.py:    def __init__(self, rules: ScoringRules):
src\trade_guardian\domain\scoring.py:    def _hv_points(self, hv_rank: float) -> int:
src\trade_guardian\domain\scoring.py:    def score_calendar(self, regime: str, curvature: str, edge: float, hv_rank: float) -> tuple[int, ScoreBreakdown]:
src\trade_guardian\infra\cache.py:    def __init__(self, path: str):
src\trade_guardian\infra\cache.py:    def _load(self):
src\trade_guardian\infra\cache.py:    def _save(self):
src\trade_guardian\infra\cache.py:    def _today() -> str:
src\trade_guardian\infra\cache.py:    def get(self, key: str) -> Optional[dict]:
src\trade_guardian\infra\cache.py:    def set(self, key: str, value: dict) -> None:
src\trade_guardian\infra\cache.py:        self._data.setdefault("items", {})[key] = value
src\trade_guardian\infra\config.py:DEFAULT_CONFIG: Dict[str, Any] = {
src\trade_guardian\infra\config.py:def _deep_merge(a: Dict[str, Any], b: Dict[str, Any]) -> Dict[str, Any]:
src\trade_guardian\infra\config.py:def load_config(path: str, default_cfg: Dict[str, Any]) -> Dict[str, Any]:
src\trade_guardian\infra\config.py:        return dict(default_cfg)
src\trade_guardian\infra\config.py:        return dict(default_cfg)
src\trade_guardian\infra\config.py:    return _deep_merge(default_cfg, user_cfg)
src\trade_guardian\infra\config.py:def write_config_template(path: str, default_cfg: Dict[str, Any], overwrite: bool = False) -> None:
src\trade_guardian\infra\config.py:        json.dump(default_cfg, f, indent=2, ensure_ascii=False)
src\trade_guardian\infra\config.py:def merge_config_paths(cfg: Dict[str, Any], root: str, csv_override: Optional[str]) -> Dict[str, Any]:
src\trade_guardian\infra\config.py:    out.setdefault("paths", {})
src\trade_guardian\infra\config.py:def _resolve_probe_count(pcfg: Dict[str, Any], base_rank: int) -> int:
src\trade_guardian\infra\config.py:def policy_from_cfg_and_cli(cfg: Dict[str, Any], args) -> ShortLegPolicy:
src\trade_guardian\infra\rate_limit.py:    def __init__(self, throttle_sec: float):
src\trade_guardian\infra\rate_limit.py:    def sleep(self):
src\trade_guardian\infra\retry_option_chain.py:def _utc_now_iso() -> str:
src\trade_guardian\infra\retry_option_chain.py:def _safe_snippet(s: Any, max_len: int = 400) -> str:
src\trade_guardian\infra\retry_option_chain.py:def classify_empty_response(
src\trade_guardian\infra\retry_option_chain.py:def _write_jsonl(path: Path, record: Dict[str, Any]) -> None:
src\trade_guardian\infra\retry_option_chain.py:def fetch_with_retry_and_diagnostics(
src\trade_guardian\infra\retry_option_chain.py:def _sleep_backoff(attempt: int, retry: RetryConfig) -> None:
src\trade_guardian\infra\schwab_client.py:    def __init__(self, cfg: dict = None):
src\trade_guardian\infra\schwab_client.py:    def build_context(self, symbol: str, days: int = 600) -> Optional[Context]:
src\trade_guardian\infra\schwab_client.py:            print(f"âŒ [Error] build_context critical fail for {symbol}: {e}")
src\trade_guardian\infra\schwab_client.py:    def _headers(self):
src\trade_guardian\infra\schwab_client.py:    def get_quote(self, symbol: str) -> dict:
src\trade_guardian\infra\schwab_client.py:    def calculate_hv_percentile(self, symbol: str) -> HVInfo:
src\trade_guardian\infra\schwab_client.py:    def _fetch_calls_chain(self, symbol: str, from_d: str, to_d: str, range_val: str = "NTM") -> dict:
src\trade_guardian\infra\schwab_client.py:    def scan_atm_term(self, symbol: str, days: int, contract_type: str = "CALL") -> tuple[float, list[TermPoint], dict]:
src\trade_guardian\infra\schwab_token_manager.py:def fetch_schwab_token() -> str:
src\trade_guardian\infra\schwab_token_manager_legacy.py:def fetch_schwab_token() -> Optional[str]:
src\trade_guardian\infra\tickers.py:def load_tickers_csv(path: str) -> List[str]:
src\trade_guardian\strategies\auto.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\auto.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\auto.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian\strategies\base.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\base.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian\strategies\blueprint.py:def _extract_greeks_for(chain: Dict[str, Any], side: str, exp: str, strike: float) -> Dict[str, float]:
src\trade_guardian\strategies\blueprint.py:def _extract_mid_for(chain: Dict[str, Any], side: str, exp: str, strike: float) -> Optional[float]:
src\trade_guardian\strategies\blueprint.py:    def one_liner(self) -> str:
src\trade_guardian\strategies\blueprint.py:    def one_liner(self) -> str:
src\trade_guardian\strategies\blueprint.py:    def one_liner(self) -> str:
src\trade_guardian\strategies\blueprint.py:def build_diagonal_blueprint(
src\trade_guardian\strategies\blueprint.py:def build_straddle_blueprint(
src\trade_guardian\strategies\blueprint.py:def build_calendar_blueprint(
src\trade_guardian\strategies\calendar.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\calendar.py:    def _tag(self, regime: str, curvature: str) -> str:
src\trade_guardian\strategies\calendar.py:    def _clamp(x: float, lo: float, hi: float) -> float:
src\trade_guardian\strategies\calendar.py:    def _risk_score(
src\trade_guardian\strategies\calendar.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\calendar.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian\strategies\diagonal.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\diagonal.py:    def _clamp(x: float, lo: float, hi: float) -> float:
src\trade_guardian\strategies\diagonal.py:    def _find_strikes(self, ctx: Context, short_exp: str) -> Tuple[Optional[float], Optional[str], Optional[float]]:
src\trade_guardian\strategies\diagonal.py:            # LEAPS definition: usually > 1 year, but > 120 days is acceptable for diagonals
src\trade_guardian\strategies\diagonal.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\diagonal.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian\strategies\hv_calendar.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\hv_calendar.py:    def _hv_adjust(self, hv_rank: float) -> int:
src\trade_guardian\strategies\hv_calendar.py:    def _find_point_gamma(ctx: Context, exp: str, dte: int) -> float:
src\trade_guardian\strategies\hv_calendar.py:    def _best_effort_squeeze_ratio(ctx: Context) -> float:
src\trade_guardian\strategies\hv_calendar.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\hv_calendar.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian\strategies\long_gamma.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\long_gamma.py:    def _clamp(x: float, lo: float, hi: float) -> float:
src\trade_guardian\strategies\long_gamma.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\placeholder.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\placeholder.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\strategy2_stub.py:    def __init__(self, cfg: dict):
src\trade_guardian\strategies\strategy2_stub.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\strategy2_stub.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian.py:def run_guardian_loop():


================================================================================
FILE_PATH: create_tg_db.py
================================================================================
import sqlite3
import os
import sys
import argparse

def init_db(reset_mode=False):
    # ==========================================
    # 1. è·¯å¾„å®šä½é€»è¾‘
    # ==========================================
    # è·å–å½“å‰è„šæœ¬æ‰€åœ¨çš„æ ¹ç›®å½•
    project_root = os.path.dirname(os.path.abspath(__file__))
    
    # å®šä¹‰æ•°æ®åº“æ–‡ä»¶å¤¹å’Œæ–‡ä»¶è·¯å¾„
    db_folder = os.path.join(project_root, "db")
    db_path = os.path.join(db_folder, "trade_guardian.db")

    print(f"ğŸ“ Project Root: {project_root}")
    
    # 2. å¦‚æœ db æ–‡ä»¶å¤¹ä¸å­˜åœ¨ï¼Œåˆ›å»ºå®ƒ
    if not os.path.exists(db_folder):
        print(f"ğŸ› ï¸  Creating DB folder: {db_folder}")
        os.makedirs(db_folder)
    
    # ==========================================
    # 3. é‡ç½®é€»è¾‘ (Safety Guard)
    # ==========================================
    if os.path.exists(db_path):
        if reset_mode:
            try:
                os.remove(db_path)
                print(f"ğŸ’¥ [RESET MODE] Deleted old database: {db_path}")
            except Exception as e:
                print(f"âŒ Error deleting old DB: {e}")
                return
        else:
            print(f"ğŸ›¡ï¸  [SAFE MODE] Database exists. Keeping data. (Use --reset to wipe)")
    else:
        print(f"ğŸ†• Database not found. Creating new one.")

    print(f"ğŸ”— Connecting to database: {db_path}")
    conn = sqlite3.connect(db_path)
    c = conn.cursor()

    # ==========================================
    # 4. åˆ›å»ºè¡¨ç»“æ„ (Schema) - ä½¿ç”¨ IF NOT EXISTS
    # ==========================================

    # è¡¨ 1: Scan Batches (æ‰«ææ‰¹æ¬¡/ä¼šè¯)
    print("   ... Checking table: scan_batches")
    c.execute('''
        CREATE TABLE IF NOT EXISTS scan_batches (
            batch_id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp TEXT,           -- ç³»ç»Ÿå¯åŠ¨æ—¶é—´ (ISO æ ¼å¼)
            strategy_name TEXT,       -- è¿è¡Œçš„ç­–ç•¥ (auto/long_gamma/diagonal)
            market_vix REAL,          -- æ‰«ææ—¶çš„ VIX æŒ‡æ•°æ°´å¹³
            universe_size INTEGER,    -- æ‰«æçš„æ ‡çš„æ€»æ•°
            avg_abs_edge REAL,        -- å¸‚åœºå¹³å‡åç¦»å¼ºåº¦ (æ¸©åº¦è®¡)
            cheap_vol_pct REAL,       -- ä¾¿å®œè´§å æ¯” (Edge > 0)
            elapsed_time REAL         -- æ€»è¿è¡Œè€—æ—¶ (ç§’)
        )
    ''')

    # è¡¨ 2: Market Snapshots (è¡Œæƒ…å¿«ç…§)
    print("   ... Checking table: market_snapshots")
    c.execute('''
        CREATE TABLE IF NOT EXISTS market_snapshots (
            snapshot_id INTEGER PRIMARY KEY AUTOINCREMENT,
            batch_id INTEGER,         -- å…³è”æ‰«ææ‰¹æ¬¡
            symbol TEXT,              -- è‚¡ç¥¨ä»£ç 
            price REAL,               -- ç°ä»·
            iv_short REAL,            -- çŸ­ç«¯ IV (29 DTE)
            iv_base REAL,             -- é•¿ç«¯åŸºå‡† IV
            edge REAL,                -- Edge Value
            hv_rank REAL,             -- å†å²æ³¢åŠ¨ç‡æ’å
            regime TEXT,              -- æœŸé™ç»“æ„ (CONTANGO/BACKWARDATION)
            FOREIGN KEY(batch_id) REFERENCES scan_batches(batch_id)
        )
    ''')

    # è¡¨ 3: Trade Plans & Gates (æ‰§è¡Œè®¡åˆ’ä¸é£é™©é—¸é—¨)
    print("   ... Checking table: trade_plans")
    c.execute('''
        CREATE TABLE IF NOT EXISTS trade_plans (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            snapshot_id INTEGER,      -- å…³è”è¡Œæƒ…å¿«ç…§
            strategy_type TEXT,       -- å…·ä½“é‡‡ç”¨çš„å­ç­–ç•¥ (LG / PMCC)
            cal_score INTEGER,        -- ç­–ç•¥è¯„åˆ† (0-100)
            short_risk INTEGER,       -- é£é™©è¯„åˆ† (0-100)
            gate_status TEXT,         -- æ‰§è¡Œå›¾æ ‡ (âœ… / âš ï¸ / â›”)
            total_gamma REAL,         -- ç»„åˆæ€» Gamma
            est_debit REAL,           -- ä¼°ç®—æƒåˆ©é‡‘æˆæœ¬
            error_msg TEXT,           -- å¦‚æœè¢«æ‹’ç»ï¼Œè®°å½•åŸå›  (å¦‚ Debit > Width)
            blueprint_json TEXT,      -- å®Œæ•´çš„è“å›¾ç»“æ„ (JSON æ ¼å¼)
            tag TEXT,                 -- ç­–ç•¥æ ‡ç­¾ (LG-M-K)
            FOREIGN KEY(snapshot_id) REFERENCES market_snapshots(snapshot_id)
        )
    ''')

    conn.commit()
    
    # éªŒè¯è¡¨æ•°é‡
    c.execute("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%';")
    tables = c.fetchall()
    
    # éªŒè¯å…³é”®å­—æ®µæ˜¯å¦å­˜åœ¨ (Tag check)
    c.execute("PRAGMA table_info(trade_plans)")
    tp_info = c.fetchall()
    tp_cols = [row[1] for row in tp_info]
    
    conn.close()

    print(f"\nâœ… SUCCESS! Trade Guardian DB initialized with {len(tables)} tables:")
    for t in tables:
        print(f"   - {t[0]}")
    
    # ç®€å•çš„ Schema æ£€æŸ¥
    if 'tag' in tp_cols:
        print(f"ğŸ‰ Verification: 'tag' column exists.")
    else:
        print(f"âš ï¸  Verification Warning: 'tag' column MISSING! (You might need to run with --reset to apply new schema)")

    if 'short_risk' in tp_cols:
        print(f"ğŸ‰ Verification: 'short_risk' column exists.")
    else:
        print(f"âš ï¸  Verification Warning: 'short_risk' column MISSING!")

    print(f"\nğŸ¯ Database Location: {db_path}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Initialize Trade Guardian Database")
    parser.add_argument("--reset", action="store_true", help="âš ï¸  DANGER: Wipe existing database and start fresh")
    args = parser.parse_args()
    
    init_db(reset_mode=args.reset)

================================================================================
FILE_PATH: history_viewer.py
================================================================================
import os
import sqlite3
import pandas as pd
import sys
import time
from datetime import datetime
from tabulate import tabulate
from colorama import Fore, Style, init

# åˆå§‹åŒ–é¢œè‰²ç¯å¢ƒ
init(autoreset=True)

class HistoryViewer:
    def __init__(self, db_path=None):
        if db_path:
            self.db_path = db_path
        else:
            root = os.path.dirname(os.path.abspath(__file__))
            self.db_path = os.path.join(root, "db", "trade_guardian.db")

    def get_latest_radar(self, symbol=None, limit=20):
        conn = sqlite3.connect(self.db_path)
        try:
            # 1. è·å–æœ€æ–° Batch
            batch_res = conn.execute("""
                SELECT b.batch_id, b.timestamp, b.market_vix 
                FROM scan_batches b
                JOIN market_snapshots s ON s.batch_id = b.batch_id
                ORDER BY b.batch_id DESC LIMIT 1
            """).fetchone()
            
            if not batch_res:
                return pd.DataFrame(), 0, "N/A"
            
            latest_id, latest_time_str, current_vix = batch_res
            latest_time = datetime.strptime(latest_time_str, "%Y-%m-%d %H:%M:%S")
            
            # 2. æ™ºèƒ½è®¡ç®— Uptime (Session Awareness)
            current_id = latest_id
            session_start_time = latest_time
            
            past_batches = conn.execute("""
                SELECT batch_id, timestamp FROM scan_batches 
                WHERE batch_id >= ? ORDER BY batch_id DESC
            """, (latest_id - 12,)).fetchall()
            
            for i in range(len(past_batches) - 1):
                curr = datetime.strptime(past_batches[i][1], "%Y-%m-%d %H:%M:%S")
                prev = datetime.strptime(past_batches[i+1][1], "%Y-%m-%d %H:%M:%S")
                diff = (curr - prev).total_seconds()
                if diff > 1200: # 20åˆ†é’Ÿæ–­æ¡£
                    session_start_time = curr
                    break
                session_start_time = prev 

            uptime_min = (latest_time - session_start_time).total_seconds() / 60.0
            if uptime_min < 1: uptime_min = 1.0
            
            # 3. æ„å»ºæŸ¥è¯¢
            filter_sql = "AND s.symbol = ?" if symbol else ""
            params = [latest_id, symbol, limit] if symbol else [latest_id, limit]
            
            query = f"""
            SELECT 
                s.symbol as Sym,
                s.price as Price,
                s.iv_short as IV_S,
                s.snapshot_id,
                COALESCE(p.gate_status, 'WAIT') as Gate,
                COALESCE(p.cal_score, 0) as Score,
                COALESCE(p.total_gamma, 0.0) as Gamma,
                COALESCE(p.tag, '') as Tag,
                p.error_msg as Reason
            FROM market_snapshots s
            LEFT JOIN trade_plans p ON s.snapshot_id = p.snapshot_id
            WHERE s.batch_id = ? {filter_sql}
            ORDER BY Score DESC, IV_S DESC
            LIMIT ?
            """
            
            df = pd.read_sql_query(query, conn, params=tuple(params))
            
            if not df.empty:
                df['Time'] = latest_time_str
                df['VIX'] = current_vix
                df = self._process_logic(df, latest_id, conn, uptime_min)
            
            return df, uptime_min, latest_time_str
        finally:
            conn.close()


    def _process_logic(self, df, latest_id, conn, uptime_min):
        v_prev = conn.execute("SELECT market_vix FROM scan_batches WHERE batch_id = ?", (latest_id-1,)).fetchone()
        df['VIX_Î”'] = round(df['VIX'].iloc[0] - v_prev[0], 2) if v_prev else 0.0

        for i, row in df.iterrows():
            sym = row['Sym']
            
            res10 = conn.execute("SELECT iv_short FROM market_snapshots WHERE symbol=? AND batch_id=?", (sym, latest_id-1)).fetchone()
            res1h = conn.execute("SELECT iv_short FROM market_snapshots WHERE symbol=? AND batch_id=?", (sym, latest_id-6)).fetchone()

            # Î”10m Logic
            if res10:
                df.at[i, 'Î”10m'] = round(row['IV_S'] - res10[0], 1)
                df.at[i, 'Î”10m_Valid'] = True
            else:
                df.at[i, 'Î”10m'] = 0.0
                df.at[i, 'Î”10m_Valid'] = False 

            # Î”1h Logic
            if res1h:
                df.at[i, 'Î”1h'] = round(row['IV_S'] - res1h[0], 1)
                df.at[i, 'Î”1h_Valid'] = True
            else:
                df.at[i, 'Î”1h'] = 0.0
                df.at[i, 'Î”1h_Valid'] = False 

            # DNA åˆ¤å®š
            dna_type = "QUIET"
            d10 = df.at[i, 'Î”10m']
            
            if uptime_min < 60:
                # WARMUP æ¨¡å¼
                if d10 > 2.5: dna_type = "PULSE"
                elif d10 > 0.8: dna_type = "TREND"
                elif d10 < -1.5: dna_type = "CRUSH"
            else:
                # NORMAL æ¨¡å¼
                if d10 > 2.0: dna_type = "PULSE"
                elif d10 > 0.5: dna_type = "TREND"
                elif d10 < -1.0: dna_type = "CRUSH"
            
            df.at[i, 'DNA_Raw'] = dna_type
                
        return df

    def display(self, symbol=None):
        df, uptime_min, last_time = self.get_latest_radar(symbol=symbol)
        
        if df.empty:
            print(f"{Fore.RED}ğŸ“­ [Sync] Monitoring... (No Data Yet){Style.RESET_ALL}")
            return

        formatted_rows = []
        for _, row in df.iterrows():
            p_str = f"{row['Price']:>8.1f}"
            iv_str = f"{row['IV_S']:>5.1f}%"
            g_str = f"{row['Gamma']:>6.3f}"
            s_str = f"{row['Score']:>3}"
            
            # Î”10m
            if row['Î”10m_Valid']:
                d10_val = row['Î”10m']
                d10_str = f"{d10_val:>+5.1f}"
                if d10_val > 1.5: d10_render = f"{Fore.RED}{d10_str}{Style.RESET_ALL}"
                elif d10_val < -1.5: d10_render = f"{Fore.CYAN}{d10_str}{Style.RESET_ALL}"
                else: d10_render = d10_str
            else:
                d10_render = f"{Fore.LIGHTBLACK_EX} INIT{Style.RESET_ALL}"

            # Î”1h å¼ºåˆ¶ Warmup æ£€æŸ¥
            if row['Î”1h_Valid'] and uptime_min >= 60:
                d1h_val = row['Î”1h']
                d1h_str = f"{d1h_val:>+5.1f}"
                d1h_render = d1h_str 
            else:
                d1h_render = f"{Fore.YELLOW} WARM{Style.RESET_ALL}"

            dna_raw = f"{row['DNA_Raw']:<5}"
            if row['DNA_Raw'] == "PULSE": dna_render = f"{Fore.CYAN}{dna_raw}{Style.RESET_ALL}"
            elif row['DNA_Raw'] == "TREND": dna_render = f"{Fore.GREEN}{dna_raw}{Style.RESET_ALL}"
            elif row['DNA_Raw'] == "CRUSH": dna_render = f"{Fore.YELLOW}{dna_raw}{Style.RESET_ALL}"
            else: dna_render = f"{Fore.WHITE}{dna_raw}{Style.RESET_ALL}"

            gate_raw = f"{row['Gate']:<6}"
            if row['Gate'] == "EXEC": gate_c = Fore.GREEN
            elif row['Gate'] == "LIMIT": gate_c = Fore.CYAN
            elif row['Gate'] == "FORBID": gate_c = Fore.RED
            else: gate_c = Fore.YELLOW
            gate_render = f"{gate_c}{gate_raw}{Style.RESET_ALL}"

            tag_val = row['Tag'] if row['Tag'] else ""
            tag_render = f"{Fore.WHITE}{tag_val:<9}{Style.RESET_ALL}"

            formatted_rows.append([
                f"{Style.BRIGHT}{row['Sym']:<5}{Style.RESET_ALL}",
                dna_render,
                p_str,
                iv_str,
                d10_render,
                d1h_render, 
                g_str,
                f"{Fore.CYAN if row['Score'] >= 70 else Fore.WHITE}{s_str}{Style.RESET_ALL}",
                gate_render,
                tag_render
            ])

        v_diff = df['VIX_Î”'].iloc[0]
        v_info = f"VIX: {df['VIX'].iloc[0]} ({Fore.RED if v_diff > 0 else Fore.GREEN}{v_diff:+0.2f}{Style.RESET_ALL})"
        
        mode_str = f"{Fore.GREEN}NORMAL{Style.RESET_ALL}"
        if uptime_min < 60:
            mode_str = f"{Fore.YELLOW}WARMUP (<60m){Style.RESET_ALL}"
        
        print("\n" + "="*100)
        print(f"ğŸ“¡ RADAR | {last_time} | Run: {int(uptime_min)}m | Mode: {mode_str} | {v_info}")
        print("="*100)
        
        headers = ["Sym", "DNA", "Price", "IV_S", "Î”10m", "Î”1h", "Gamma", "Score", "Gate", "Tag"]
        print(tabulate(formatted_rows, headers=headers, tablefmt='simple', stralign="right", disable_numparse=True))
        print("-" * 100)

        # --- [FIX] ä¿®å¤è¯Šæ–­åŒºé€»è¾‘ï¼šå¦‚æœ Reason ä¸ºç©ºï¼Œç»™äºˆé»˜è®¤å€¼ï¼Œè€Œä¸æ˜¯éšè— ---
        problematic = df[ (df['Gate'] == 'FORBID') | (df['Reason'].notna()) ]
        if not problematic.empty:
            print(f"{Fore.RED}â›” Risk / Gate Diagnostics:{Style.RESET_ALL}")
            for _, r in problematic.iterrows():
                # å¦‚æœæ•°æ®åº“é‡Œ error_msg æ˜¯ç©ºçš„ï¼Œæä¾›ä¸€ä¸ªé»˜è®¤çš„å…œåº•è§£é‡Š
                # IWM è¿™ç§ Gamma è¶…æ ‡çš„é€šå¸¸å±äº Policy Restriction
                reason_str = r['Reason'] if r['Reason'] else "Policy Restriction (High Risk/Gamma)"
                print(f"   â€¢ {Style.BRIGHT}{r['Sym']}{Style.RESET_ALL}: {r['Gate']} -> {reason_str}")
        
        print("="*100)

        
if __name__ == "__main__":
    viewer = HistoryViewer()
    target_sym = sys.argv[1] if len(sys.argv) > 1 else None
    print(f"Starting Dashboard... (Target: {target_sym if target_sym else 'ALL'})")
    while True:
        try:
            viewer.display(symbol=target_sym)
            time.sleep(60)
        except KeyboardInterrupt:
            print("\nStopped.")
            break
        except Exception as e:
            print(f"Error: {e}")
            time.sleep(5)

================================================================================
FILE_PATH: project_flat_view2.txt
================================================================================
PROJECT_ROOT: D:\workspace\trade_guardian
GENERATED_BY: merge_project.py
================================================================================


================================================================================
FILE_PATH: build_context.txt
================================================================================
create_tg_db.py:def init_db():
history_viewer.py:    def __init__(self, db_path="db/trade_guardian.db"):
history_viewer.py:    def get_latest_radar(self, symbol=None, limit=20):
history_viewer.py:    def _process_logic(self, df, latest_id, conn):
history_viewer.py:    def display(self, symbol=None):
merge_project.py:def is_text_file(file_path):
merge_project.py:def merge_project_files():
src\trade_guardian\app\cli.py:    DEFAULT_CONFIG,
src\trade_guardian\app\cli.py:def main():
src\trade_guardian\app\cli.py:    p_init.add_argument("--path", type=str, default=None, help="Output path (default: ./config/config.json)")
src\trade_guardian\app\cli.py:    p_scan.add_argument("--config", type=str, default=None, help="Config path (default: ./config/config.json)")
src\trade_guardian\app\cli.py:    p_scan.add_argument("--strategy", type=str, default="auto", help="Strategy name (default: auto)")
src\trade_guardian\app\cli.py:    p_scan.add_argument("--days", type=int, default=600)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--csv", type=str, default=None, help="Tickers csv path")
src\trade_guardian\app\cli.py:    p_scan.add_argument("--min-score", type=int, default=60)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--max-risk", type=int, default=70)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--limit", type=int, default=0)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--top", type=int, default=None, help="Only show top N sorted blueprints")
src\trade_guardian\app\cli.py:    p_scan.add_argument("--short-rank", type=int, default=None)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--min-short-dte", type=int, default=None)
src\trade_guardian\app\cli.py:    p_scan.add_argument("--max-probe-rank", type=int, default=None)
src\trade_guardian\app\cli.py:        write_config_template(out, DEFAULT_CONFIG, overwrite=args.force)
src\trade_guardian\app\cli.py:        autogen_default = bool(DEFAULT_CONFIG.get("runtime", {}).get("autogen_config_if_missing", True))
src\trade_guardian\app\cli.py:        autogen = autogen_default
src\trade_guardian\app\cli.py:            write_config_template(cfg_path, DEFAULT_CONFIG, overwrite=False)
src\trade_guardian\app\cli.py:        cfg = load_config(cfg_path, DEFAULT_CONFIG)
src\trade_guardian\app\orchestrator.py:    def __init__(self, client, cfg: dict, policy, strategy=None):
src\trade_guardian\app\orchestrator.py:    def _get_universe(self) -> List[str]:
src\trade_guardian\app\orchestrator.py:    def scanlist(self, strategy_name: str = "auto", days: int = 600, 
src\trade_guardian\app\orchestrator.py:                ctx = self.client.build_context(ticker, days=days)
src\trade_guardian\app\orchestrator.py:    def _get_gate_status(self, row: ScanRow, bp: Optional[Blueprint], dna_type: str) -> str:
src\trade_guardian\app\orchestrator.py:    def _print_enhanced_blueprint(self, bp: Blueprint, row: ScanRow, dna: str):
src\trade_guardian\app\orchestrator.py:    def _get_temp(self, dna):
src\trade_guardian\app\orchestrator.py:    def plan(self, ctx: Context, row: ScanRow) -> Optional[Blueprint]:
src\trade_guardian\app\orchestrator.py:    def _load_strategy(self, name: str):
src\trade_guardian\app\persistence.py:    def __init__(self, db_path: str = None):
src\trade_guardian\app\persistence.py:    def save_scan_session(self, 
src\trade_guardian\app\persistence.py:    def check_iv_spikes(self, current_batch_id: int, threshold: float = 3.0) -> List[Tuple[str, float]]:
src\trade_guardian\app\persistence.py:    def get_latest_drift_1h(self, symbol: str) -> float:
src\trade_guardian\app\renderer.py:    def __init__(self, cfg=None, policy=None, hv_cache_path: Optional[str] = None):
src\trade_guardian\app\renderer.py:    def _sanitize_int(self, value: Any, default: int = 0) -> int:
src\trade_guardian\app\renderer.py:            if isinstance(value, list): return self._sanitize_int(value[0], default) if value else default
src\trade_guardian\app\renderer.py:            return default
src\trade_guardian\app\renderer.py:            return default
src\trade_guardian\app\renderer.py:    def render(self, 
src\trade_guardian\app\renderer.py:    def render_diagnostics(self, strict: List[ScanRow], **kwargs):
src\trade_guardian\app\renderer.py:    def _print_table(self, title: str, rows: List[ScanRow]):
src\trade_guardian\app\renderer.py:    def _print_details(self, title: str, rows: List[ScanRow]):
src\trade_guardian\app\renderer.py:    def _print_blueprints(self, title: str, rows: List[ScanRow]):
src\trade_guardian\domain\features.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\domain\features.py:    def _eligible_points(term: List[TermPoint], min_dte: int) -> List[TermPoint]:
src\trade_guardian\domain\features.py:    def _baseline_iv(term: List[TermPoint], fallback_iv: float) -> float:
src\trade_guardian\domain\features.py:    def build(self, term: List[TermPoint], hv: HVInfo, rank: int) -> Dict[str, object]:
src\trade_guardian\domain\hv.py:    def __init__(self, client: SchwabClient, cache: JsonDailyCache):
src\trade_guardian\domain\hv.py:    def get_hv(self, symbol: str) -> HVInfo:
src\trade_guardian\domain\models.py:    meta: Dict[str, Any] = field(default_factory=dict)
src\trade_guardian\domain\models.py:    legs: List[OrderLeg] = field(default_factory=list)
src\trade_guardian\domain\policy.py:    def probe_ranks(self) -> List[int]:
src\trade_guardian\domain\registry.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\domain\registry.py:    def get(self, name: str):
src\trade_guardian\domain\registry.py:        if n in ("auto", "smart", "default"):
src\trade_guardian\domain\scoring.py:    def __init__(self, rules: ScoringRules):
src\trade_guardian\domain\scoring.py:    def _hv_points(self, hv_rank: float) -> int:
src\trade_guardian\domain\scoring.py:    def score_calendar(self, regime: str, curvature: str, edge: float, hv_rank: float) -> tuple[int, ScoreBreakdown]:
src\trade_guardian\infra\cache.py:    def __init__(self, path: str):
src\trade_guardian\infra\cache.py:    def _load(self):
src\trade_guardian\infra\cache.py:    def _save(self):
src\trade_guardian\infra\cache.py:    def _today() -> str:
src\trade_guardian\infra\cache.py:    def get(self, key: str) -> Optional[dict]:
src\trade_guardian\infra\cache.py:    def set(self, key: str, value: dict) -> None:
src\trade_guardian\infra\cache.py:        self._data.setdefault("items", {})[key] = value
src\trade_guardian\infra\config.py:DEFAULT_CONFIG: Dict[str, Any] = {
src\trade_guardian\infra\config.py:def _deep_merge(a: Dict[str, Any], b: Dict[str, Any]) -> Dict[str, Any]:
src\trade_guardian\infra\config.py:def load_config(path: str, default_cfg: Dict[str, Any]) -> Dict[str, Any]:
src\trade_guardian\infra\config.py:        return dict(default_cfg)
src\trade_guardian\infra\config.py:        return dict(default_cfg)
src\trade_guardian\infra\config.py:    return _deep_merge(default_cfg, user_cfg)
src\trade_guardian\infra\config.py:def write_config_template(path: str, default_cfg: Dict[str, Any], overwrite: bool = False) -> None:
src\trade_guardian\infra\config.py:        json.dump(default_cfg, f, indent=2, ensure_ascii=False)
src\trade_guardian\infra\config.py:def merge_config_paths(cfg: Dict[str, Any], root: str, csv_override: Optional[str]) -> Dict[str, Any]:
src\trade_guardian\infra\config.py:    out.setdefault("paths", {})
src\trade_guardian\infra\config.py:def _resolve_probe_count(pcfg: Dict[str, Any], base_rank: int) -> int:
src\trade_guardian\infra\config.py:def policy_from_cfg_and_cli(cfg: Dict[str, Any], args) -> ShortLegPolicy:
src\trade_guardian\infra\rate_limit.py:    def __init__(self, throttle_sec: float):
src\trade_guardian\infra\rate_limit.py:    def sleep(self):
src\trade_guardian\infra\retry_option_chain.py:def _utc_now_iso() -> str:
src\trade_guardian\infra\retry_option_chain.py:def _safe_snippet(s: Any, max_len: int = 400) -> str:
src\trade_guardian\infra\retry_option_chain.py:def classify_empty_response(
src\trade_guardian\infra\retry_option_chain.py:def _write_jsonl(path: Path, record: Dict[str, Any]) -> None:
src\trade_guardian\infra\retry_option_chain.py:def fetch_with_retry_and_diagnostics(
src\trade_guardian\infra\retry_option_chain.py:def _sleep_backoff(attempt: int, retry: RetryConfig) -> None:
src\trade_guardian\infra\schwab_client.py:    def __init__(self, cfg: dict = None):
src\trade_guardian\infra\schwab_client.py:    def build_context(self, symbol: str, days: int = 600) -> Optional[Context]:
src\trade_guardian\infra\schwab_client.py:            print(f"âŒ [Error] build_context critical fail for {symbol}: {e}")
src\trade_guardian\infra\schwab_client.py:    def _headers(self):
src\trade_guardian\infra\schwab_client.py:    def get_quote(self, symbol: str) -> dict:
src\trade_guardian\infra\schwab_client.py:    def calculate_hv_percentile(self, symbol: str) -> HVInfo:
src\trade_guardian\infra\schwab_client.py:    def _fetch_calls_chain(self, symbol: str, from_d: str, to_d: str, range_val: str = "NTM") -> dict:
src\trade_guardian\infra\schwab_client.py:    def scan_atm_term(self, symbol: str, days: int, contract_type: str = "CALL") -> tuple[float, list[TermPoint], dict]:
src\trade_guardian\infra\schwab_token_manager.py:def fetch_schwab_token() -> str:
src\trade_guardian\infra\schwab_token_manager_legacy.py:def fetch_schwab_token() -> Optional[str]:
src\trade_guardian\infra\tickers.py:def load_tickers_csv(path: str) -> List[str]:
src\trade_guardian\strategies\auto.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\auto.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\auto.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian\strategies\base.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\base.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian\strategies\blueprint.py:def _extract_greeks_for(chain: Dict[str, Any], side: str, exp: str, strike: float) -> Dict[str, float]:
src\trade_guardian\strategies\blueprint.py:def _extract_mid_for(chain: Dict[str, Any], side: str, exp: str, strike: float) -> Optional[float]:
src\trade_guardian\strategies\blueprint.py:    def one_liner(self) -> str:
src\trade_guardian\strategies\blueprint.py:    def one_liner(self) -> str:
src\trade_guardian\strategies\blueprint.py:    def one_liner(self) -> str:
src\trade_guardian\strategies\blueprint.py:def build_diagonal_blueprint(
src\trade_guardian\strategies\blueprint.py:def build_straddle_blueprint(
src\trade_guardian\strategies\blueprint.py:def build_calendar_blueprint(
src\trade_guardian\strategies\calendar.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\calendar.py:    def _tag(self, regime: str, curvature: str) -> str:
src\trade_guardian\strategies\calendar.py:    def _clamp(x: float, lo: float, hi: float) -> float:
src\trade_guardian\strategies\calendar.py:    def _risk_score(
src\trade_guardian\strategies\calendar.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\calendar.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian\strategies\diagonal.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\diagonal.py:    def _clamp(x: float, lo: float, hi: float) -> float:
src\trade_guardian\strategies\diagonal.py:    def _find_strikes(self, ctx: Context, short_exp: str) -> Tuple[Optional[float], Optional[str], Optional[float]]:
src\trade_guardian\strategies\diagonal.py:            # LEAPS definition: usually > 1 year, but > 120 days is acceptable for diagonals
src\trade_guardian\strategies\diagonal.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\diagonal.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian\strategies\hv_calendar.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\hv_calendar.py:    def _hv_adjust(self, hv_rank: float) -> int:
src\trade_guardian\strategies\hv_calendar.py:    def _find_point_gamma(ctx: Context, exp: str, dte: int) -> float:
src\trade_guardian\strategies\hv_calendar.py:    def _best_effort_squeeze_ratio(ctx: Context) -> float:
src\trade_guardian\strategies\hv_calendar.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\hv_calendar.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian\strategies\long_gamma.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\long_gamma.py:    def _clamp(x: float, lo: float, hi: float) -> float:
src\trade_guardian\strategies\long_gamma.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\placeholder.py:    def __init__(self, cfg: dict, policy: ShortLegPolicy):
src\trade_guardian\strategies\placeholder.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\strategy2_stub.py:    def __init__(self, cfg: dict):
src\trade_guardian\strategies\strategy2_stub.py:    def evaluate(self, ctx: Context) -> ScanRow:
src\trade_guardian\strategies\strategy2_stub.py:    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
src\trade_guardian.py:def run_guardian_loop():


================================================================================
FILE_PATH: create_tg_db.py
================================================================================
import sqlite3
import os
import sys
import argparse

def init_db(reset_mode=False):
    # ==========================================
    # 1. è·¯å¾„å®šä½é€»è¾‘
    # ==========================================
    # è·å–å½“å‰è„šæœ¬æ‰€åœ¨çš„æ ¹ç›®å½•
    project_root = os.path.dirname(os.path.abspath(__file__))
    
    # å®šä¹‰æ•°æ®åº“æ–‡ä»¶å¤¹å’Œæ–‡ä»¶è·¯å¾„
    db_folder = os.path.join(project_root, "db")
    db_path = os.path.join(db_folder, "trade_guardian.db")

    print(f"ğŸ“ Project Root: {project_root}")
    
    # 2. å¦‚æœ db æ–‡ä»¶å¤¹ä¸å­˜åœ¨ï¼Œåˆ›å»ºå®ƒ
    if not os.path.exists(db_folder):
        print(f"ğŸ› ï¸  Creating DB folder: {db_folder}")
        os.makedirs(db_folder)
    
    # ==========================================
    # 3. é‡ç½®é€»è¾‘ (Safety Guard)
    # ==========================================
    if os.path.exists(db_path):
        if reset_mode:
            try:
                os.remove(db_path)
                print(f"ğŸ’¥ [RESET MODE] Deleted old database: {db_path}")
            except Exception as e:
                print(f"âŒ Error deleting old DB: {e}")
                return
        else:
            print(f"ğŸ›¡ï¸  [SAFE MODE] Database exists. Keeping data. (Use --reset to wipe)")
    else:
        print(f"ğŸ†• Database not found. Creating new one.")

    print(f"ğŸ”— Connecting to database: {db_path}")
    conn = sqlite3.connect(db_path)
    c = conn.cursor()

    # ==========================================
    # 4. åˆ›å»ºè¡¨ç»“æ„ (Schema) - ä½¿ç”¨ IF NOT EXISTS
    # ==========================================

    # è¡¨ 1: Scan Batches (æ‰«ææ‰¹æ¬¡/ä¼šè¯)
    print("   ... Checking table: scan_batches")
    c.execute('''
        CREATE TABLE IF NOT EXISTS scan_batches (
            batch_id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp TEXT,           -- ç³»ç»Ÿå¯åŠ¨æ—¶é—´ (ISO æ ¼å¼)
            strategy_name TEXT,       -- è¿è¡Œçš„ç­–ç•¥ (auto/long_gamma/diagonal)
            market_vix REAL,          -- æ‰«ææ—¶çš„ VIX æŒ‡æ•°æ°´å¹³
            universe_size INTEGER,    -- æ‰«æçš„æ ‡çš„æ€»æ•°
            avg_abs_edge REAL,        -- å¸‚åœºå¹³å‡åç¦»å¼ºåº¦ (æ¸©åº¦è®¡)
            cheap_vol_pct REAL,       -- ä¾¿å®œè´§å æ¯” (Edge > 0)
            elapsed_time REAL         -- æ€»è¿è¡Œè€—æ—¶ (ç§’)
        )
    ''')

    # è¡¨ 2: Market Snapshots (è¡Œæƒ…å¿«ç…§)
    print("   ... Checking table: market_snapshots")
    c.execute('''
        CREATE TABLE IF NOT EXISTS market_snapshots (
            snapshot_id INTEGER PRIMARY KEY AUTOINCREMENT,
            batch_id INTEGER,         -- å…³è”æ‰«ææ‰¹æ¬¡
            symbol TEXT,              -- è‚¡ç¥¨ä»£ç 
            price REAL,               -- ç°ä»·
            iv_short REAL,            -- çŸ­ç«¯ IV (29 DTE)
            iv_base REAL,             -- é•¿ç«¯åŸºå‡† IV
            edge REAL,                -- Edge Value
            hv_rank REAL,             -- å†å²æ³¢åŠ¨ç‡æ’å
            regime TEXT,              -- æœŸé™ç»“æ„ (CONTANGO/BACKWARDATION)
            FOREIGN KEY(batch_id) REFERENCES scan_batches(batch_id)
        )
    ''')

    # è¡¨ 3: Trade Plans & Gates (æ‰§è¡Œè®¡åˆ’ä¸é£é™©é—¸é—¨)
    print("   ... Checking table: trade_plans")
    c.execute('''
        CREATE TABLE IF NOT EXISTS trade_plans (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            snapshot_id INTEGER,      -- å…³è”è¡Œæƒ…å¿«ç…§
            strategy_type TEXT,       -- å…·ä½“é‡‡ç”¨çš„å­ç­–ç•¥ (LG / PMCC)
            cal_score INTEGER,        -- ç­–ç•¥è¯„åˆ† (0-100)
            short_risk INTEGER,       -- é£é™©è¯„åˆ† (0-100)
            gate_status TEXT,         -- æ‰§è¡Œå›¾æ ‡ (âœ… / âš ï¸ / â›”)
            total_gamma REAL,         -- ç»„åˆæ€» Gamma
            est_debit REAL,           -- ä¼°ç®—æƒåˆ©é‡‘æˆæœ¬
            error_msg TEXT,           -- å¦‚æœè¢«æ‹’ç»ï¼Œè®°å½•åŸå›  (å¦‚ Debit > Width)
            blueprint_json TEXT,      -- å®Œæ•´çš„è“å›¾ç»“æ„ (JSON æ ¼å¼)
            tag TEXT,                 -- ç­–ç•¥æ ‡ç­¾ (LG-M-K)
            FOREIGN KEY(snapshot_id) REFERENCES market_snapshots(snapshot_id)
        )
    ''')

    conn.commit()
    
    # éªŒè¯è¡¨æ•°é‡
    c.execute("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%';")
    tables = c.fetchall()
    
    # éªŒè¯å…³é”®å­—æ®µæ˜¯å¦å­˜åœ¨ (Tag check)
    c.execute("PRAGMA table_info(trade_plans)")
    tp_info = c.fetchall()
    tp_cols = [row[1] for row in tp_info]
    
    conn.close()

    print(f"\nâœ… SUCCESS! Trade Guardian DB initialized with {len(tables)} tables:")
    for t in tables:
        print(f"   - {t[0]}")
    
    # ç®€å•çš„ Schema æ£€æŸ¥
    if 'tag' in tp_cols:
        print(f"ğŸ‰ Verification: 'tag' column exists.")
    else:
        print(f"âš ï¸  Verification Warning: 'tag' column MISSING! (You might need to run with --reset to apply new schema)")

    if 'short_risk' in tp_cols:
        print(f"ğŸ‰ Verification: 'short_risk' column exists.")
    else:
        print(f"âš ï¸  Verification Warning: 'short_risk' column MISSING!")

    print(f"\nğŸ¯ Database Location: {db_path}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Initialize Trade Guardian Database")
    parser.add_argument("--reset", action="store_true", help="âš ï¸  DANGER: Wipe existing database and start fresh")
    args = parser.parse_args()
    
    init_db(reset_mode=args.reset)

================================================================================
FILE_PATH: history_viewer.py
================================================================================
import os
import sqlite3
import pandas as pd
import sys
import time
from tabulate import tabulate
from colorama import Fore, Style, init

# åˆå§‹åŒ–é¢œè‰²ç¯å¢ƒ
init(autoreset=True)

class HistoryViewer:
    def __init__(self, db_path=None):
        if db_path:
            self.db_path = db_path
        else:
            # [FIX] (C) è·¯å¾„é”šå®šï¼šç¡®ä¿åœ¨ä»»ä½•ç›®å½•è¿è¡Œéƒ½æŒ‡å‘åŒä¸€ä¸ªåº“
            root = os.path.dirname(os.path.abspath(__file__))
            self.db_path = os.path.join(root, "db", "trade_guardian.db")


    def get_latest_radar(self, symbol=None, limit=20):
        conn = sqlite3.connect(self.db_path)
        try:
            batch_res = conn.execute("""
                SELECT b.batch_id, b.timestamp, b.market_vix 
                FROM scan_batches b
                JOIN market_snapshots s ON s.batch_id = b.batch_id
                ORDER BY b.batch_id DESC LIMIT 1
            """).fetchone()
            
            if not batch_res:
                return pd.DataFrame()
            
            latest_id, latest_time, current_vix = batch_res
            
            # [FIX] (F) Symbol è¿‡æ»¤ç”Ÿæ•ˆ
            filter_sql = "AND s.symbol = ?" if symbol else ""
            params = [latest_id, symbol, limit] if symbol else [latest_id, limit]
            
            query = f"""
            SELECT 
                s.symbol as Sym,
                s.price as Price,
                s.iv_short as IV_S,
                s.snapshot_id,
                COALESCE(p.gate_status, 'WAIT') as Gate,
                COALESCE(p.cal_score, 0) as Score,
                COALESCE(p.total_gamma, 0.0) as Gamma,
                COALESCE(p.tag, '') as Tag
            FROM market_snapshots s
            LEFT JOIN trade_plans p ON s.snapshot_id = p.snapshot_id
            WHERE s.batch_id = ? {filter_sql}
            ORDER BY Score DESC, IV_S DESC
            LIMIT ?
            """
            
            # è¿™é‡Œçš„ params å¿…é¡»è½¬æ¢æˆ tuple ä¼ ç»™ read_sql_query
            df = pd.read_sql_query(query, conn, params=tuple(params))
            
            if not df.empty:
                df['Time'] = latest_time # (B) æ­¤æ—¶å·²ç»æ˜¯ YYYY-MM-DD HH:MM:SS æ ¼å¼äº†
                df['VIX'] = current_vix
                df = self._process_logic(df, latest_id, conn)
            
            return df
        finally:
            conn.close()


    def _process_logic(self, df, latest_id, conn):
        """
        è®¡ç®—åŠ¨èƒ½ (Delta 15m / 1h)
        """
        # è·å–ä¸Šä¸€ä¸ª Batch çš„ VIX ç”¨äºè®¡ç®—å·®å€¼
        v_prev = conn.execute("SELECT market_vix FROM scan_batches WHERE batch_id = ?", (latest_id-1,)).fetchone()
        df['VIX_Î”'] = round(df['VIX'].iloc[0] - v_prev[0], 2) if v_prev else 0.0

        for i, row in df.iterrows():
            sym = row['Sym']
            # å°è¯•è·å–å†å² IV æ•°æ®
            res15 = conn.execute("SELECT iv_short FROM market_snapshots WHERE symbol=? AND batch_id=?", (sym, latest_id-1)).fetchone()
            res1h = conn.execute("SELECT iv_short FROM market_snapshots WHERE symbol=? AND batch_id=?", (sym, latest_id-4)).fetchone()

            d15 = round(row['IV_S'] - (res15[0] if res15 else row['IV_S']), 1)
            d1h = round(row['IV_S'] - (res1h[0] if res1h else row['IV_S']), 1)
            
            df.at[i, 'Î”15m'] = d15
            df.at[i, 'Î”1h'] = d1h

            # DNA åˆ¤å®š (ä»…ç”¨äºæ˜¾ç¤ºé¢œè‰²)
            dna_type = "QUIET"
            if d15 > 2.0: dna_type = "PULSE"
            elif d15 > 0.5: dna_type = "TREND"
            elif d15 < -1.0: dna_type = "CRUSH"
            
            df.at[i, 'DNA_Raw'] = dna_type
                
        return df

    def display(self, symbol=None):
        df = self.get_latest_radar(symbol=symbol)
        if df.empty:
            print(f"{Fore.RED}ğŸ“­ [Sync] Monitoring...{Style.RESET_ALL}")
            return

        formatted_rows = []
        for _, row in df.iterrows():
            # --- 1. æ•°æ®æ ¼å¼åŒ– (çº¯æ–‡æœ¬ï¼Œå›ºå®šå®½åº¦) ---
            p_str = f"{row['Price']:>10.2f}"
            iv_str = f"{row['IV_S']:>8.1f}%"
            d15_raw = f"{row['Î”15m']:>+6.1f}"
            d1h_raw = f"{row['Î”1h']:>+6.1f}"
            g_str = f"{row['Gamma']:>8.3f}"
            s_str = f"{row['Score']:>5}"
            
            # --- 2. é¢œè‰²æ¸²æŸ“ ---
            
            # åŠ¨èƒ½ (Î”15m)
            d15_render = d15_raw
            if row['Î”15m'] > 1.5: 
                d15_render = f"{Fore.RED}{d15_raw}{Style.RESET_ALL}"
            elif row['Î”15m'] < -1.5: 
                d15_render = f"{Fore.CYAN}{d15_raw}{Style.RESET_ALL}"

            # DNA çŠ¶æ€
            dna_raw = f"{row['DNA_Raw']:<6}"
            if row['DNA_Raw'] == "PULSE": dna_render = f"{Fore.CYAN}{dna_raw}{Style.RESET_ALL}"
            elif row['DNA_Raw'] == "TREND": dna_render = f"{Fore.GREEN}{dna_raw}{Style.RESET_ALL}"
            elif row['DNA_Raw'] == "CRUSH": dna_render = f"{Fore.YELLOW}{dna_raw}{Style.RESET_ALL}"
            else: dna_render = f"{Fore.WHITE}{dna_raw}{Style.RESET_ALL}"

            # Gate çŠ¶æ€ (åŒæ­¥ Orchestrator çš„é¢œè‰²é€»è¾‘)
            gate_raw = f"{row['Gate']:<6}"
            if row['Gate'] == "EXEC": gate_c = Fore.GREEN
            elif row['Gate'] == "LIMIT": gate_c = Fore.CYAN  # âœ… LIMIT æ˜¾ç¤ºä¸ºé’è‰²
            elif row['Gate'] == "FORBID": gate_c = Fore.RED
            else: gate_c = Fore.YELLOW # WAIT
            gate_render = f"{gate_c}{gate_raw}{Style.RESET_ALL}"

            # Tag æ¸²æŸ“ (âœ… å…³é”®ç‚¹)
            # ç¡®ä¿ Tag ä¸ä¸º None (æ•°æ®åº“è¯»å–å¯èƒ½ä¼šè¯»å‡º None)
            tag_val = row['Tag'] if row['Tag'] is not None else ""
            tag_render = f"{Fore.WHITE}{tag_val:<8}{Style.RESET_ALL}"

            formatted_rows.append([
                f"{Fore.LIGHTBLACK_EX}{row['Time']}{Style.RESET_ALL}",
                f"{Style.BRIGHT}{row['Sym']:<6}{Style.RESET_ALL}",
                dna_render,
                p_str,
                iv_str,
                d15_render,
                d1h_raw,
                g_str,
                f"{Fore.CYAN if row['Score'] >= 70 else Fore.WHITE}{s_str}{Style.RESET_ALL}",
                gate_render,
                tag_render  # âœ… æœ€åä¸€åˆ—
            ])

        # --- 3. å¤´éƒ¨ä¿¡æ¯ä¸æ‰“å° ---
        v_diff = df['VIX_Î”'].iloc[0]
        v_info = f" | VIX: {df['VIX'].iloc[0]} ({Fore.RED if v_diff > 0 else Fore.GREEN}{v_diff:+0.2f}{Style.RESET_ALL})"
        
        # è°ƒæ•´æ¨ªçº¿å®½åº¦ä»¥é€‚é…æ–°å¢çš„åˆ—
        print("\n" + "="*118)
        print(f"ğŸ“¡ DNA MOMENTUM RADAR | {df['Time'].iloc[0]}{v_info}")
        print("="*118)
        
        # å®šä¹‰è¡¨å¤´ï¼Œç¡®ä¿ä¸ row æ•°æ®åˆ—æ•°ä¸€è‡´
        headers = ["Time", "Sym", "DNA", "Price", "IV_S", "Î”15m", "Î”1h", "Gamma", "Score", "Gate", "Tag"]
        
        # stralign="left" é˜²æ­¢ tabulate è‡ªåŠ¨å±…ä¸­å¯¼è‡´é¢œè‰²ä»£ç é”™ä½
        print(tabulate(formatted_rows, headers=headers, tablefmt='psql', stralign="left", disable_numparse=True))
        print("\n" + "="*118)

        
if __name__ == "__main__":
    viewer = HistoryViewer()
    target_sym = sys.argv[1] if len(sys.argv) > 1 else None
    print(f"Starting Dashboard... (Target: {target_sym if target_sym else 'ALL'})")
    while True:
        try:
            viewer.display(symbol=target_sym)
            time.sleep(60)
        except KeyboardInterrupt:
            print("\nStopped.")
            break
        except Exception as e:
            # æ­¤æ—¶å¦‚æœå‡ºé”™ï¼Œè¯·å‘Šè¯‰æˆ‘é”™è¯¯ä¿¡æ¯ï¼Œä½†é€»è¾‘ä¸Šåº”è¯¥å·²ç»é—­ç¯
            print(f"Error: {e}")
            time.sleep(5)

================================================================================
FILE_PATH: pyproject.toml
================================================================================
[build-system]
requires = ["setuptools>=68"]
build-backend = "setuptools.build_meta"

[project]
name = "trade-guardian"
version = "0.1.0"
requires-python = ">=3.10"
dependencies = [
  "requests",
  "pandas",
  "numpy",
  "tabulate",
  "colorama",
]

[tool.setuptools]
package-dir = {"" = "src"}

[tool.setuptools.packages.find]
where = ["src"]


================================================================================
FILE_PATH: README.md
================================================================================


# ğŸ§  Trade Guardian (v2.0)

**Trade Guardian** æ˜¯ä¸€æ¬¾é¢å‘ä¸“ä¸šæœŸæƒäº¤æ˜“è€…çš„è‡ªåŠ¨åŒ–æ‰«æä¸æ‰§è¡Œè®¡åˆ’å·¥å…·ã€‚å®ƒä¸ä»…èƒ½å‘ç°å¸‚åœºä¸­å®šä»·åä½çš„æ³¢åŠ¨ç‡æœºä¼šï¼ˆEdgeï¼‰ï¼Œæ›´èƒ½é€šè¿‡å†…ç½®çš„ **Planner (è®¡åˆ’å™¨)** å¼ºåˆ¶æ‰§è¡Œç¡¬æ€§é£é™©æ‹¦æˆªã€‚

> **è®¾è®¡å“²å­¦**ï¼šScanner è´Ÿè´£æµ·é€‰æœºä¼šï¼ŒPlanner è´Ÿè´£ç¡®ä¿å¯äº¤æ˜“æ€§ä¸ç¡¬é£é™©é—¸é—¨ã€‚

---

## ğŸš€ æ ¸å¿ƒè¿›åŒ–åŠŸèƒ½

### 1. çœŸå®æ•°æ®é©±åŠ¨ (Schwab API)

ç³»ç»Ÿå·²å®Œå…¨æ‰“é€š **Schwab API**ï¼Œå®æ—¶è·å–ï¼š

* æ ‡çš„ç°ä»·ã€å†å²æ³¢åŠ¨ç‡ (HV) åŠ HV Rankã€‚
* ATM æœŸæƒé“¾ã€éšå«æ³¢åŠ¨ç‡ (IV) æœŸé™ç»“æ„åŠ Greeks (Gamma/Delta/Theta)ã€‚
* è‡ªåŠ¨é”å®šæµåŠ¨æ€§æœ€ä½³çš„ **æœˆåº¦æœŸæƒåˆçº¦ (Monthly OpEx)**ã€‚

### 2. å¢å¼ºå‹é£é™©å¼•æ“ (The Guardian)

* **Total Gamma ç›‘æµ‹**ï¼šè‡ªåŠ¨è®¡ç®—ç»„åˆï¼ˆå¦‚è·¨å¼ç»„åˆ Straddleï¼‰çš„æ€» Gammaï¼Œå¹¶è¿›è¡Œåˆ†çº§ï¼š
* **EXTREME â›”** (Î“ â‰¥ 0.20): æç«¯æ³¢åŠ¨é£é™©ã€‚
* **HIGH âš ï¸** (Î“ â‰¥ 0.12): é«˜é£é™©ï¼Œéœ€å¤§å¹…ç¼©å‡ä»“ä½ã€‚
* **ELEVATED ğŸ”¸** (Î“ â‰¥ 0.08): é¢„è­¦åŒºã€‚


* **PMCC å®‰å…¨é”**ï¼šç¡¬æ€§æ‰§è¡Œ `Debit < Width` æ£€æŸ¥ï¼Œè‡ªåŠ¨æ‹¦æˆªæ³¨å®šäºæŸçš„é”æ­»äº¤æ˜“ï¼ˆLocked Lossï¼‰ï¼Œå¹¶ç»™å‡ºä¿®æ­£å»ºè®®ã€‚

### 3. äº¤æ˜“å‘˜çœ‹æ¿å¼è¾“å‡º

* **Gate çŠ¶æ€åˆ—**ï¼šåœ¨æ‰«æç»“æœä¸­ç›´è§‚æ˜¾ç¤º `âœ… å¯æ‰§è¡Œ`ã€`âš ï¸ é«˜é£é™©`ã€`â›” å·²æ‹’ç»`ã€‚
* **Trader's Sort**ï¼šä¼˜å…ˆæ’åˆ—â€œé«˜ Edgeã€ä½ Riskã€Gate âœ…â€çš„æ ‡çš„ã€‚
* **Actionable Blueprints**ï¼šç”Ÿæˆå«å…·ä½“æ—¥æœŸã€è¡Œæƒä»·ã€æ–¹å‘åŠæˆæœ¬ä¼°ç®—çš„æ‰§è¡Œè“å›¾ã€‚

---

## ğŸ› ï¸ å®‰è£…ä¸é…ç½®

1. **ç¯å¢ƒè¦æ±‚**ï¼šPython 3.8+
2. **å®‰è£…ä¾èµ–**ï¼š
```bash
pip install requests pandas numpy

```


3. **æ•°æ®é…ç½®**ï¼š
* åœ¨ `data/tickers.csv` ä¸­å¡«å…¥ä½ æƒ³æ‰«æçš„è‚¡ç¥¨ä»£ç ï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰ã€‚
* ç¡®ä¿ `src/trade_guardian/infra/schwab_token_manager.py` èƒ½å¤Ÿè·å–æœ‰æ•ˆçš„ API Tokenã€‚



---

## ğŸ“– ä½¿ç”¨æŒ‡å—

### å¯åŠ¨å…¨è‡ªåŠ¨æ‰«æ

```bash
python src/trade_guardian.py scanlist --strategy auto --days 600 --detail --top 5

```

**å‚æ•°è¯´æ˜**ï¼š

* `--strategy auto`: åŒæ—¶è¿è¡Œ Long Gamma (Straddle) å’Œ Diagonal (PMCC) ç­–ç•¥ã€‚
* `--days 600`: æ‰«æè¿œç«¯æœŸæƒé“¾ï¼ˆç”¨äº PMCC å¯»æ‰¾ LEAPSï¼‰ã€‚
* `--detail`: è¾“å‡ºå…·ä½“çš„æ‰§è¡Œè“å›¾ï¼ˆActionable Blueprintsï¼‰ã€‚
* `--top 5`: ç»è¿‡æ’åºåï¼Œåªæ˜¾ç¤ºæœ€ä¼˜è´¨çš„å‰ 5 ä¸ªäº¤æ˜“è®¡åˆ’ã€‚

---

## ğŸ“Š è¾“å‡ºè§£è¯»

### æ‰«æè¡¨ (Scanner View)

| Sym | Px | ShortExp | DTE | ShortIV | Edge | Risk | Gate |
| --- | --- | --- | --- | --- | --- | --- | --- |
| AMD | 202.0 | 2026-01-16 | 29 | 45.2% | +0.13x | 20 | âœ… |
| ONDS | 7.87 | 2026-01-16 | 29 | 120.4% | +0.26x | 70 | âš ï¸ |
| MSTR | 159.2 | 2026-01-16 | 29 | 77.6% | +0.02x | 30 | â›” |

### æ‰§è¡Œè“å›¾ç¤ºä¾‹ (Execution Plan)

```text
 MSTR DIAGONAL    Est.Debit: $55.87
    +1 2026-06-18 111.0  CALL
    -1 2026-01-16 162.0  CALL
    ==============================
    â›” REJECTED: Debit > Width. Excess: $4.87.
    ==============================
    Strategy Gate: Blocked by Risk Policy.
       â€¢ Try buying deeper ITM LEAPS or RAISING Short Strike.

```

---

## ğŸ§¾ è¯Šæ–­æŒ‡æ ‡ (Diagnostics)

* **Avg |Edge|**: å¸‚åœºæ•´ä½“æ³¢åŠ¨ç‡åç¦»å¼ºåº¦ã€‚
* **Cheap Vol (%)**: å¸‚åœºä¸­å¤„äºâ€œä¾¿å®œâ€çŠ¶æ€ï¼ˆIV < HVï¼‰çš„æ ‡çš„æ¯”ä¾‹ï¼Œä½œä¸ºå¤šç©ºæƒ…ç»ªæ¸©åº¦è®¡ã€‚

---

## âš–ï¸ å…è´£å£°æ˜

æœ¬å·¥å…·ä»…ä¾›ç ”ç©¶ä¸å‚è€ƒä½¿ç”¨ï¼Œä¸æ„æˆä»»ä½•æŠ•èµ„å»ºè®®ã€‚æœŸæƒäº¤æ˜“æ¶‰åŠé«˜é£é™©ï¼Œåœ¨ä½¿ç”¨è“å›¾æ‰§è¡Œäº¤æ˜“å‰ï¼Œè¯·åŠ¡å¿…æ ¸å®å®æ—¶æŠ¥ä»·å¹¶è¿›è¡Œä¸ªäººé£é™©è¯„ä¼°ã€‚

---

**Current Version**: 2.0.0 | **Last Updated**: 2025-12-18

================================================================================
FILE_PATH: requirements.txt
================================================================================
requests
pandas
numpy
tabulate
colorama


================================================================================
FILE_PATH: TRADE GUARDIAN è·¯ç”±çŸ©é˜µ.md
================================================================================
**â€œShape Ã— Strategy Ã— Gateâ€ è·¯ç”±çŸ©é˜µ**ï¼ˆTrade Graduation / Tactical Mode ä¸“ç”¨ï¼‰ã€‚
**å…ˆå®šå½¢æ€(Shape)** â†’ **å†å®šç­–ç•¥(Route)** â†’ **å†å®šé—¨æ§›(Gate)** â†’ **æœ€åç»™æ‰§è¡ŒæŒ‡ä»¤**ã€‚

---

# TRADE GUARDIAN è·¯ç”±çŸ©é˜µï¼ˆBrain + Gate ç»Ÿä¸€ç‰ˆï¼‰

## 0) æ ¸å¿ƒè¾“å…¥ï¼ˆç³»ç»Ÿåªçœ‹è¿™å‡ é¡¹ï¼‰

* `em = edge_micro`ï¼ˆå‰ç«¯ç»“æ„ä¼˜åŠ¿ï¼‰
* `ek = edge_month`ï¼ˆåç«¯ç»“æ„ä¼˜åŠ¿ï¼‰
* `short_dte`ï¼ˆçŸ­è…¿ DTEï¼‰
* `regime`ï¼ˆBACKWARDATION / CONTANGO / FLATï¼‰
* `is_squeeze`ï¼ˆmicro_iv > month_iv * 1.05ï¼‰
* `curvature`ï¼ˆSPIKY_FRONT / NORMALï¼‰
* `momentum`ï¼ˆCRUSH / QUIET / TREND / PULSEï¼‰
* `est_gamma`ï¼ˆé£é™©ç¡¬é˜ˆå€¼ï¼‰
* Blueprint æ˜¯å¦æˆåŠŸï¼ˆbp.errorï¼‰

---

## 1) Shape åˆ†ç±»çŸ©é˜µï¼ˆå…ˆæŠŠåœ°å½¢è¯´æ¸…æ¥šï¼‰

æŒ‰ **ä¼˜å…ˆçº§** ä»ä¸Šåˆ°ä¸‹åŒ¹é…ï¼ˆå‘½ä¸­å³åœæ­¢ï¼‰ï¼š

| Priority | Shape        | åˆ¤å®šè§„åˆ™ï¼ˆå»ºè®®æ ‡å‡†ï¼‰                                               | äº¤æ˜“å«ä¹‰               |
| -------: | ------------ | -------------------------------------------------------- | ------------------ |
|        1 | **BACKWARD** | `regime == BACKWARDATION`                                | å€’æŒ‚ï¼Œå–è¿‘ç«¯=è‡ªæ€          |
|        2 | **FFBS**     | `ek >= 0.20 and em < 0.08`                               | å‰ç«¯å¹³ç¨³ã€åç«¯é™¡å³­ï¼šé»„é‡‘å¯¹è§’çº¿    |
|        3 | **SPIKE**    | `is_squeeze == True OR em >= 0.12`ï¼ˆ*ä¸è¦ç”¨ curvature å•ç‹¬è§¦å‘*ï¼‰ | å‰ç«¯æŒ¤å‹/äº‹ä»¶æ³¢ï¼šgamma é£é™©é«˜ |
|        4 | **STEEP**    | `ek >= 0.20`                                             | æ­£å¸¸åç«¯é™¡å³­ï¼Œæœ‰ç»“æ„å¯åƒ       |
|        5 | **MILD**     | `0.15 <= ek < 0.20`                                      | è½»åº¦ç»“æ„ï¼Œè¾¹ç¼˜ä¸€èˆ¬          |
|        6 | **FLAT**     | `ek < 0.15`                                              | ç»“æ„å¹³å¦ï¼Œé çº¯æ³¢åŠ¨          |

> å¤‡æ³¨ï¼šä½ ç°åœ¨è¾“å‡ºé‡Œ NVDAï¼ˆek=0.15ï¼‰åº”è¯¥æ›´åƒ **MILD** è€Œä¸æ˜¯ STEEPã€‚
> SPY é‚£ç§ â€œè¶…çŸ­ç«¯ä½IVå¯¼è‡´ curvature è™šè§¦å‘â€ ä¸åº”ç›´æ¥å˜ SPIKEâ€”â€”SPIKE å¿…é¡»é  em / squeeze ç¡®è®¤ã€‚

---

## 2) Routeï¼ˆç­–ç•¥è·¯ç”±ï¼‰çŸ©é˜µï¼šShape â†’ é€‰å“ªç§ç­–ç•¥

è¿™éƒ¨åˆ†å°±æ˜¯ä½  Brain V5 çš„â€œç»“æ„ä¼˜å…ˆâ€å“²å­¦ + äº¤æ˜“å‘˜ç°å®ï¼š

| Shape        | é»˜è®¤ç­–ç•¥ Route                    | åŸå› ï¼ˆäº¤æ˜“è¯­è¨€ï¼‰                     |
| ------------ | ----------------------------- | ---------------------------- |
| **BACKWARD** | **LGï¼ˆLong Gamma / Straddleï¼‰** | å€’æŒ‚æ—¶å–è¿‘ç«¯é£é™©çˆ†ç‚¸ï¼Œåªèƒ½ä¹° gamma é˜²å®ˆ      |
| **FFBS**     | **DIAGï¼ˆDiagonalï¼‰**            | å‰ç«¯ä½IV + åç«¯é«˜æº¢ä»·ï¼ŒTheta/Vega å·®æœ€è‚¥ |
| **STEEP**    | **DIAG ä¼˜å…ˆ**ï¼ˆè‹¥æ„å»ºå¤±è´¥â†’LGï¼‰         | æœ‰ç»“æ„å¯æ”¶å‰²ï¼Œä¸”å‰ç«¯æœªå¿…å±é™©               |
| **SPIKE**    | **LG ä¼˜å…ˆ**ï¼ˆç‰¹æ®Šæƒ…å†µæ‰ DIAGï¼‰         | å‰ç«¯æŒ¤å‹ï¼ŒçŸ­è…¿ gamma åå™¬æ¦‚ç‡é«˜          |
| **MILD**     | **LG ä¼˜å…ˆ**ï¼ˆé™¤é ek å¾ˆç¨³/ä½ æƒ³åŠ æ¡ä»¶ï¼‰     | ç»“æ„è¾¹ç¼˜ï¼Œåš DIAG æ€§ä»·æ¯”ä¸€èˆ¬            |
| **FLAT**     | **LG**                        | æ²¡ç»“æ„å°±èµŒæ³¢åŠ¨æ‰©å¼                     |

**è¡¥å……ï¼šDIAG æ„å»ºå¤±è´¥å…œåº•**

* `if diagonal.evaluate(ctx) å¤±è´¥ or metaç¼º long_strike` â†’ è‡ªåŠ¨å›è½ **LG**
  ï¼ˆä½ å·²ç»åšäº†ï¼‰

---

## 3) Gateï¼ˆæ”¾è¡ŒçŸ©é˜µï¼‰ï¼šRoute + Shape + Momentum â†’ WAIT / LIMIT / EXEC

Gate æ˜¯ â€œèƒ½ä¸èƒ½åš / æ€ä¹ˆåšâ€ çš„æœ€åè£åˆ¤ï¼Œåˆ†ä¸‰å±‚ï¼š

### 3.1 Hard Killï¼ˆæ— æ¡ä»¶ FORBIDï¼‰

| æ¡ä»¶                        | Gate       |
| ------------------------- | ---------- |
| `bp is None` æˆ– `bp.error` | **FORBID** |
| `est_gamma >= 0.30`       | **FORBID** |
| `momentum == CRUSH`       | **FORBID** |

---

### 3.2 ç»“æ„é—¨æ§›ï¼ˆSoft Gateï¼‰

ä½ ç°åœ¨çš„åº•çº¿å‚æ•°ï¼š

* `MICRO_MIN = 0.10`
* `MONTH_MIN = 0.15`

#### A) å¯¹ LGï¼ˆLong Gammaï¼‰

LG è¦æ±‚â€œå‰ç«¯ä¸èƒ½å¤ªçƒ‚â€ï¼Œå¦åˆ™ä¹°äº†ä¹Ÿæ˜¯ç£¨æŸï¼š

| æ¡ä»¶                                  | Gate     |
| ----------------------------------- | -------- |
| `em < MICRO_MIN AND ek < MONTH_MIN` | **WAIT** |
| å…¶å®ƒ                                  | è¿›å…¥åŠ¨èƒ½åˆ¤å®š   |

#### B) å¯¹ DIAGï¼ˆDiagonalï¼‰â€”â€”æ ¸å¿ƒï¼šçœ‹ ekï¼Œå¾®ç»“æ„è±å… em

| Shape                   | DIAG çš„ç»“æ„è¦æ±‚                            | Gate        |
| ----------------------- | ------------------------------------- | ----------- |
| **FFBS / STEEP**        | `ek >= MONTH_MIN`ï¼ˆè±å… emï¼‰              | è¿›å…¥åŠ¨èƒ½åˆ¤å®š      |
| **å…¶å®ƒï¼ˆFLAT/MILD/SPIKEï¼‰** | `ek >= MONTH_MIN AND em >= MICRO_MIN` | å¦åˆ™ **WAIT** |

---

### 3.3 åŠ¨èƒ½åˆ¤å®šï¼ˆEXEC vs LIMITï¼‰

åŠ¨èƒ½æ¥è‡ªä½ çš„ 15m IV å˜åŒ–ï¼ˆQUIET/TREND/PULSEï¼‰ï¼š

| Momentum          | Gate      | æ‰§è¡Œå«ä¹‰        |
| ----------------- | --------- | ----------- |
| **PULSE / TREND** | **EXEC**  | åŠ¨èƒ½ç¡®ç«‹ï¼šå¯ä»¥ä¸»åŠ¨æˆäº¤ |
| **QUIET**         | **LIMIT** | ç­‰è§¦å‘ï¼šæŒ‚å•æ½œä¼    |

---

## 4) æœ€é‡è¦çš„â€œäº¤æ˜“å‘˜è¡¥ä¸â€ï¼šSPIKE çš„ DIAG é™çº§è§„åˆ™ï¼ˆå¼ºçƒˆå»ºè®®ï¼‰

å› ä¸º SPIKE æ˜¯æœ€å®¹æ˜“æŠŠä½ ç‚¸æ‰çš„å½¢æ€ã€‚

### è§„åˆ™ï¼ˆæ¨èæœ€å°è¡¥ä¸ï¼‰

* å¦‚æœ `tag` æ˜¯ DIAG ä¸” `shape == SPIKE` ä¸” `short_dte <= 7` ä¸” `momentum == QUIET`
  â†’ **å¼ºåˆ¶ WAIT**ï¼ˆä¸å…è®¸ LIMIT è¢«åŠ¨åƒ gamma é£é™©ï¼‰

| æ¡ä»¶                                    | Gate               |
| ------------------------------------- | ------------------ |
| `DIAG & SPIKE & short_dte<=7 & QUIET` | **WAIT**           |
| `DIAG & SPIKE & (TREND/PULSE)`        | **EXEC**ï¼ˆåªæœ‰åŠ¨èƒ½ç¡®è®¤æ‰æ‰“ï¼‰ |

è¿™æ¡ä¼šè®© TSLA/QQQ/TQQQ è¿™ç§ â€œç»“æ„å¥½ä½†å‰ç«¯ä¸å®‰ç¨³â€ ä¸ä¼šå¤©å¤© LIMITã€‚

---

# æœ€ç»ˆæ€»è¡¨ï¼ˆä½ å¯ä»¥è´´ README çš„â€œå†³ç­–æ€»çŸ©é˜µâ€ï¼‰

æŒ‰å®é™…æ‰§è¡Œé¡ºåºï¼š

1. **Hard Kill**ï¼šbp/error, gamma, CRUSH â†’ FORBID
2. **Shape**ï¼šBACKWARD / FFBS / SPIKE / STEEP / MILD / FLAT
3. **Route**ï¼šBACKWARDâ†’LGï¼›FFBS/STEEPâ†’DIAGï¼›SPIKE/MILD/FLATâ†’LGï¼ˆSPIKE ç‰¹åˆ¤ï¼‰
4. **Gate-ç»“æ„**ï¼šDIAG çœ‹ ekï¼ˆFFBS/STEEP è±å… emï¼‰ï¼›LG çœ‹ em/ek åŒä½
5. **Gate-åŠ¨èƒ½**ï¼šTREND/PULSEâ†’EXECï¼›QUIETâ†’LIMIT
6. **SPIKE-DIAG é™çº§è¡¥ä¸**ï¼šSPIKE + DIAG + short_dte<=7 + QUIET â†’ WAIT

---

## å¿«é€Ÿ sanity checkï¼ˆç”¨ä½ å½“å‰è¾“å‡ºéªŒè¯ï¼‰

* **IWMï¼šFFBS + ek=0.24 + em=0.01**
  â†’ Route=DIAGï¼ŒGate ä¸æŸ¥ emï¼ˆè±å…ï¼‰â†’ QUIET â†’ LIMIT âœ…
* **SPYï¼šè¶…çŸ­ç«¯ä½IVï¼Œä½† em ä½ã€ek=0.17ï¼ˆMILDï¼‰**
  â†’ Route=LG â†’ em/ek æ˜¯å¦åŒä½ï¼Ÿä¸åŒä½ â†’ QUIET â†’ LIMITï¼ˆä½†ä½ ä¹Ÿå¯ä»¥è®© MILD é»˜è®¤ WAITï¼‰
* **TSLAï¼šSPIKE + DIAG + QUIET + short_dte=6**
  â†’ ä¼šè¢«â€œSPIKE-DIAG é™çº§è¡¥ä¸â€æ‰“å› WAITï¼ˆé¿å…æŒ‚å•è¢«åŠ¨åƒé£é™©ï¼‰âœ…

---


# ğŸ§  Trade Guardian: Decision Engine Logic

Trade Guardian é‡‡ç”¨ **"Shape-First" (å½¢æ€ä¼˜å…ˆ)** çš„å†³ç­–é€»è¾‘ï¼Œå°†æœŸæƒæœŸé™ç»“æ„æ•°æ®è½¬åŒ–ä¸ºå…·ä½“çš„æˆ˜æœ¯æŒ‡ä»¤ã€‚ç³»ç»Ÿä¸å†å•çº¯ä¾èµ–ç»å¯¹æ³¢åŠ¨ç‡æ•°å€¼ï¼Œè€Œæ˜¯ä¾èµ–**ç›¸å¯¹ç»“æ„ä¼˜åŠ¿**ã€‚

### æ ¸å¿ƒæµç¨‹
`Raw Data` $\to$ `Stabilized Edges` $\to$ `Shape Classifier` $\to$ `Strategy Route` $\to$ `Safety Gate` $\to$ `Action`

---

## 1. æ ¸å¿ƒè¾“å…¥ (Key Inputs)

ä¸ºäº†æ¶ˆé™¤çŸ­ç«¯å™ªéŸ³å¹¶è¿˜åŸçœŸå®åœ°å½¢ï¼Œç³»ç»Ÿåœ¨åŸå§‹æ•°æ®ä¹‹ä¸Šè¿›è¡Œäº†æ•°å­¦ç¨³å®šåŒ–å¤„ç†ï¼š

* **Edge Micro (`em`)**: å‰ç«¯ç»“æ„ä¼˜åŠ¿ã€‚
    * *Stabilizer V3*: é‡‡ç”¨ `1-10 DTE Median Base` æ¶ˆé™¤å•ç‚¹å™ªéŸ³ï¼Œå¹¶å¯¹ `< 6 DTE` è¿›è¡Œè¿ç»­å¹³æ»‘è¡°å‡ã€‚
* **Edge Month (`ek`)**: åç«¯ç»“æ„ä¼˜åŠ¿ã€‚
    * *Anchor*: åŠ¨æ€é”šå®š `30-45 DTE` æˆ˜æœ¯åŒºã€‚
* **Regime**: å¸‚åœºçŠ¶æ€ (`BACKWARDATION` / `CONTANGO` / `FLAT`).
* **Momentum**: 15åˆ†é’Ÿçº§åˆ« IV åŠ¨èƒ½ (`PULSE` / `TREND` / `QUIET` / `CRUSH`).

---

## 2. å½¢æ€åˆ†ç±»çŸ©é˜µ (Shape Matrix)

ç³»ç»ŸæŒ‰ **ä¼˜å…ˆçº§ (Priority)** ä¾æ¬¡è¯†åˆ«ä»¥ä¸‹æœŸé™ç»“æ„å½¢æ€ï¼Œå‘½ä¸­å³åœæ­¢ï¼š

| ä¼˜å…ˆçº§ | å½¢æ€ (Shape) | åˆ¤å®šè§„åˆ™ (ä¼ªä»£ç ) | äº¤æ˜“å«ä¹‰ |
| :---: | :--- | :--- | :--- |
| **1** | **BACKWARD** | `Regime == BACKWARDATION` | **å€’æŒ‚**ã€‚å–æ–¹ç¦åŒºï¼Œé˜²å¾¡æ¨¡å¼ã€‚ |
| **2** | **FFBS** | `ek >= 0.20` & `em < 0.08` | **å‰å¹³åé™¡** (Front-Flat Back-Steep)ã€‚é»„é‡‘å¯¹è§’çº¿å½¢æ€ã€‚ |
| **3** | **SPIKE** | `Squeeze` æˆ– `em >= 0.12` | **å‰ç«¯åˆºå¤´**ã€‚çŸ­æœŸ IV æš´æ¶¨ï¼ŒGamma é£é™©é«˜ã€‚ |
| **4** | **STEEP** | `ek >= 0.20` | **é™¡å³­**ã€‚æ ‡å‡†çš„æœŸé™ç»“æ„å¥—åˆ©æœºä¼šã€‚ |
| **5** | **MILD** | `0.15 <= ek < 0.20` | **æ¸©å’Œ**ã€‚ç»“æ„ä¸€èˆ¬ï¼Œå¤„äºä¸´ç•Œç‚¹ã€‚ |
| **6** | **FLAT** | `ek < 0.15` | **å¹³å¦**ã€‚æ— ç»“æ„ä¼˜åŠ¿ï¼Œçº¯æ³¢åŠ¨ç‡åšå¼ˆã€‚ |

---

## 3. ç­–ç•¥è·¯ç”± (Strategy Route)

åŸºäº **Brain V5 (ç»“æ„ä¼˜å…ˆï¼Œä½æ³¢å…œåº•)** å“²å­¦ï¼š

### ğŸŸ¢ AUTO-DIAG (Diagonal Strategy)
**è§¦å‘é€»è¾‘**ï¼šå½“ç»“æ„ä¼˜åŠ¿æ˜æ˜¾æ—¶è§¦å‘ã€‚
* **é€‚ç”¨å½¢æ€**ï¼š`FFBS`, `STEEP`, æˆ– `edge_month >= 0.20`ã€‚
* **æ ¸å¿ƒæ€æƒ³**ï¼šåªè¦å¡åº¦å¤Ÿé™¡ï¼Œå³ä½¿ç»å¯¹ IV è¾ƒä½ï¼Œä¹Ÿä¼˜å…ˆåˆ©ç”¨æ—¶é—´ä»·å€¼è¡°å‡å·®å¼‚ï¼ˆTheta/Vega Arbï¼‰è·åˆ©ã€‚

### ğŸ”µ AUTO-LG (Long Gamma / Straddle)
**è§¦å‘é€»è¾‘**ï¼šå½“ç»“æ„å¹³åº¸æˆ–æ³¢åŠ¨ç‡æä½æ—¶è§¦å‘ã€‚
* **é€‚ç”¨å½¢æ€**ï¼š`MILD`, `FLAT`, `BACKWARD`, `SPIKE` (é€šå¸¸), æˆ– `HV Rank < 30`ã€‚
* **æ ¸å¿ƒæ€æƒ³**ï¼šæ²¡æœ‰ç»“æ„ä¼˜åŠ¿æ—¶ï¼Œä¹°å…¥è·¨å¼æœŸæƒï¼ˆStraddleï¼‰åšå–æ³¢åŠ¨ç‡å›å½’æˆ–æ–¹å‘æ€§çªç ´ã€‚

---

## 4. å®‰å…¨é—¨é˜€ (Safety Gate V6)

Gate æ˜¯ç³»ç»Ÿçš„æœ€åä¸€é“é˜²çº¿ï¼Œå†³å®šæœ€ç»ˆçŠ¶æ€æ˜¯ `EXEC` (æ‰§è¡Œ)ã€`LIMIT` (æŒ‚å•) è¿˜æ˜¯ `WAIT` (è§‚æœ›)ã€‚

### ğŸ›‘ Hard Kill (ä¸€ç¥¨å¦å†³)
* **Blueprint Error**: å»ºä»“å¤±è´¥æˆ–æ•°æ®ç¼ºå¤± $\to$ `FORBID`
* **Gamma Risk**: `est_gamma >= 0.30` $\to$ `FORBID`
* **Vol Collapse**: `Momentum == CRUSH` $\to$ `FORBID`

### ğŸš§ Structural Gate (ç»“æ„æ”¾è¡Œ)

1.  **DIAG è±å…æƒ (The FFBS Privilege)**:
    * è‹¥å½¢æ€ä¸º **`FFBS`** æˆ– **`STEEP`**ï¼Œ**è±å…**å¯¹ Micro Edge (`em`) çš„æœ€ä½è¦æ±‚ã€‚
    * *ç†ç”±ï¼šæ­¤æ—¶å‰ç«¯è¶Šå¹³è¶Šå¥½ï¼Œä¸éœ€è¦å‰ç«¯æœ‰ Edgeã€‚*

2.  **SPIKE é™çº§ä¿æŠ¤ (Rule #4)**:
    * è‹¥å½¢æ€ä¸º **`SPIKE`** ä¸” `Short DTE <= 7` ä¸”åŠ¨èƒ½ä¸è¶³ (`QUIET`) $\to$ å¼ºåˆ¶ **`WAIT`**ã€‚
    * *ç†ç”±ï¼šå‰ç«¯æŒ¤å‹æ—¶æŒ‚ Limit å•å®¹æ˜“è¢«åŠ¨æˆäº¤å¹¶ç«‹åˆ»é­å— Gamma åå™¬ã€‚*

3.  **LG æ ‡å‡†**:
    * è‹¥ `em` å’Œ `ek` åŒä½ (`< Threshold`) $\to$ **`WAIT`**ã€‚

### ğŸš€ Momentum Gate (æ‰§è¡Œå±‚)

* **`PULSE` / `TREND`**: åŠ¨èƒ½ç¡®ç«‹ $\to$ **`EXEC`** (å»ºè®® Market æˆ– Mid+)
* **`QUIET`**: åŠ¨èƒ½æ²‰å¯‚ $\to$ **`LIMIT`** (å»ºè®® Mid-)

---

## 5. æœ¯è¯­å¯¹ç…§è¡¨

* **S_IV**: Short Leg IV (Base Denominator)
* **EdgM**: Micro Edge (Stabilized Front-end Slope)
* **EdgK**: Month Edge (Stabilized Back-end Slope)
* **Scr**: Score (ç»¼åˆè¯„åˆ†)

================================================================================
FILE_PATH: config\config.json
================================================================================
{
  "paths": {
    "tickers_csv": "data/tickers.csv",
    "cache_dir": "cache"
  },
  "scan": {
    "throttle_sec": 0.5,
    "contract_type": "ALL"
  },
  "rules": {
    "min_edge_short_base": 1.05
  },
  "policy": {
    "base_rank": 1,
    "min_dte": 3,
    "probe_count": 3
  },
  "strategies": {
    "hv_calendar": {
      "hv_rules": {
        "hv_low_rank": 20.0,
        "hv_mid_rank": 50.0,
        "hv_high_rank": 70.0,
        "hv_low_bonus": 10,
        "hv_mid_bonus": 4,
        "hv_high_penalty": -4,
        "hv_extreme_penalty": -10
      }
    }
  }
}

================================================================================
FILE_PATH: src\trade_guardian.py
================================================================================
import time
import sys
import os
from datetime import datetime

# ç¡®ä¿ src ç›®å½•åœ¨è·¯å¾„ä¸­ï¼Œä»¥ä¾¿æ­£ç¡®å¯¼å…¥
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from trade_guardian.app.cli import main

def run_guardian_loop():
    """
    å®ˆæŠ¤è€…æ¨¡å¼ï¼šæ¯ 15 åˆ†é’Ÿè‡ªåŠ¨æ‰§è¡Œä¸€æ¬¡å…¨é‡æ‰«æå¹¶å­˜åº“
    """
    INTERVAL = 15 * 60  # 15 åˆ†é’Ÿ (900ç§’)
    
    print("="*80)
    print(f"ğŸ›¡ï¸  TRADE GUARDIAN - DAEMON MODE ACTIVE")
    print(f"â° Polling Interval: {INTERVAL/60} minutes")
    print(f"ğŸ“‚ Project Root: {project_root}")
    print("="*80)
    
    try:
        while True:
            start_ts = time.time()
            now_str = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            # æ¨¡æ‹Ÿå‘½ä»¤è¡Œå‚æ•°ç»™ cli.main()
            # è¿™é‡Œä½ å¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´é»˜è®¤å‚æ•°
            sys.argv = [
                "trade_guardian.py", 
                "scanlist", 
                "--strategy", "auto", 
                "--days", "600", 
                "--detail",
                "--top", "10" # è‡ªåŠ¨æ¨¡å¼ä¸‹åªæ˜¾ç¤ºæœ€æœ‰ä»·å€¼çš„10ä¸ªè®¡åˆ’
            ]
            
            print(f"\nğŸ”„ [LOOP START] {now_str}")
            
            try:
                # æ‰§è¡ŒåŸæœ‰çš„ cli ä¸»å‡½æ•°
                main()
            except Exception as e:
                print(f"âŒ Session Execution Error: {e}")

            elapsed = time.time() - start_ts
            wait_time = max(0, INTERVAL - elapsed)
            
            next_run = datetime.fromtimestamp(time.time() + wait_time).strftime('%H:%M:%S')
            
            print(f"\nâœ… SESSION COMPLETE. Duration: {elapsed:.2f}s")
            print(f"â³ Sleeping {wait_time/60:.1f} min. Next run at: {next_run} (Ctrl+C to stop)")
            
            time.sleep(wait_time)
            
    except KeyboardInterrupt:
        print("\nğŸ›‘ Guardian daemon stopped by user. exiting...")
        sys.exit(0)

if __name__ == "__main__":
    # é€»è¾‘åˆ¤å®šï¼š
    # 1. å¦‚æœä½ è¾“å…¥ python src/trade_guardian.py scanlist ... (å¸¦å‚æ•°) -> è¿è¡Œä¸€æ¬¡å°±ç»“æŸ
    # 2. å¦‚æœä½ ç›´æ¥è¾“å…¥ python src/trade_guardian.py (ä¸å¸¦å‚æ•°) -> è¿›å…¥15åˆ†é’Ÿè½®è¯¢æ¨¡å¼
    if len(sys.argv) > 1:
        main()
    else:
        run_guardian_loop()

================================================================================
FILE_PATH: src\trade_guardian\__init__.py
================================================================================
__all__ = ["app", "domain", "infra", "strategies"]
__version__ = "0.1.0"


================================================================================
FILE_PATH: src\trade_guardian\app\cli.py
================================================================================
import argparse
import os
import time

from trade_guardian.infra.config import (
    DEFAULT_CONFIG,
    load_config,
    write_config_template,
    merge_config_paths,
    policy_from_cfg_and_cli,
)
from trade_guardian.infra.schwab_client import SchwabClient
from trade_guardian.domain.registry import StrategyRegistry
from trade_guardian.app.orchestrator import TradeGuardian


def main():
    parser = argparse.ArgumentParser("Trade Guardian")
    sub = parser.add_subparsers(dest="cmd", required=True)

    # ---------- initconfig ----------
    p_init = sub.add_parser("initconfig", help="Generate config/config.json template")
    p_init.add_argument("--path", type=str, default=None, help="Output path (default: ./config/config.json)")
    p_init.add_argument("--force", action="store_true", help="Overwrite if exists")

    # ---------- scanlist ----------
    p_scan = sub.add_parser("scanlist", help="Scan tickers.csv and output candidates")
    p_scan.add_argument("--config", type=str, default=None, help="Config path (default: ./config/config.json)")
    p_scan.add_argument("--autogen-config", action="store_true", help="Auto-generate config if missing")
    p_scan.add_argument("--no-autogen-config", action="store_true", help="Disable auto-generate config")

    p_scan.add_argument("--strategy", type=str, default="auto", help="Strategy name (default: auto)")
    p_scan.add_argument("--days", type=int, default=600)
    p_scan.add_argument("--csv", type=str, default=None, help="Tickers csv path")
    p_scan.add_argument("--min-score", type=int, default=60)
    p_scan.add_argument("--max-risk", type=int, default=70)
    p_scan.add_argument("--limit", type=int, default=0)
    p_scan.add_argument("--detail", action="store_true", help="Print blueprints and detailed logic")
    p_scan.add_argument("--top", type=int, default=None, help="Only show top N sorted blueprints")

    # Policy overrides
    p_scan.add_argument("--short-rank", type=int, default=None)
    p_scan.add_argument("--min-short-dte", type=int, default=None)
    p_scan.add_argument("--max-probe-rank", type=int, default=None)

    args = parser.parse_args()

    # å®šä½é¡¹ç›®æ ¹ç›®å½• (cli.py -> app -> trade_guardian -> src -> project_root)
    root = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "..", ".."))

    if args.cmd == "initconfig":
        out = args.path or os.path.join(root, "config", "config.json")
        os.makedirs(os.path.dirname(out), exist_ok=True)
        write_config_template(out, DEFAULT_CONFIG, overwrite=args.force)
        print(f"âœ… Wrote config template: {out}")
        return

    if args.cmd == "scanlist":
        # è®°å½•å¼€å§‹æ—¶é—´ï¼Œç”¨äºæ•°æ®åº“å­˜ç›˜
        start_ts = time.time()

        cfg_path = args.config or os.path.join(root, "config", "config.json")

        # æ£€æŸ¥æ˜¯å¦éœ€è¦è‡ªåŠ¨ç”Ÿæˆé…ç½®
        autogen_default = bool(DEFAULT_CONFIG.get("runtime", {}).get("autogen_config_if_missing", True))
        autogen = autogen_default
        if args.autogen_config: autogen = True
        if args.no_autogen_config: autogen = False

        if autogen and not os.path.exists(cfg_path):
            os.makedirs(os.path.dirname(cfg_path), exist_ok=True)
            write_config_template(cfg_path, DEFAULT_CONFIG, overwrite=False)

        # åŠ è½½ä¸åˆå¹¶è·¯å¾„
        cfg = load_config(cfg_path, DEFAULT_CONFIG)
        cfg = merge_config_paths(cfg, root, args.csv)

        # æ„å»ºç­–ç•¥å’Œå®¢æˆ·ç«¯
        policy = policy_from_cfg_and_cli(cfg, args)
        client = SchwabClient(cfg)
        registry = StrategyRegistry(cfg, policy)
        strategy = registry.get(args.strategy)

        # åˆå§‹åŒ–ä¸»æ§ç¨‹åº
        tg = TradeGuardian(client=client, cfg=cfg, policy=policy, strategy=strategy)
        
        # æ‰§è¡Œæ‰«æ
        # è¿™é‡Œè®¡ç®— elapsed (ç»è¿‡çš„æ—¶é—´)ï¼Œç¡®ä¿æ•°æ®åº“èƒ½è®°å½•è¿™æ¬¡ä»»åŠ¡è·‘äº†å¤šä¹…
        tg.scanlist(
            strategy_name=args.strategy,
            days=args.days,
            min_score=args.min_score,
            max_risk=args.max_risk,
            limit=args.limit,
            detail=args.detail,
            top=args.top,
            elapsed=0.0  # åˆå§‹è®¾ä¸º0ï¼ŒOrchestrator å†…éƒ¨ä¼šè®¡ç®—çœŸå®å€¼æˆ–ç”±è¿™é‡Œä¼ é€’
        )
        return


if __name__ == "__main__":
    main()

================================================================================
FILE_PATH: src\trade_guardian\app\orchestrator.py
================================================================================
from __future__ import annotations
import os
import sys
import time
import pandas as pd
import traceback
from typing import List, Tuple, Optional, Any
from colorama import Fore, Style

from trade_guardian.domain.models import Context, ScanRow, Blueprint, OrderLeg
from trade_guardian.app.persistence import PersistenceManager
from trade_guardian.strategies.blueprint import build_straddle_blueprint 
# [FIX] å¼•å…¥é™æµå™¨
from trade_guardian.infra.rate_limit import RateLimiter

# --- [äº¤æ˜“å‘˜åº•çº¿å‚æ•°] ---
MICRO_MIN = 0.10
MONTH_MIN = 0.15

class TradeGuardian:
    def __init__(self, client, cfg: dict, policy, strategy=None):
        self.client = client
        self.cfg = cfg
        self.policy = policy
        self.strategy = strategy 
        
        # [FIX] P0-2: ä» Config è¯»å–è·¯å¾„ï¼Œä¸å†ç¡¬ç¼–ç 
        self.tickers_path = cfg.get("paths", {}).get("tickers_csv", "data/tickers.csv")
        
        # [FIX] Part 2, Item 5: åˆå§‹åŒ–é™æµå™¨
        throttle = float(cfg.get("scan", {}).get("throttle_sec", 0.5))
        self.limiter = RateLimiter(throttle)
        
        self.db = PersistenceManager()
        self.last_batch_df: Optional[pd.DataFrame] = None 

    def _get_universe(self) -> List[str]:
        if not os.path.exists(self.tickers_path):
            # å°è¯• fallback åˆ°ç›¸å¯¹è·¯å¾„
            fallback = os.path.join("data", "tickers.csv")
            if os.path.exists(fallback):
                self.tickers_path = fallback
            else:
                print(f"\nâŒ [CRITICAL ERROR] Tickers file NOT FOUND at {self.tickers_path}")
                sys.exit(1)
                
        df = pd.read_csv(self.tickers_path, header=None)
        # ç®€å•çš„æ¸…æ´—
        return df[0].dropna().apply(lambda x: str(x).strip().upper()).tolist()

    def scanlist(self, strategy_name: str = "auto", days: int = 600, 
                 min_score: int = 60, max_risk: int = 70, detail: bool = False,
                 limit: int = None, **kwargs):
        
        # [FIX] Issue B: å¼€å§‹è®¡æ—¶
        start_ts = time.time()

        try:
            vix_q = self.client.get_quote("$VIX")
            current_vix = vix_q.get("lastPrice", 0.0) 
        except: current_vix = 0.0
        
        tickers = self._get_universe()
        if limit: tickers = tickers[:limit]

        db_results_pack = []  
        strict_results = [] 
        current_rows_for_next_batch = [] 
        
        # DNA -> Shape (Display Structure Shape)
        FMT = "{sym:<5} {px:<7} {sexp:<11} {sdte:<3} {siv:>6} | {mexp:<11} {mdte:<3} {miv:>6} {em:>5} | {kexp:<11} {kdte:<3} {kiv:>6} {ek:>5} | {sc:>4} {shp:<8} {gate:<6}   {tag:<8}"
        
        HEADER = FMT.format(
            sym="Sym", px="Px", sexp="ShortExp", sdte="D", siv="S_IV",
            mexp="MicroExp", mdte="D", miv="M_IV", em="EdgM",
            kexp="MonthExp", kdte="D", kiv="K_IV", ek="EdgK",
            sc="Scr", shp="Shape", gate="Gate", tag="Tag"
        )
        WIDTH = len(HEADER)

        print("\n" + "=" * WIDTH)
        print(f"ğŸ§  TRADE GUARDIAN :: GRADUATION BUILD | VIX: {current_vix:.2f} | Strategy: {strategy_name}")
        print("-" * WIDTH)
        print(HEADER)
        print("-" * WIDTH)

        for ticker in tickers:
            # [FIX] Part 2, Item 5: å¾ªç¯å†…é™æµ
            self.limiter.sleep()

            try:
                # 1. æ„å»ºä¸Šä¸‹æ–‡
                ctx = self.client.build_context(ticker, days=days)
                if not ctx: continue
                
                # 2. ç­–ç•¥è·¯ç”±
                # [FIX] P0-2: ä¼˜å…ˆä½¿ç”¨ä¼ å…¥çš„ strategy å¯¹è±¡ï¼Œå¦åˆ™æ ¹æ®åç§°åŠ è½½
                current_strategy = self.strategy if self.strategy else self._load_strategy(strategy_name)
                row = current_strategy.evaluate(ctx)
                if not row: continue

                # 3. åŠ¨èƒ½è®¡ç®— (Momentum)
                iv_diff = 0.0
                if self.last_batch_df is not None:
                    prev = self.last_batch_df[self.last_batch_df['symbol'] == row.symbol]
                    if not prev.empty:
                        # è¿™é‡Œçš„æ¯”è¾ƒéå¸¸åŸºç¡€ï¼Œåç»­å¯ä»¥æ”¹ä¸º % change
                        iv_diff = row.short_iv - prev.iloc[0]['iv']
                
                mom_type = "QUIET"
                if iv_diff > 2.0: mom_type = "PULSE"
                elif iv_diff > 0.5: mom_type = "TREND"
                elif iv_diff < -1.0: mom_type = "CRUSH"
                
                row.meta["delta_15m"] = iv_diff
                row.meta["momentum"] = mom_type

                # 4. å½¢æ€åˆ†ç±» (Shape Classifier) - [FIX] P0-3: ä¸¥æ ¼å¯¹é½è·¯ç”±çŸ©é˜µ
                tsf = ctx.tsf or {}
                regime = str(tsf.get("regime", "FLAT"))
                is_squeeze = bool(tsf.get("is_squeeze", False))
                # curvature = str(tsf.get("curvature", "NORMAL")) # çŸ©é˜µè¯´ä¸è¦å•çœ‹è¿™ä¸ª
                
                em = float(row.meta.get("edge_micro", 0) or 0)
                ek = float(row.meta.get("edge_month", 0) or 0)
                
                shape = "FLAT"
                if regime == "BACKWARDATION":
                    shape = "BACKWARD"
                elif ek >= 0.20 and em < 0.08:
                    shape = "FFBS" # é»„é‡‘å¯¹è§’çº¿
                elif is_squeeze or em >= 0.12: # [FIX] çŸ©é˜µè§„åˆ™ï¼šSPIKE å¿…é¡»é  em æˆ– squeeze
                    shape = "SPIKE"
                elif ek >= 0.20: # [FIX] çŸ©é˜µè§„åˆ™ï¼šSTEEP >= 0.20
                    shape = "STEEP"
                elif 0.15 <= ek < 0.20: # [FIX] çŸ©é˜µè§„åˆ™ï¼šMILD åŒºé—´
                    shape = "MILD"
                else:
                    shape = "FLAT"
                
                row.meta["shape"] = shape
                
                # 5. è·å–è“å›¾
                bp = getattr(row, 'blueprint', None)
                if not bp:
                    bp = self.plan(ctx, row) 
                
                # 6. é£æ§é—¨æ§› (Gate V6)
                gate = self._get_gate_status(row, bp, mom_type) 
                
                db_results_pack.append((row, ctx, bp, gate)) 
                current_rows_for_next_batch.append({'symbol': row.symbol, 'iv': row.short_iv})
                
                if gate != "FORBID":
                    strict_results.append((row, ctx, bp, gate, mom_type))

                # 7. æ‰“å°
                if gate == "EXEC": g_color = Fore.GREEN
                elif gate == "LIMIT": g_color = Fore.CYAN
                elif gate == "FORBID": g_color = Fore.RED
                else: g_color = Fore.YELLOW
                
                gate_display = f"{g_color}{gate:<6}{Style.RESET_ALL}"
                
                # Tag å¯èƒ½ä¸ºç©ºçš„å¤„ç†
                tag_str = str(row.tag) if row.tag else ""

                print(FMT.format(
                    sym=row.symbol,
                    px=f"{row.price:.1f}",
                    sexp=row.short_exp,
                    sdte=row.short_dte,
                    siv=f"{int(row.short_iv)}%",
                    mexp=str(row.meta.get("micro_exp", "N/A")),
                    mdte=str(row.meta.get("micro_dte", 0)),
                    miv=f"{int(row.meta.get('micro_iv', 0))}%",
                    em=f"{em:.2f}",
                    kexp=str(row.meta.get("month_exp", "N/A")),
                    kdte=str(row.meta.get("month_dte", 0)),
                    kiv=f"{int(row.meta.get('month_iv', 0))}%",
                    ek=f"{ek:.2f}",
                    sc=row.cal_score,
                    shp=shape, 
                    gate=gate_display, 
                    tag=tag_str
                ))

            except Exception as e:
                print(f"âŒ CRASH on {ticker}: {e}")
                # traceback.print_exc() 
                continue

        # [FIX] (A) æ ¸å¿ƒä¿®å¤ï¼šæ›´æ–° last_batch_dfï¼Œå¦åˆ™åŠ¨èƒ½(Momentum)æ°¸è¿œç®—ä¸å‡ºæ¥
        if current_rows_for_next_batch:
            self.last_batch_df = pd.DataFrame(current_rows_for_next_batch)
        
        # è®¡ç®—ç»Ÿè®¡æŒ‡æ ‡ (ä¿æŒä½ ä¹‹å‰çš„ç»Ÿè®¡é€»è¾‘)
        elapsed = time.time() - start_ts
        valid_rows = [item[0] for item in db_results_pack]
        avg_abs_edge = 0.0
        cheap_vol_pct = 0.0
        
        if valid_rows:
            total_abs_edge = sum(abs(r.edge) for r in valid_rows)
            avg_abs_edge = total_abs_edge / len(valid_rows)
            cheap_count = sum(1 for r in valid_rows if r.edge > 0)
            cheap_vol_pct = cheap_count / len(valid_rows)

        # ä¿å­˜ä¼šè¯
        self.db.save_scan_session(
            strategy_name, 
            current_vix, 
            len(tickers), 
            avg_abs_edge, 
            cheap_vol_pct, 
            elapsed, 
            db_results_pack
        )
        
        if detail and strict_results:
            print(f"\nğŸš€ Actionable Blueprints (Tactical Mode)")
            print("-" * WIDTH)
            for row, ctx, bp, gate, dna in strict_results:
                self._print_enhanced_blueprint(bp, row, dna, gate)
        print("-" * WIDTH)

    def _get_gate_status(self, row: ScanRow, bp: Optional[Blueprint], dna_type: str) -> str:
        est_gamma = row.meta.get("est_gamma", 0.0)
        
        # --- Layer 1: Hard Kill (ç»å¯¹é£æ§) ---
        if not bp or bp.error: return "FORBID"
        if est_gamma >= 0.30: return "FORBID" 
        if dna_type == "CRUSH": return "FORBID" 
        
        em = row.meta.get("edge_micro", 0)
        ek = row.meta.get("edge_month", 0)
        shape = row.meta.get("shape", "FLAT")
        tag = row.tag or ""
        short_dte = row.short_dte
        
        # --- Layer 2: Strategy & Shape Gate (ç»“æ„é—¨æ§›) ---
        
        if "DIAG" in tag:
            # [DIAG æ ¸å¿ƒ] çœ‹åç«¯ç»“æ„ (ek)
            if ek < MONTH_MIN:
                return "WAIT"
            
            # [å½¢æ€ç‰¹åˆ¤]
            # A. FFBS / STEEP: å®Œç¾å½¢æ€ï¼Œè±å…å‰ç«¯å¾®ç»“æ„è¦æ±‚ (em)
            if shape in ["FFBS", "STEEP"]:
                pass 
            
            # B. SPIKE: å‰ç«¯æŒ¤å‹ï¼Œé£é™©æé«˜ -> é™çº§ä¿æŠ¤ (Rule #4)
            elif shape == "SPIKE":
                if short_dte <= 7 and dna_type == "QUIET":
                    return "WAIT"
                # å¦‚æœæ˜¯ SPIKE ä½† em æå·® (ç†è®ºä¸Š SPIKE em åº”è¯¥é«˜ï¼Œè¿™é‡Œæ˜¯å…œåº•)
                if em < MICRO_MIN:
                    return "WAIT"

            # C. å…¶ä»–å½¢æ€ (FLAT/MILD): å¿…é¡»åŒè¾¹è¾¾æ ‡
            else:
                if em < MICRO_MIN:
                    return "WAIT"

        else:
            # [LG æ ¸å¿ƒ] å‰ç«¯ä¸èƒ½å¤ªçƒ‚ï¼Œæˆ–è€…çº¯åšä½æ³¢
            # å¦‚æœ em å’Œ ek åŒä½ï¼Œä¸”æ²¡æœ‰ç‰¹æ®ŠåŸå› ï¼ŒWAIT
            if em < MICRO_MIN and ek < MONTH_MIN:
                return "WAIT"

        # --- Layer 3: Momentum Gate (åŠ¨èƒ½æ‰§è¡Œ) ---
        if dna_type in ["PULSE", "TREND"]:
            return "EXEC"
        else:
            return "LIMIT"
        

    def plan(self, ctx: Context, row: ScanRow) -> Optional[Blueprint]:
        bp = build_straddle_blueprint(
            symbol=ctx.symbol,
            underlying=ctx.price,
            chain=ctx.raw_chain,
            exp=row.short_exp
        )
        if bp:
            bp.note = "Fallback Gamma Plan"
            return bp
        return Blueprint(ctx.symbol, "STRADDLE", [], 0.0, "Build Failed", error="No Pricing Data")

    def _print_enhanced_blueprint(self, bp: Blueprint, row: ScanRow, dna: str, gate: str):
        tactic = ""
        if gate == "LIMIT":
            tactic = f"{Fore.CYAN}[æŒ‚å•æ½œä¼] Limit @ Mid-$0.05 | ç­‰å¾… DNA æ¿€æ´»{Style.RESET_ALL}"
        elif gate == "EXEC":
            tactic = f"{Fore.GREEN}[ç«‹å³æ‰§è¡Œ] Market/Mid+$0.02 | åŠ¨èƒ½ç¡®ç«‹{Style.RESET_ALL}"
        elif gate == "WAIT":
             tactic = f"{Fore.YELLOW}[ä¿æŒå…³æ³¨] å°šæœªè¾¾åˆ°å…¥åœºæ ‡å‡†{Style.RESET_ALL}"

        print(f" {Fore.WHITE}{bp.symbol:<5} | Gate: {gate:<5} | Debit: ${bp.est_debit} | Gamma: {row.meta.get('est_gamma', 0):.4f}")
        print(f"    Edges: Micro {row.meta.get('edge_micro', 0):.2f} / Month {row.meta.get('edge_month', 0):.2f}")
        
        shape = row.meta.get("shape", "")
        mom = row.meta.get("momentum", "QUIET")
        print(f"    Shape: {shape:<8} | Momentum: {mom}")
        
        if "DIAG" in (row.tag or "") and shape == "FFBS":
            print(f"    âœ… {Fore.GREEN}FFBS (Front-Flat Back-Steep): å®Œç¾å¯¹è§’çº¿å½¢æ€ï¼Œå‰ç«¯å®‰ç¨³ï¼Œåç«¯é«˜æº¢ä»·ã€‚{Style.RESET_ALL}")
        
        print(f"    ğŸ‘‰ {tactic}")
        
        if bp.legs:
            for leg in bp.legs:
                action_sym = '+' if leg.action == 'BUY' else '-'
                print(f"       {action_sym}{leg.ratio} {leg.exp} {leg.strike:<6} {leg.type}")
        else:
            print(f"       [ERROR] No Legs: {bp.error}")
        print(f"    {'='*80}")

    def _load_strategy(self, name: str):
        # [FIX] å¦‚æœéœ€è¦åŠ¨æ€åŠ è½½ï¼Œè¿™é‡Œä½¿ç”¨ Registry ä¼šæ›´å¥½ï¼Œä½†æš‚æ—¶ä¿æŒåŸæ ·ä»¥æœ€å°åŒ–æ”¹åŠ¨
        from trade_guardian.strategies.auto import AutoStrategy
        return AutoStrategy(self.cfg, self.policy)

================================================================================
FILE_PATH: src\trade_guardian\app\persistence.py
================================================================================
import sqlite3
import os
from datetime import datetime

class PersistenceManager:
    def __init__(self, db_path=None):
        # [FIX] (C) è·¯å¾„é”šå®šï¼šæ— è®ºåœ¨å“ªé‡Œè¿è¡Œï¼Œéƒ½å®šä½åˆ°é¡¹ç›®æ ¹ç›®å½•ä¸‹çš„ db æ–‡ä»¶å¤¹
        if db_path:
            self.db_path = db_path
        else:
            # å½“å‰æ–‡ä»¶åœ¨ src/trade_guardian/app/
            base_dir = os.path.dirname(os.path.abspath(__file__))
            # å›é€€ 3 å±‚åˆ°é¡¹ç›®æ ¹ç›®å½• (src/trade_guardian/app -> src/trade_guardian -> src -> root)
            project_root = os.path.abspath(os.path.join(base_dir, "..", "..", ".."))
            self.db_path = os.path.join(project_root, "db", "trade_guardian.db")

        # ç¡®ä¿å­˜æ”¾ç›®å½•å­˜åœ¨
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)


    # [FIX] Issue B: æ¥æ”¶ç»Ÿè®¡å‚æ•° (avg_edge, cheap_vol, elapsed)
    def save_scan_session(self, strategy_name, vix, count, avg_edge, cheap_vol, elapsed, results_pack):
        """ä¿å­˜å•æ¬¡æ‰«æçš„æ‰€æœ‰ç»“æœ"""
        conn = sqlite3.connect(self.db_path)
        c = conn.cursor()
        
        try:
            # [FIX] (B) æ—¶é—´æ ¼å¼ä¿®å¤ï¼šSQLite å¯¹ ISO 8601 (å¸¦T) æ”¯æŒä¸å¥½ï¼Œæ”¹ç”¨ç©ºæ ¼åˆ†éš”
            current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            c.execute("""INSERT INTO scan_batches 
                      (timestamp, strategy_name, market_vix, universe_size, avg_abs_edge, cheap_vol_pct, elapsed_time) 
                      VALUES (?, ?, ?, ?, ?, ?, ?)""",
                      (current_time, strategy_name, vix, count, avg_edge, cheap_vol, elapsed))
            batch_id = c.lastrowid
            
            for item in results_pack:
                row, ctx, bp, gate = item
                
                # [FIX] (D) è¡¥å…¨å­—æ®µï¼šå†™å…¥ hv_rank å’Œ regimeï¼Œé˜²æ­¢æ•°æ®ä¸¢å¤±
                # æ³¨æ„ï¼šè¿™é‡Œéœ€è¦ create_tg_db.py é‡Œ market_snapshots è¡¨ç»“æ„é…åˆ (ä½ ä¹‹å‰çš„ schema å·²ç»æœ‰äº†)
                c.execute("""INSERT INTO market_snapshots 
                          (batch_id, symbol, price, iv_short, iv_base, edge, hv_rank, regime) 
                          VALUES (?, ?, ?, ?, ?, ?, ?, ?)""",
                          (batch_id, row.symbol, row.price, row.short_iv, row.base_iv, row.edge, row.hv_rank, row.regime))
                snap_id = c.lastrowid
                
                tag_val = row.tag 
                est_gamma = row.meta.get("est_gamma", 0.0)
                est_debit = bp.est_debit if bp else 0.0
                strat_name = bp.strategy if bp else "NONE"
                
                c.execute("""INSERT INTO trade_plans 
                          (snapshot_id, strategy_type, cal_score, short_risk, gate_status, est_debit, total_gamma, tag) 
                          VALUES (?, ?, ?, ?, ?, ?, ?, ?)""",
                          (snap_id, strat_name, row.cal_score, row.short_risk, gate, est_debit, est_gamma, tag_val))
                
            conn.commit()
            print(f"ğŸ’¾ [DB] Saved Batch {batch_id}: {count} items | AvgEdge: {avg_edge:.2f} | Time: {elapsed:.1f}s")
            
        except Exception as e:
            import traceback
            traceback.print_exc()
            print(f"âŒ [DB Error] Save failed: {e}")
        finally:
            conn.close()

================================================================================
FILE_PATH: src\trade_guardian\app\renderer.py
================================================================================
from __future__ import annotations
import os
from typing import List, Optional, Any
from trade_guardian.domain.models import ScanRow

# === 1. å®šä¹‰é¢œè‰²ä»£ç  ===
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    WARNING = '\033[93m' # é»„è‰²
    FAIL = '\033[91m'    # çº¢è‰²
    ENDC = '\033[0m'     # é‡ç½®é¢œè‰²
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

# è®© Windows ç»ˆç«¯æ”¯æŒ ANSI é¢œè‰²
os.system('')

class ScanlistRenderer:
    def __init__(self, cfg=None, policy=None, hv_cache_path: Optional[str] = None):
        self.cfg = cfg
        self.policy = policy
        self.hv_cache_path = hv_cache_path

    def _sanitize_int(self, value: Any, default: int = 0) -> int:
        """é˜²å¾¡æ€§ç¼–ç¨‹ï¼šç¡®ä¿è¿”å›çš„ä¸€å®šæ˜¯ int"""
        try:
            if isinstance(value, int): return value
            if isinstance(value, str) and value.isdigit(): return int(value)
            if isinstance(value, list): return self._sanitize_int(value[0], default) if value else default
            return default
        except:
            return default

    # [ä¸»æ¸²æŸ“å…¥å£]
    def render(self, 
               strict: List[ScanRow], 
               auto_adjusted: List[ScanRow], 
               watch: List[ScanRow], 
               days: int, 
               min_score: int = 0, 
               max_risk: int = 100, 
               detail: bool = False, 
               universe_size: int = 0,
               top: Any = 0, 
               **kwargs): # åæ‰æ‰€æœ‰æœªå®šä¹‰çš„å‚æ•°
        
        # æ¸…ç† top å‚æ•°
        safe_top = self._sanitize_int(top, 0)
        
        # æ‰“å°å¤´éƒ¨ä¿¡æ¯
        print("")
        print("=" * 95)
        print(f"ğŸ§  {Colors.HEADER}TRADE GUARDIAN :: SCANLIST (days={days}){Colors.ENDC}")
        print("=" * 95)
        
        # ç»Ÿè®¡ä¿¡æ¯
        adjusted_list = auto_adjusted if auto_adjusted else []
        total = universe_size if universe_size > 0 else (len(strict) + len(adjusted_list) + len(watch))
        
        print(f"Universe size: {total} | Strict: {len(strict)} | AutoAdjusted: {len(adjusted_list)} | Watch: {len(watch)} | Errors: 0")
        print(f"Strict Filter: score >= {min_score}, short_risk <= {max_risk}")
        if self.hv_cache_path:
            print(f"Throttle: 0.50s/ticker | HV cache: {self.hv_cache_path}")
        
        # æ‰“å°è¡¨æ ¼
        if strict:
            self._print_table(f"âœ… {Colors.GREEN}Strict Candidates (actionable now){Colors.ENDC}", strict)
            if detail:
                self._print_details("Top details (per-row explain)", strict)
                # æ‰“å°è“å›¾ (å»æ‰äº† Strategy #3 çš„æ–‡å­—)
                self._print_blueprints(f"ğŸš€ {Colors.CYAN}Actionable Blueprints{Colors.ENDC}", strict)

        if adjusted_list:
            self._print_table("ğŸ¤– Auto-Adjusted Candidates", adjusted_list)

        if watch:
            self._print_table("ğŸ‘€ Watchlist", watch)

    # [è¯Šæ–­ä¿¡æ¯å…¥å£]
    def render_diagnostics(self, strict: List[ScanRow], **kwargs):
        if not strict: return

        print(f"\nğŸ§¾ Diagnostics")
        avg_score = sum(r.cal_score for r in strict) / len(strict)
        
        # è®¡ç®—å¹³å‡ Edge
        valid_edges = [r.edge for r in strict if r.edge > 0]
        avg_edge = sum(valid_edges) / len(valid_edges) if valid_edges else 0.0
        
        print(f"   â€¢ Avg Score: {avg_score:.1f} | Avg Edge: {avg_edge:.2f}x")

    # [å†…éƒ¨ helper] æ‰“å°è¡¨æ ¼
    def _print_table(self, title: str, rows: List[ScanRow]):
        if not rows: return
        if title: print(f"\n{title}")
        
        header = f"{'Sym':<6} {'Px':<7} {'ShortExp':<10} {'ShortDTE':>8} {'ShortIV':>8} {'BaseIV':>8} {'Edge':>7} {'HV%':>5} {'Score':>7} {'Risk':>6} {'Tag':<11}"
        print(header)
        print("-" * len(header))
        
        for r in rows:
            # IV ä¿®æ­£ï¼šé™¤ä»¥ 100
            short_iv_val = r.short_iv / 100.0
            base_iv_val = r.base_iv / 100.0
            
            row_str = (
                f"{r.symbol:<6} "
                f"{r.price:<7.2f} "
                f"{r.short_exp:<10} "
                f"{r.short_dte:>8} "
                f"{short_iv_val:>8.1%} "
                f"{base_iv_val:>8.1%} "
                f"{r.edge:>6.2f}x "
                f"{r.hv_rank:>4.0f}% "
                f"{r.cal_score:>7} "
                f"{r.short_risk:>6} "
                f"{r.tag:<11}"
            )
            print(row_str)

    # [å†…éƒ¨ helper] æ‰“å°è¯¦æƒ…
    def _print_details(self, title: str, rows: List[ScanRow]):
        print(f"\n{title}")
        print("Explain legend")
        print("  score parts: b=base, rg=regime, ed=edge, hv=HV-rank slot, cv=curvature, pen=penalties")
        print("  risk  parts: b=base, dte=time-to-expiry, gm=gamma proxy, cv=curvature risk, rg=regime risk, pen=penalties")
        
        for r in rows:
            bd = r.score_breakdown
            rbd = r.risk_breakdown
            print(f"\n  {Colors.BOLD}{r.symbol:<6}{Colors.ENDC} score={r.cal_score:<3} [b{bd.base:+} rg{bd.regime:+} ed{bd.edge:+} hv{bd.hv:+} cv{bd.curvature:+} pen{bd.penalties:+}] | edge={r.edge:.2f}x tag={r.tag} hv={r.hv_rank:.0f}%")
            print(f"         risk={r.short_risk:<3} [b{rbd.base:+} dte{rbd.dte:+} gm{rbd.gamma:+} cv{rbd.curvature:+} rg{rbd.regime:+}] | short={r.short_exp} d{r.short_dte}")

    # [å†…éƒ¨ helper] æ‰“å°è“å›¾ (åŒ…å« Greeks)
    def _print_blueprints(self, title: str, rows: List[ScanRow]):
        valid_rows = [r for r in rows if getattr(r, 'blueprint', None)]
        if not valid_rows: return

        print(f"\n{title}")
        print("-" * 95)
        for r in valid_rows:
            bp = r.blueprint
            
            # æ‘˜è¦è¡Œ
            line = bp.one_liner()
            if "est_debit=" in line:
                parts = line.split("est_debit=")
                line = f"{parts[0]}{Colors.CYAN}est_debit={parts[1]}{Colors.ENDC}"
            print(f"  {line}")
            
            # Note è¡Œ
            note = getattr(bp, "note", "")
            if note:
                if "WARNING" in note or "Risk" in note:
                    print(f"    Note: {Colors.FAIL}{note}{Colors.ENDC}")
                elif "Healthy" in note:
                    print(f"    Note: {Colors.GREEN}{note}{Colors.ENDC}")
                else:
                    print(f"    Note: {note}")

            # è…¿éƒ¨è¯¦æƒ… (å¸¦ Greeks)
            if hasattr(bp, "short_exp") and hasattr(bp, "long_exp"):
                # Diagonal / PMCC / Calendar
                if hasattr(bp, "short_strike") and hasattr(bp, "long_strike"):
                     # PMCC
                     s_delta = bp.short_greeks.get("delta", 0) if getattr(bp, "short_greeks", None) else 0
                     l_delta = bp.long_greeks.get("delta", 0) if getattr(bp, "long_greeks", None) else 0
                     print(f"    Legs: +{bp.long_exp} ({bp.long_strike}C) [Î”{l_delta:.2f}]")
                     print(f"          -{bp.short_exp} ({bp.short_strike}C) [Î”{s_delta:.2f}]")
                else:
                     # Calendar
                     print(f"    Legs: -{bp.short_exp} / +{bp.long_exp} @ Strike {bp.strike}")
            
            elif hasattr(bp, "exp"):
                # Straddle
                atm_gamma = bp.greeks.get("gamma", 0) if getattr(bp, "greeks", None) else 0
                atm_delta = bp.greeks.get("delta", 0) if getattr(bp, "greeks", None) else 0
                print(f"    Legs: +{bp.exp} CALL & PUT @ Strike {bp.strike} [Î”{atm_delta:.2f} Î“{atm_gamma:.3f}]")
            
            else:
                print(f"    Legs: (Unknown structure)")

        print("-" * 95)
        print("")

================================================================================
FILE_PATH: src\trade_guardian\app\__init__.py
================================================================================


================================================================================
FILE_PATH: src\trade_guardian\domain\features.py
================================================================================
from __future__ import annotations

from typing import Dict, List

from trade_guardian.domain.models import HVInfo, TermPoint
from trade_guardian.domain.policy import ShortLegPolicy


class TSFeatureBuilder:
    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy

    @staticmethod
    def _eligible_points(term: List[TermPoint], min_dte: int) -> List[TermPoint]:
        return [p for p in term if p.dte >= min_dte]

    @staticmethod
    def _baseline_iv(term: List[TermPoint], fallback_iv: float) -> float:
        mids = [p.iv for p in term if 30 <= p.dte <= 90 and p.iv > 0]
        if mids:
            return float(sum(mids) / len(mids))
        return float(fallback_iv)

    def build(self, term: List[TermPoint], hv: HVInfo, rank: int) -> Dict[str, object]:
        if not term:
            return {"status": "Error", "msg": "Empty term structure"}

        eligible = self._eligible_points(term, self.policy.min_dte)
        if not eligible:
            return {"status": "Error", "msg": f"No eligible expiries (min_dte={self.policy.min_dte})"}

        if rank < 0 or rank >= len(eligible):
            return {"status": "Error", "msg": f"Rank out of range: rank={rank} eligible={len(eligible)}"}

        short = eligible[rank]
        base_iv = self._baseline_iv(term, fallback_iv=short.iv)

        # regime: compare base vs short
        if base_iv > short.iv * 1.03:
            regime = "CONTANGO"
        elif short.iv > base_iv * 1.03:
            regime = "BACKWARDATION"
        else:
            regime = "FLAT"

        # curvature: compare rank0 (nearest eligible) vs short
        front = eligible[0]
        squeeze_ratio = (front.iv / base_iv) if base_iv > 0 else 0.0

        # spiky front when rank0 materially richer than short rank
        curv = "SPIKY_FRONT" if (front.iv > short.iv * 1.20 and front.dte < 14) else "NORMAL"

        edge = (short.iv / base_iv) if base_iv > 0 else 0.0

        return {
            "status": "Success",
            "regime": regime,
            "curvature": curv,
            "short_exp": short.exp,
            "short_dte": short.dte,
            "short_iv": short.iv,
            "base_iv": base_iv,
            "edge": edge,
            "squeeze_ratio": squeeze_ratio,
        }


================================================================================
FILE_PATH: src\trade_guardian\domain\hv.py
================================================================================
from __future__ import annotations

from trade_guardian.domain.models import HVInfo
from trade_guardian.infra.cache import JsonDailyCache
from trade_guardian.infra.schwab_client import SchwabClient


class HVService:
    def __init__(self, client: SchwabClient, cache: JsonDailyCache):
        self.client = client
        self.cache = cache

    def get_hv(self, symbol: str) -> HVInfo:
        cached = self.cache.get(symbol)
        if cached:
            return HVInfo(**cached)

        hv = self.client.calculate_hv_percentile(symbol)
        # store even if partial to avoid repeated API spam
        self.cache.set(symbol, hv.__dict__)
        return hv


================================================================================
FILE_PATH: src\trade_guardian\domain\models.py
================================================================================
from __future__ import annotations
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any

# --- åŸºç¡€è®¾æ–½ç±» (ç”¨äº SchwabClient ç­‰) ---

@dataclass
class HVInfo:
    """Historical Volatility Data Container"""
    current_hv: float = 0.0
    hv_rank: float = 0.0
    hv_percentile: float = 0.0
    high_52w: float = 0.0
    low_52w: float = 0.0
    status: str = "Success"
    msg: str = ""
    hv_low: float = 0.0
    hv_high: float = 0.0
    p50: float = 0.0
    p75: float = 0.0
    p90: float = 0.0

@dataclass
class TermPoint:
    """Term Structure Point (ç”¨äº term structure è®¡ç®—)"""
    exp: str = "" 
    exp_date: str = "" 
    dte: int = 0
    iv: float = 0.0
    strike: float = 0.0
    mark: float = 0.0
    delta: float = 0.0
    theta: float = 0.0
    gamma: float = 0.0

# --- æ ¸å¿ƒåˆ†æç±» ---

@dataclass
class IVData:
    rank: float = 0.0
    percentile: float = 0.0
    current_iv: float = 0.0
    hv_rank: float = 0.0
    current_hv: float = 0.0

@dataclass
class Context:
    symbol: str
    price: float
    iv: IVData
    hv: IVData
    tsf: dict  # Term Structure Factors
    raw_chain: dict
    metrics: Any = None 
    # [FIX] P0-1: å¢åŠ  term å­—æ®µï¼Œé˜²æ­¢ Calendar ç­–ç•¥æŠ¥é”™
    term: List[TermPoint] = field(default_factory=list) 

@dataclass
class ScoreBreakdown:
    base: int = 0
    regime: int = 0
    edge: int = 0
    hv: int = 0
    curvature: int = 0
    penalties: int = 0

@dataclass
class RiskBreakdown:
    base: int = 0
    dte: int = 0
    gamma: int = 0
    regime: int = 0
    curvature: int = 0
    penalties: int = 0

@dataclass
class ScanRow:
    symbol: str
    price: float
    short_exp: str
    short_dte: int
    short_iv: float
    base_iv: float
    edge: float
    hv_rank: float
    regime: str
    curvature: str
    tag: str
    cal_score: int
    short_risk: int
    score_breakdown: ScoreBreakdown
    risk_breakdown: RiskBreakdown
    meta: Dict[str, Any] = field(default_factory=dict)
    # å…è®¸åŠ¨æ€æŒ‚è½½ blueprint
    blueprint: Optional[Blueprint] = None

@dataclass
class Recommendation:
    strategy: str
    symbol: str
    action: str
    rationale: str
    entry_price: float
    score: int
    conviction: str
    meta: dict

# --- æ‰§è¡Œè“å›¾ç±» (Orchestrator éœ€è¦) ---

@dataclass
class OrderLeg:
    """å®šä¹‰æœŸæƒç­–ç•¥çš„ä¸€æ¡è…¿"""
    symbol: str
    action: str      # BUY / SELL
    ratio: int       # e.g. 1
    exp: str         # Expiry Date (YYYY-MM-DD)
    strike: float
    type: str        # CALL / PUT

@dataclass
class Blueprint:
    """å®šä¹‰æœ€ç»ˆç”Ÿæˆçš„æ‰§è¡Œè“å›¾"""
    symbol: str
    strategy: str
    legs: List[OrderLeg] = field(default_factory=list)
    est_debit: float = 0.0
    note: str = ""
    gamma_exposure: float = 0.0
    error: Optional[str] = None
    # å…è®¸åŠ¨æ€æŒ‚è½½ greeks å­—å…¸
    short_greeks: Dict[str, float] = field(default_factory=dict)
    long_greeks: Dict[str, float] = field(default_factory=dict)
    greeks: Dict[str, float] = field(default_factory=dict)

    def one_liner(self) -> str:
        return f"{self.symbol} {self.strategy} | est_debit={self.est_debit}"

================================================================================
FILE_PATH: src\trade_guardian\domain\policy.py
================================================================================
from dataclasses import dataclass
from typing import List


@dataclass(frozen=True)
class ShortLegPolicy:
    base_rank: int = 1
    min_dte: int = 3
    max_probe_rank: int = 3  # count, e.g. 3 => ranks base..base+2

    def probe_ranks(self) -> List[int]:
        if self.max_probe_rank <= 1:
            return [self.base_rank]
        return list(range(self.base_rank, self.base_rank + self.max_probe_rank))


================================================================================
FILE_PATH: src\trade_guardian\domain\registry.py
================================================================================
from __future__ import annotations

from trade_guardian.domain.policy import ShortLegPolicy

from trade_guardian.strategies.auto import AutoStrategy  # <--- æ–°å¢
from trade_guardian.strategies.calendar import CalendarStrategy
from trade_guardian.strategies.hv_calendar import HVCalendarStrategy
from trade_guardian.strategies.long_gamma import LongGammaStrategy
from trade_guardian.strategies.diagonal import DiagonalStrategy



class StrategyRegistry:
    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy

    def get(self, name: str):
        n = (name or "").strip().lower()

        if n in ("calendar", "cal"):
            return CalendarStrategy(self.cfg, self.policy)

        if n in ("hv_calendar", "hvcal", "hv"):
            return HVCalendarStrategy(self.cfg, self.policy)
            
        if n in ("long_gamma", "gamma", "straddle", "lg"):
            return LongGammaStrategy(self.cfg, self.policy)
        
        if n in ("diagonal", "pmcc", "diag"):
            return DiagonalStrategy(self.cfg, self.policy)
        
        # æ³¨å†Œ auto
        if n in ("auto", "smart", "default"):
            return AutoStrategy(self.cfg, self.policy)
        
        # [FIX] Minor: ä¿®æ­£æŠ¥é”™ä¿¡æ¯ï¼ŒåŒ…å« diagonal å’Œ auto
        raise KeyError(f"Unknown strategy: {name}. Available: calendar, hv_calendar, long_gamma, diagonal, auto")

================================================================================
FILE_PATH: src\trade_guardian\domain\scoring.py
================================================================================
from __future__ import annotations

from dataclasses import dataclass

from trade_guardian.domain.models import ScoreBreakdown


@dataclass(frozen=True)
class ScoringRules:
    # core
    min_edge_short_base: float = 1.05

    # HV-aware (Strategy #2)
    hv_enabled: bool = False
    hv_low_rank: float = 20.0
    hv_mid_rank: float = 50.0
    hv_high_rank: float = 70.0

    hv_low_bonus: int = 10     # hv_rank <= low
    hv_mid_bonus: int = 4      # (low, mid]
    hv_high_penalty: int = -4  # (mid, high]
    hv_extreme_penalty: int = -10  # > high


class Scoring:
    def __init__(self, rules: ScoringRules):
        self.rules = rules

    def _hv_points(self, hv_rank: float) -> int:
        """
        HV scoring (explainable bucket model):
          - low hv_rank: calendars generally benefit from "room for vol expansion"
          - high hv_rank: you're paying rich vol; calendar can become "chasing vol"
        """
        if not self.rules.hv_enabled:
            return 0

        r = float(hv_rank)
        if r <= self.rules.hv_low_rank:
            return int(self.rules.hv_low_bonus)
        if r <= self.rules.hv_mid_rank:
            return int(self.rules.hv_mid_bonus)
        if r <= self.rules.hv_high_rank:
            return int(self.rules.hv_high_penalty)
        return int(self.rules.hv_extreme_penalty)

    def score_calendar(self, regime: str, curvature: str, edge: float, hv_rank: float) -> tuple[int, ScoreBreakdown]:
        """
        Keep simple & explainable:
          base 50
          +curv bonus when SPIKY_FRONT
          edge: reward if >= min_edge_short_base, penalty if weak
          regime: penalize CONTANGO a bit, neutral FLAT, small bonus BACKWARDATION
          hv: optional bucketed adjustment (Strategy #2)
        """
        bd = ScoreBreakdown(base=50)

        # regime
        if regime == "CONTANGO":
            bd.regime = -8
        elif regime == "BACKWARDATION":
            bd.regime = +4
        else:
            bd.regime = 0

        # curvature
        bd.curvature = +6 if curvature == "SPIKY_FRONT" else 0

        # edge
        if edge >= self.rules.min_edge_short_base:
            bd.edge = +8
        elif edge >= 1.0:
            bd.edge = -8
        else:
            bd.edge = -14

        # hv (strategy #2)
        bd.hv = self._hv_points(hv_rank)

        total = bd.base + bd.regime + bd.edge + bd.hv + bd.curvature + bd.penalties
        return int(total), bd


================================================================================
FILE_PATH: src\trade_guardian\domain\__init__.py
================================================================================



================================================================================
FILE_PATH: src\trade_guardian\infra\cache.py
================================================================================
from __future__ import annotations

import json
import os
from datetime import datetime
from typing import Any, Dict, Optional


class JsonDailyCache:
    """
    Simple daily cache. Resets automatically each day by storing a date stamp.
    """
    def __init__(self, path: str):
        self.path = path
        self._data: Dict[str, Any] = {}
        self._load()

    def _load(self):
        if not os.path.exists(self.path):
            self._data = {"_date": self._today(), "items": {}}
            return
        try:
            with open(self.path, "r", encoding="utf-8") as f:
                self._data = json.load(f)
        except Exception:
            self._data = {"_date": self._today(), "items": {}}

        if self._data.get("_date") != self._today():
            self._data = {"_date": self._today(), "items": {}}

    def _save(self):
        os.makedirs(os.path.dirname(self.path), exist_ok=True)
        with open(self.path, "w", encoding="utf-8") as f:
            json.dump(self._data, f, indent=2)

    @staticmethod
    def _today() -> str:
        return datetime.now().strftime("%Y-%m-%d")

    def get(self, key: str) -> Optional[dict]:
        return self._data.get("items", {}).get(key)

    def set(self, key: str, value: dict) -> None:
        self._data.setdefault("items", {})[key] = value
        self._save()


================================================================================
FILE_PATH: src\trade_guardian\infra\config.py
================================================================================
from __future__ import annotations

import json
import os
from typing import Any, Dict, Optional

from trade_guardian.domain.policy import ShortLegPolicy

DEFAULT_CONFIG: Dict[str, Any] = {
    "paths": {
        "tickers_csv": "data/tickers.csv",
        "cache_dir": "cache",
    },
    "scan": {
        "throttle_sec": 0.50,
        "contract_type": "ALL",
    },
    "rules": {
        "min_edge_short_base": 1.05,
    },
    "policy": {
        "base_rank": 1,
        "min_dte": 3,
        # å…¼å®¹ä¸¤ç§å†™æ³•ï¼šprobe_count / max_probe_rank
        # - probe_count=3 => æ¢æµ‹ base..base+2
        "probe_count": 3,
        # "max_probe_rank": 3,
    },
    "strategies": {
        "hv_calendar": {
            "hv_rules": {
                "hv_low_rank": 20.0,
                "hv_mid_rank": 50.0,
                "hv_high_rank": 70.0,
                "hv_low_bonus": 10,
                "hv_mid_bonus": 4,
                "hv_high_penalty": -4,
                "hv_extreme_penalty": -10,
            }
        }
    },
}


def _deep_merge(a: Dict[str, Any], b: Dict[str, Any]) -> Dict[str, Any]:
    out = dict(a)
    for k, v in b.items():
        if isinstance(v, dict) and isinstance(out.get(k), dict):
            out[k] = _deep_merge(out[k], v)  # type: ignore[arg-type]
        else:
            out[k] = v
    return out


def load_config(path: str, default_cfg: Dict[str, Any]) -> Dict[str, Any]:
    if not os.path.exists(path):
        return dict(default_cfg)
    with open(path, "r", encoding="utf-8") as f:
        user_cfg = json.load(f)
    if not isinstance(user_cfg, dict):
        return dict(default_cfg)
    return _deep_merge(default_cfg, user_cfg)


def write_config_template(path: str, default_cfg: Dict[str, Any], overwrite: bool = False) -> None:
    if os.path.exists(path) and not overwrite:
        return
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        json.dump(default_cfg, f, indent=2, ensure_ascii=False)


def merge_config_paths(cfg: Dict[str, Any], root: str, csv_override: Optional[str]) -> Dict[str, Any]:
    out = dict(cfg)
    out.setdefault("paths", {})
    paths = dict(out["paths"])

    if csv_override:
        paths["tickers_csv"] = csv_override

    tickers_csv = paths.get("tickers_csv", "data/tickers.csv")
    if not os.path.isabs(tickers_csv):
        tickers_csv = os.path.join(root, tickers_csv)
    paths["tickers_csv"] = os.path.normpath(tickers_csv)

    cache_dir = paths.get("cache_dir", "cache")
    if not os.path.isabs(cache_dir):
        cache_dir = os.path.join(root, cache_dir)
    paths["cache_dir"] = os.path.normpath(cache_dir)

    out["paths"] = paths
    return out


def _resolve_probe_count(pcfg: Dict[str, Any], base_rank: int) -> int:
    """
    Return probe_count (>=1).
    æ”¯æŒï¼š
      - policy.probe_count
      - policy.max_probe_rank (inclusive)
    """
    if "probe_count" in pcfg and pcfg.get("probe_count") is not None:
        try:
            c = int(pcfg["probe_count"])
            return max(1, c)
        except Exception:
            return 3

    if "max_probe_rank" in pcfg and pcfg.get("max_probe_rank") is not None:
        try:
            mx = int(pcfg["max_probe_rank"])
            # max_probe_rank is inclusive absolute rank; convert to count
            return max(1, (mx - int(base_rank) + 1))
        except Exception:
            return 3

    return 3


def policy_from_cfg_and_cli(cfg: Dict[str, Any], args) -> ShortLegPolicy:
    """
    Build ShortLegPolicy from config + CLI overrides.

    CLI args:
      --short-rank
      --min-short-dte
      --max-probe-rank   (meaning: absolute inclusive rank upper bound)
    """
    pcfg = (cfg.get("policy", {}) or {})

    base_rank = int(pcfg.get("base_rank", 1))
    min_dte = int(pcfg.get("min_dte", 3))
    probe_count = _resolve_probe_count(pcfg, base_rank)

    # CLI overrides
    if getattr(args, "short_rank", None) is not None:
        base_rank = int(args.short_rank)
    if getattr(args, "min_short_dte", None) is not None:
        min_dte = int(args.min_short_dte)

    if getattr(args, "max_probe_rank", None) is not None:
        mx = int(args.max_probe_rank)
        probe_count = max(1, (mx - int(base_rank) + 1))

    # âœ… ç”¨ä½ç½®å‚æ•°ï¼šé¿å… dataclass å­—æ®µåå˜åŒ–å¯¼è‡´çš„ keyword å´©æºƒ
    # çº¦å®šï¼šShortLegPolicy(base_rank, min_dte, probe_count)
    return ShortLegPolicy(int(base_rank), int(min_dte), int(probe_count))


================================================================================
FILE_PATH: src\trade_guardian\infra\rate_limit.py
================================================================================
import time


class RateLimiter:
    def __init__(self, throttle_sec: float):
        self.throttle_sec = float(throttle_sec)

    def sleep(self):
        if self.throttle_sec > 0:
            time.sleep(self.throttle_sec)


================================================================================
FILE_PATH: src\trade_guardian\infra\retry_option_chain.py
================================================================================
from __future__ import annotations

import json
import logging
import random
import time
from dataclasses import dataclass, asdict
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Callable, Dict, Optional, Tuple

log = logging.getLogger(__name__)


@dataclass(frozen=True)
class RetryConfig:
    max_attempts: int = 3
    base_sleep_s: float = 0.5      # first backoff
    max_sleep_s: float = 4.0       # cap
    jitter_s: float = 0.15         # random +/- jitter
    timeout_s: float = 10.0        # if your client supports timeout, pass it through


@dataclass
class FetchAttemptRecord:
    ts_utc: str
    symbol: str
    provider: str
    attempt: int
    max_attempts: int
    ok: bool

    # request parameters you care about
    request_params: Dict[str, Any]

    # response/exception info
    reason: str = ""               # classified reason string
    http_status: Optional[int] = None
    error: str = ""                # exception message if any
    response_meta: Dict[str, Any] = None  # optional: headers, request_id, etc.
    response_snippet: str = ""     # short text snippet (safe length)


class OptionChainFetchError(RuntimeError):
    pass


def _utc_now_iso() -> str:
    return datetime.now(timezone.utc).isoformat(timespec="seconds")


def _safe_snippet(s: Any, max_len: int = 400) -> str:
    if s is None:
        return ""
    try:
        txt = s if isinstance(s, str) else json.dumps(s, ensure_ascii=False)
    except Exception:
        txt = repr(s)
    txt = txt.replace("\n", " ").replace("\r", " ")
    return txt[:max_len]


def classify_empty_response(
    *,
    payload: Any,
    http_status: Optional[int] = None,
    error: Optional[BaseException] = None,
) -> str:
    """
    Return a stable machine-readable reason.
    Keep this conservative: it's for diagnostics, not logic.
    """
    if error is not None:
        msg = str(error).lower()
        if "timeout" in msg:
            return "timeout"
        if "rate" in msg or "429" in msg:
            return "rate_limited"
        if "403" in msg or "forbidden" in msg:
            return "forbidden"
        if "401" in msg or "unauthorized" in msg:
            return "unauthorized"
        if "not found" in msg or "404" in msg:
            return "not_found"
        if "connection" in msg or "ssl" in msg:
            return "network_error"
        return "exception"

    if http_status is not None:
        if http_status == 204:
            return "no_content"
        if http_status == 404:
            return "not_found"
        if http_status == 401:
            return "unauthorized"
        if http_status == 403:
            return "forbidden"
        if http_status == 429:
            return "rate_limited"
        if 500 <= http_status <= 599:
            return "server_error"
        if 400 <= http_status <= 499:
            return "client_error"

    # payload-level hints
    if payload is None:
        return "payload_none"
    if isinstance(payload, (list, tuple)) and len(payload) == 0:
        return "payload_empty_list"
    if isinstance(payload, dict) and len(payload.keys()) == 0:
        return "payload_empty_dict"

    # common shapes: provider returns {"errors":[...]} or {"message": "..."}
    if isinstance(payload, dict):
        if "error" in payload:
            return "payload_error_field"
        if "errors" in payload and payload.get("errors"):
            return "payload_errors"
        if "message" in payload and payload.get("message"):
            return "payload_message"
        # option-chain typical: chain/expirations missing
        for k in ("callExpDateMap", "putExpDateMap", "options", "data"):
            if k in payload and not payload.get(k):
                return f"payload_missing_{k}"

    return "unknown_empty_or_unexpected"


def _write_jsonl(path: Path, record: Dict[str, Any]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("a", encoding="utf-8") as f:
        f.write(json.dumps(record, ensure_ascii=False) + "\n")


def fetch_with_retry_and_diagnostics(
    *,
    symbol: str,
    provider: str,
    request_params: Dict[str, Any],
    fetch_fn: Callable[[Dict[str, Any]], Tuple[Any, Optional[int], Dict[str, Any]]],
    # fetch_fn contract:
    #   input: request_params
    #   return: (payload, http_status, response_meta)
    #   - http_status may be None if not available
    #   - response_meta may include request_id, headers, url, etc.
    retry: RetryConfig = RetryConfig(),
    diag_jsonl_path: Path = Path("cache") / "option_chain_failures.jsonl",
    # If True: only retry on transient reasons; if False: retry all failures
    retry_only_transient: bool = True,
) -> Any:
    """
    This function is meant to sit in your infra layer.
    It does:
      - retry/backoff
      - classify failures and write JSONL diagnostic records
    """

    transient_reasons = {
        "timeout",
        "network_error",
        "server_error",
        "rate_limited",
        "no_content",
        "unknown_empty_or_unexpected",
        "payload_none",
        "payload_empty_list",
        "payload_empty_dict",
    }

    last_error: Optional[BaseException] = None
    last_reason = "unknown"
    last_status: Optional[int] = None
    last_meta: Dict[str, Any] = {}

    for attempt in range(1, retry.max_attempts + 1):
        try:
            payload, http_status, response_meta = fetch_fn(request_params)
            last_status = http_status
            last_meta = response_meta or {}

            # treat "empty payload" as failure that can be retried (often transient)
            is_empty = payload is None
            if not is_empty and isinstance(payload, (list, tuple, dict)):
                is_empty = (len(payload) == 0)

            if is_empty:
                reason = classify_empty_response(payload=payload, http_status=http_status)
                last_reason = reason

                rec = FetchAttemptRecord(
                    ts_utc=_utc_now_iso(),
                    symbol=symbol,
                    provider=provider,
                    attempt=attempt,
                    max_attempts=retry.max_attempts,
                    ok=False,
                    request_params=request_params,
                    reason=reason,
                    http_status=http_status,
                    error="",
                    response_meta=response_meta or {},
                    response_snippet=_safe_snippet(payload),
                )
                _write_jsonl(diag_jsonl_path, asdict(rec))

                # decide retry
                if attempt < retry.max_attempts and (not retry_only_transient or reason in transient_reasons):
                    _sleep_backoff(attempt, retry)
                    continue

                raise OptionChainFetchError(f"{symbol}: empty option chain payload ({reason})")

            # success
            return payload

        except Exception as e:
            last_error = e
            reason = classify_empty_response(payload=None, http_status=last_status, error=e)
            last_reason = reason

            rec = FetchAttemptRecord(
                ts_utc=_utc_now_iso(),
                symbol=symbol,
                provider=provider,
                attempt=attempt,
                max_attempts=retry.max_attempts,
                ok=False,
                request_params=request_params,
                reason=reason,
                http_status=last_status,
                error=str(e),
                response_meta=last_meta or {},
                response_snippet="",
            )
            _write_jsonl(diag_jsonl_path, asdict(rec))

            if attempt < retry.max_attempts and (not retry_only_transient or reason in transient_reasons):
                _sleep_backoff(attempt, retry)
                continue

            raise

    # should never reach
    if last_error is not None:
        raise last_error
    raise OptionChainFetchError(f"{symbol}: failed to fetch option chain ({last_reason})")


def _sleep_backoff(attempt: int, retry: RetryConfig) -> None:
    # exponential backoff with jitter
    base = retry.base_sleep_s * (2 ** (attempt - 1))
    sleep_s = min(retry.max_sleep_s, base)
    sleep_s += random.uniform(-retry.jitter_s, retry.jitter_s)
    sleep_s = max(0.0, sleep_s)
    time.sleep(sleep_s)


================================================================================
FILE_PATH: src\trade_guardian\infra\schwab_client.py
================================================================================
from __future__ import annotations

import requests
import numpy as np
import pandas as pd
import traceback
from datetime import datetime, timedelta, date
from urllib.parse import quote
from typing import Optional, Any, List

from trade_guardian.domain.models import Context, IVData, HVInfo, TermPoint
from trade_guardian.infra.schwab_token_manager import fetch_schwab_token

# --- Helper Functions (ç‰©ç†ç‰¹å¾è¾…åŠ©) ---
def _to_date(iso: str) -> date:
    return datetime.strptime(iso, "%Y-%m-%d").date()

def is_third_friday(d: date) -> bool:
    """åˆ¤æ–­æ˜¯å¦ä¸ºæ ‡å‡†æœˆåº¦æœŸæƒ (ç¬¬ä¸‰ä¸ªå‘¨äº”)"""
    return d.weekday() == 4 and 15 <= d.day <= 21

def get_series_kind(exp_str: str) -> str:
    """æ ¹æ®åˆ°æœŸæ—¥åˆ¤æ–­åˆçº¦ç±»å‹ï¼šMONTHLY, WEEKLY, DAILY"""
    d = _to_date(exp_str)
    if is_third_friday(d): return "MONTHLY"
    if d.weekday() == 4: return "WEEKLY"
    return "DAILY"

class SchwabClient:
    OPTION_CHAIN_URL = "https://api.schwabapi.com/marketdata/v1/chains"
    QUOTE_URL_TEMPLATE = "https://api.schwabapi.com/marketdata/v1/quotes?symbols={symbols}&fields=quote"
    PRICE_HISTORY_URL = "https://api.schwabapi.com/marketdata/v1/pricehistory"

    def __init__(self, cfg: dict = None):
        self.cfg = cfg or {}

    def build_context(self, symbol: str, days: int = 600) -> Optional[Context]:
        """
        [Tactical Refactor] Curve-Driven Context Builder
        ä¼˜åŒ–ç›®æ ‡ï¼šåœ¨æ‰«æå…¨é‡åœ°å½¢çš„åŸºç¡€ä¸Šï¼Œå¼•å…¥æˆ˜æœ¯åå¥½ (Tactical Bias)
          1. Micro: ä¼˜å…ˆæ•æ‰å•ä½æ—¶é—´å†…çš„ IV çˆ†å‘åŠ› (Front Momentum)
          2. Month: åœ¨å¹³ç¨³åŒºåŸºç¡€ä¸Šï¼Œæƒ©ç½šè¿‡è¿œçš„ DTEï¼Œé”šå®š 35DTE æˆ˜æœ¯åŒº
        """
        try:
            # 1. è·å– HV æ•°æ®
            hv_info = self.calculate_hv_percentile(symbol)
            if getattr(hv_info, 'status', '') == "Error":
                hv_info = HVInfo(current_hv=0.0, hv_rank=50.0)

            # 2. è·å–å…¨é‡æœŸæƒé“¾
            try:
                price, term_points, raw_chain = self.scan_atm_term(symbol, days)
            except Exception as e:
                return None

            if not term_points or len(term_points) < 3:
                return None

            # 3. æ’åº
            term_points.sort(key=lambda x: x.dte)

            # =================================================================
            # ç®—æ³• A: ç¡®å®š Short Leg (æ‰§è¡Œè…¿)
            # é€»è¾‘ï¼š1-10 DTE ä¸­æœ€è¿‘çš„é 0DTE
            # =================================================================
            short_candidates = [p for p in term_points if 1 <= p.dte <= 10]
            if short_candidates:
                short_point = min(short_candidates, key=lambda x: x.dte)
            else:
                short_point = term_points[0]
            
            short_kind = get_series_kind(short_point.exp)
            short_iv_base = short_point.iv if short_point.iv > 0 else 1.0

            # =================================================================
            # ç®—æ³• B: å¯»æ‰¾ Micro Anchor (å¼•å…¥å‰ç«¯çˆ†å‘åŠ›è¯„åˆ†)
            # é€»è¾‘ï¼šåœ¨ 1-15 DTE ä¸­ï¼Œä¼˜å…ˆæ‰¾å±€éƒ¨æ³¢å³°ï¼›è‹¥æ— ï¼Œæ‰¾å•ä½æ—¶é—´ IV å¢å¹…æœ€å¤§çš„ç‚¹
            # =================================================================
            micro_pool = [p for p in term_points if 1 <= p.dte <= 15]
            micro_point = None

            if len(micro_pool) >= 2:
                # 1. ä¼˜å…ˆï¼šå¯»æ‰¾å±€éƒ¨æå¤§å€¼ (Local Maxima) -> æ˜¾æ€§æŒ¤å‹
                local_maxima = []
                for i in range(1, len(micro_pool) - 1):
                    if micro_pool[i].iv > micro_pool[i-1].iv and micro_pool[i].iv > micro_pool[i+1].iv:
                        local_maxima.append(micro_pool[i])
                
                if local_maxima:
                    micro_point = max(local_maxima, key=lambda x: x.iv)
                else:
                    # 2. å…œåº•ï¼šæ— å±€éƒ¨å³°å€¼æ—¶ï¼Œå¯»æ‰¾ "å•ä½æ—¶é—´çˆ†å‘åŠ›" æœ€å¼ºçš„ç‚¹
                    # å…¬å¼ï¼šScore = (IV - ShortIV) / sqrt(DTE)
                    # é¿å…æ— è„‘é€‰æœ€è¿œç«¯ï¼Œè€Œæ˜¯é€‰æ›²çº¿æœ€é™¡å³­çš„é‚£ä¸€æ®µ
                    def _momentum_score(p):
                        d_eff = max(1, p.dte)
                        return (p.iv - short_iv_base) / np.sqrt(d_eff)
                    
                    micro_point = max(micro_pool, key=_momentum_score)
            
            # Fallback
            if not micro_point or micro_point.dte <= short_point.dte:
                candidates = [p for p in term_points if p.dte > short_point.dte and p.dte <= 21]
                if candidates:
                    micro_point = min(candidates, key=lambda x: abs(x.dte - 10))
                else:
                    micro_point = short_point

            # =================================================================
            # ç®—æ³• C: å¯»æ‰¾ Month Anchor (æˆ˜æœ¯çª—å£ä¿®æ­£)
            # é€»è¾‘ï¼šä¼˜å…ˆåœ¨ 25-45 DTE (æˆ˜æœ¯åŒº) å¯»æ‰¾é”šç‚¹ï¼›è‹¥æ— æ•°æ®ï¼Œå†æ‰©è‡³ 25-90 DTE
            # =================================================================
            month_pool = [p for p in term_points if 25 <= p.dte <= 45]
            if len(month_pool) < 3:
                month_pool = [p for p in term_points if 25 <= p.dte <= 90]
            
            month_point = None
            
            # ä½¿ç”¨ç®€å•çš„è·ç¦»+å¹³ç¨³åº¦æ‰“åˆ† (ä¿æŒåŸé€»è¾‘ï¼Œä½†æ± å­å˜äº†)
            TARGET_MONTH = 35.0
            LAMBDA_DIST = 0.35 

            if len(month_pool) >= 3:
                scored_candidates = []
                for i in range(1, len(month_pool) - 1):
                    window = [month_pool[i-1].iv, month_pool[i].iv, month_pool[i+1].iv]
                    sd = np.std(window)
                    dist_penalty = abs(month_pool[i].dte - TARGET_MONTH) / TARGET_MONTH
                    score = sd + (LAMBDA_DIST * dist_penalty)
                    scored_candidates.append((score, sd, month_pool[i]))
                
                scored_candidates.sort(key=lambda x: x[0])
                top_5 = scored_candidates[:min(5, len(scored_candidates))]
                
                # åœ¨ä¼˜èƒœç»„é‡Œä¼˜å…ˆé€‰ Monthly
                best_monthly = next((p for sc, sd, p in top_5 if get_series_kind(p.exp) == "MONTHLY"), None)
                month_point = best_monthly if best_monthly else top_5[0][2]
            else:
                # Fallback
                fallback_candidates = [p for p in term_points if p.dte >= 20]
                if fallback_candidates:
                    month_point = min(fallback_candidates, key=lambda x: abs(x.dte - 30))
                else:
                    month_point = term_points[-1]


            # =================================================================
            # 4. æ•°æ®ç»„è£…ä¸ Edge ç¨³å¥è®¡ç®— (Stabilizer V3)
            # =================================================================
            short_iv = short_point.iv
            micro_iv = micro_point.iv
            month_iv = month_point.iv

            if short_iv <= 0: short_iv = 1.0
            if month_iv <= 0: month_iv = 1.0

            # ç»“æ„åˆ¤å®š
            is_squeeze = True if (micro_iv > month_iv * 1.05) else False
            
            regime = "FLAT"
            if short_iv > month_iv * 1.03: regime = "BACKWARDATION"
            elif month_iv > short_iv * 1.03: regime = "CONTANGO"

            curvature = "NORMAL"
            if micro_iv > short_iv * 1.10: curvature = "SPIKY_FRONT"

            # [Edge Stabilizer V3]
            # 1. Short Base (Median): è¿™é‡Œçš„ Short IV å®¹æ˜“å—å•æ—¥äº‹ä»¶å½±å“å‡ºç°æ¯›åˆºã€‚
            #    ä½¿ç”¨ 1-10 DTE åŒºé—´çš„ä¸­ä½æ•°ä½œä¸ºæ›´ç¨³å¥çš„"çŸ­æœŸåŸºå‡†"ã€‚
            short_band = [p.iv for p in term_points if 1 <= p.dte <= 10 and p.iv > 0]
            short_base = np.median(short_band) if short_band else short_iv

            # 2. Mixed Denominator: é˜²æ­¢åˆ†æ¯è¿‡å°ï¼ŒåŒæ—¶ä¹Ÿé˜²æ­¢ä½æ³¢ç¯å¢ƒä¸‹ Edge è¢«è¿‡åº¦å‹ç¼©ã€‚
            #    ä½¿ç”¨ (Base + Far) / 2 ä½œä¸ºåˆ†æ¯ï¼Œå¹¶ä¿ç•™ 12.0 çš„ç¡¬åœ°æ¿ã€‚
            IV_FLOOR = 12.0
            denom_micro = max(0.5 * (short_base + micro_iv), IV_FLOOR)
            denom_month = max(0.5 * (short_base + month_iv), IV_FLOOR)
            
            edge_micro_raw = (micro_iv - short_base) / denom_micro
            edge_month_raw = (month_iv - short_base) / denom_month
            
            # 3. Extended Soft Decay: å°†è¡°å‡èŒƒå›´æ‰©è‡³ 6 DTE (å‘¨æƒè¦†ç›–åŒº)
            #    ç³»æ•°ä» 0.7 èµ·æ­¥ (sqrt(1/6)=0.4å¤ªç‹ äº†ï¼Œæˆ‘ä»¬è®¾æ­»åº•çº¿)
            DECAY_CUTOFF = 6.0
            stabilizer = 1.0
            
            if short_point.dte < DECAY_CUTOFF:
                # å¹³æ»‘å› å­
                raw_decay = np.sqrt(max(1, short_point.dte) / DECAY_CUTOFF)
                # é™åˆ¶èŒƒå›´ [0.7, 1.0]ï¼Œé¿å…å¯¹ 1-2 DTE æƒ©ç½šè¿‡é‡å¯¼è‡´å®Œå…¨ä¸å¯äº¤æ˜“
                stabilizer = max(0.7, min(1.0, raw_decay))
                
                edge_micro_raw *= stabilizer
                edge_month_raw *= stabilizer

            # [DEBUG] æ‰“å°è°ƒè¯•ä¿¡æ¯ï¼ŒéªŒè¯æ•°å€¼æ˜¯å¦åˆç† (æ­£å¼ç‰ˆå¯æ³¨é‡Š)
            # print(f"[DBG] {symbol:<5} DTE:{short_point.dte} Base:{short_base:.1f}% M_IV:{month_iv:.1f}% Stab:{stabilizer:.2f} Edge:{edge_month_raw:.2f}")

            tsf = {
                "regime": regime,
                "curvature": curvature,
                "is_squeeze": is_squeeze,

                # Anchor Points
                "short_exp": short_point.exp, "short_dte": short_point.dte, "short_iv": short_point.iv, "short_kind": short_kind,
                "micro_exp": micro_point.exp, "micro_dte": micro_point.dte, "micro_iv": micro_point.iv,
                "month_exp": month_point.exp, "month_dte": month_point.dte, "month_iv": month_point.iv,

                # Stabilized Edges
                "edge_micro": edge_micro_raw,
                "edge_month": edge_month_raw,
            }
            
            # 5. è¿”å› Context
            iv_data = IVData(
                rank=hv_info.hv_rank, percentile=0.0, current_iv=short_iv, 
                hv_rank=hv_info.hv_rank, current_hv=hv_info.current_hv
            )
            
            class Metrics: pass
            metrics = Metrics()
            metrics.gamma = short_point.gamma
            metrics.delta = short_point.delta
            metrics.theta = short_point.theta

            # [FIX] P0-1: è¿™é‡Œå¢åŠ äº† term=term_points
            return Context(
                symbol=symbol, 
                price=price, 
                iv=iv_data, 
                hv=iv_data, 
                tsf=tsf, 
                raw_chain=raw_chain, 
                metrics=metrics,
                term=term_points 
            )
        
        except Exception as e:
            return None

    # --- åŸºç¡€ API æ–¹æ³•ä¿æŒä¸å˜ ---
    def _headers(self):
        token = fetch_schwab_token()
        if not token: raise ValueError("Token fetch failed")
        return {"Authorization": f"Bearer {token}", "Accept": "application/json"}

    def get_quote(self, symbol: str) -> dict:
        encoded = quote(symbol, safe="")
        url = self.QUOTE_URL_TEMPLATE.format(symbols=encoded)
        resp = requests.get(url, headers=self._headers(), timeout=20)
        return resp.json().get(symbol, {}).get("quote", {}) or {}

    def calculate_hv_percentile(self, symbol: str) -> HVInfo:
        try:
            params = {"symbol": symbol, "periodType": "year", "period": 2, "frequencyType": "daily", "frequency": 1}
            resp = requests.get(self.PRICE_HISTORY_URL, headers=self._headers(), params=params, timeout=30)
            data = resp.json()
            candles = data.get("candles") or []
            if not candles: return HVInfo(status="Error")

            df = pd.DataFrame(candles)
            df["close"] = df["close"].astype(float)
            df["log_ret"] = np.log(df["close"] / df["close"].shift(1))
            df["hv"] = df.dropna(subset=["log_ret"])["log_ret"].rolling(window=20).std() * np.sqrt(252) * 100
            
            current_hv = float(df["hv"].iloc[-1])
            recent = df["hv"].dropna().tail(252)
            hv_low, hv_high = float(recent.min()), float(recent.max())
            hv_rank = (current_hv - hv_low) / (hv_high - hv_low) * 100.0 if hv_high > hv_low else 0.0
            
            return HVInfo(status="Success", current_hv=current_hv, hv_rank=hv_rank, hv_low=hv_low, hv_high=hv_high)
        except: return HVInfo(status="Error")

    def _fetch_calls_chain(self, symbol: str, from_d: str, to_d: str, range_val: str = "NTM") -> dict:
        params = {"symbol": symbol, "contractType": "ALL", "strategy": "SINGLE", "range": range_val, "fromDate": from_d, "toDate": to_d}
        resp = requests.get(self.OPTION_CHAIN_URL, headers=self._headers(), params=params, timeout=30)
        return resp.json() if resp.status_code == 200 else {}

    def scan_atm_term(self, symbol: str, days: int) -> tuple[float, list[TermPoint], dict]:
        """ä¸€æ¬¡æ€§è·å–æœªæ¥ N å¤©çš„å…¨é‡æœŸæƒé“¾"""
        q = self.get_quote(symbol)
        price = float(q.get("lastPrice") or 0.0)
        if price == 0: raise RuntimeError(f"No price for {symbol}")

        from_date = datetime.now().strftime("%Y-%m-%d")
        to_date = (datetime.now() + timedelta(days=days)).strftime("%Y-%m-%d")
        
        chain = self._fetch_calls_chain(symbol, from_date, to_date, range_val="ALL")
        call_map = chain.get("callExpDateMap") or {}

        term: list[TermPoint] = []
        for date_str, strikes_map in sorted(call_map.items()):
            parts = date_str.split(":")
            date_iso, dte = parts[0], int(parts[1])
            
            best_strike, min_dist, best_data = 0.0, 1e18, None
            for s_str, contracts in strikes_map.items():
                s_val = float(s_str)
                dist = abs(s_val - price)
                if dist < min_dist:
                    c = contracts[0]
                    iv = float(c.get("volatility", 0) or 0.0)
                    if iv > 0:
                        if iv < 5.0: iv *= 100.0
                        min_dist, best_strike = dist, s_val
                        best_data = {
                            "iv": iv, "mark": float(c.get("mark") or 0.0), 
                            "delta": float(c.get("delta") or 0.0), 
                            "theta": float(c.get("theta") or 0.0), 
                            "gamma": float(c.get("gamma") or 0.0)
                        }
            if best_data:
                term.append(TermPoint(exp=date_iso, dte=dte, strike=best_strike, **best_data))
        
        return price, term, chain

================================================================================
FILE_PATH: src\trade_guardian\infra\schwab_token_manager.py
================================================================================
# trade_guardian/infra/schwab_token_manager.py
from __future__ import annotations

import os

def fetch_schwab_token() -> str:
    """
    Resolve Schwab OAuth access token.
    Priority:
      1) env SCHWAB_ACCESS_TOKEN
      2) legacy module shipped with this project: schwab_token_manager_legacy.py
      3) legacy global module name: schwab_token_manager (if user has it on PYTHONPATH)
    """
    tok = os.getenv("SCHWAB_ACCESS_TOKEN", "").strip()
    if tok:
        return tok

    # local legacy copy (recommended)
    try:
        from .schwab_token_manager_legacy import fetch_schwab_token as legacy_fetch
        tok = (legacy_fetch() or "").strip()
        if tok:
            return tok
    except Exception:
        pass

    # global legacy name (optional)
    try:
        from schwab_token_manager import fetch_schwab_token as global_fetch  # type: ignore
        tok = (global_fetch() or "").strip()
        if tok:
            return tok
    except Exception:
        pass

    raise RuntimeError(
        "Schwab token not found. "
        "Set env SCHWAB_ACCESS_TOKEN, or copy your old schwab_token_manager.py into "
        "trade_guardian/infra/schwab_token_manager_legacy.py."
    )


================================================================================
FILE_PATH: src\trade_guardian\infra\schwab_token_manager_legacy.py
================================================================================
# File: schwab_token_manager.py

import requests
import json
from typing import Optional

# --- Configuration for API Token Server ---
TOKEN_SERVER = "http://127.0.0.1:5000" # Your local token server URL

def fetch_schwab_token() -> Optional[str]:
    """
    Fetches the Schwab API access token from the local token server.
    This is a central utility function to be used by other data fetcher modules.
    """
    try:
        resp = requests.get(f"{TOKEN_SERVER}/token")
        resp.raise_for_status()
        token_data = resp.json()
        access_token = token_data.get("access_token")
        if not access_token:
            print("Error: 'access_token' key not found in token server response.")
            return None
        return access_token
    except requests.exceptions.RequestException as e:
        print(f"Error fetching Schwab token: {e}")
    except json.JSONDecodeError:
        print(f"Error decoding JSON from token server. Response: {resp.text}")
    return None

# --- Main block for standalone testing ---
if __name__ == "__main__":
    print("--- Testing Schwab Token Manager ---")
    token = fetch_schwab_token()
    if token:
        print("Successfully fetched an access token.")
        # print(f"Token (first 15 chars): {token[:15]}...") # Uncomment for more verbose testing
    else:
        print("Failed to fetch an access token.")
    print("--- Test Complete ---")

================================================================================
FILE_PATH: src\trade_guardian\infra\tickers.py
================================================================================
# src/trade_guardian/infra/tickers.py
from __future__ import annotations

from typing import List
import csv
import os
import re

_VALID = re.compile(r"^[A-Z0-9\.\-\_]+$")  # allow BRK.B, etc.

def load_tickers_csv(path: str) -> List[str]:
    """
    Load tickers from a csv where each line contains a symbol (or first column is symbol).
    Skips:
      - blank lines
      - comment lines starting with # or //
      - header-like tokens: SYMBOL, TICKER, SYM
      - invalid symbols
    """
    if not os.path.exists(path):
        raise FileNotFoundError(f"tickers.csv not found: {path}")

    out: List[str] = []
    with open(path, "r", newline="", encoding="utf-8-sig") as f:
        reader = csv.reader(f)
        for row in reader:
            if not row:
                continue
            sym = (row[0] or "").strip().upper()
            if not sym:
                continue
            if sym.startswith("#") or sym.startswith("//"):
                continue
            if sym in {"SYMBOL", "TICKER", "SYM"}:
                continue
            if not _VALID.match(sym):
                continue
            out.append(sym)

    # de-dup while keeping order
    seen = set()
    uniq: List[str] = []
    for s in out:
        if s not in seen:
            uniq.append(s)
            seen.add(s)
    return uniq


================================================================================
FILE_PATH: src\trade_guardian\infra\__init__.py
================================================================================



================================================================================
FILE_PATH: src\trade_guardian\strategies\auto.py
================================================================================
from __future__ import annotations

from typing import Optional, Tuple

from trade_guardian.domain.models import Context, Recommendation, ScanRow
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.strategies.base import Strategy
from trade_guardian.strategies.diagonal import DiagonalStrategy
from trade_guardian.strategies.long_gamma import LongGammaStrategy


class AutoStrategy(Strategy):
    """
    Strategy #5: Auto / Smart Router (Brain V5 - Structure First)
    
    Philosophy:
      - Structure Trumps Volatility: If the Term Structure offers a good edge (>0.20),
        we prioritize Diagonal spreads to harvest Theta/Vega differential, even if IV is low.
      - Low Vol Fallback: Only when structure is flat do we revert to Long Gamma (Straddle)
        to play for pure expansion.
    
    Routing Order:
      1. Backwardation -> LG (Defense)
      2. Edge > 0.20   -> DIAG (Attack Structure)
      3. HV < 30       -> LG (Attack Vol Floor)
      4. Default       -> LG
    """
    name = "auto"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy
        self.diagonal = DiagonalStrategy(cfg, policy)
        self.long_gamma = LongGammaStrategy(cfg, policy)

    def evaluate(self, ctx: Context) -> ScanRow:
        hv_rank = float(ctx.hv.hv_rank)
        tsf = ctx.tsf
        regime = str(tsf.get("regime", "FLAT"))
        edge_month = float(tsf.get("edge_month", 0.0))

        # --- å†³ç­–é€»è¾‘ (Brain V5) ---
        
        # 1. [å€’æŒ‚ä¿æŠ¤] Backwardation -> å¼ºåˆ¶ Long Gamma
        # è¿™ç§æ—¶å€™å–è¿‘ç«¯æ˜¯è‡ªæ€ï¼Œå¿…é¡»é˜²å®ˆ
        if regime == "BACKWARDATION":
            row = self.long_gamma.evaluate(ctx)
            row.tag = f"AUTO-LG"
            return row

        # 2. [ç»“æ„ä¼˜å…ˆ] åªè¦ Edge è¶³å¤Ÿå¥½ (> 0.20)ï¼Œä¼˜å…ˆåš Diagonal
        # å³ä½¿ HV å¾ˆä½ï¼Œä¼˜ç§€çš„ç»“æ„ä¹Ÿèƒ½æä¾›æ¯” Straddle æ›´å¥½çš„ç›ˆäºæ¯”
        # (åŒ…å«äº† > 0.35 çš„è¶…çº§ç»“æ„æƒ…å†µ)
        if edge_month >= 0.20:
            row_diag = self.diagonal.evaluate(ctx)
            # åªæœ‰æ„å»ºæˆåŠŸæ‰è¿”å›ï¼Œå¦åˆ™æ‰ä¸‹å»èµ°å…œåº•
            if row_diag and row_diag.meta and "long_strike" in row_diag.meta:
                row_diag.tag = f"AUTO-DIAG" 
                return row_diag

        # 3. [ä½æ³¢åšå¼ˆ] ç»“æ„å¹³åº¸ï¼Œä½†æ³¢åŠ¨ç‡åœ¨åœ°æ¿ -> å¼ºåˆ¶ Long Gamma
        # NVDA (Edge 0.16) ä¼šè½åˆ°è¿™é‡Œ
        if hv_rank < 30:
            row = self.long_gamma.evaluate(ctx)
            row.tag = f"AUTO-LG" 
            return row
        
        # 4. [é»˜è®¤å…œåº•] ç»“æ„å¹³å¦ä¸”æ³¢åŠ¨ç‡ä¸­ç­‰ -> Long Gamma
        row = self.long_gamma.evaluate(ctx)
        row.tag = f"AUTO-LG"
        return row

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        row = self.evaluate(ctx)
        if "DIAG" in row.tag:
            return self.diagonal.recommend(ctx, min_score, max_risk)
        else:
            return self.long_gamma.recommend(ctx, min_score, max_risk)

================================================================================
FILE_PATH: src\trade_guardian\strategies\base.py
================================================================================
from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Optional, Tuple

from trade_guardian.domain.models import Context, Recommendation, ScanRow


class Strategy(ABC):
    name: str = "base"

    @abstractmethod
    def evaluate(self, ctx: Context) -> ScanRow:
        raise NotImplementedError

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        """
        Optional: probe ranks to find a tradable short leg.
        For strategies that don't support probing, return (None, "-").
        """
        return None, "-"


================================================================================
FILE_PATH: src\trade_guardian\strategies\blueprint.py
================================================================================
from typing import Optional, Dict, Any
from trade_guardian.domain.models import Blueprint, OrderLeg

# [è¾…åŠ©å‡½æ•°] ä¿æŒä¸å˜
def _extract_greeks_for(chain: Dict[str, Any], side: str, exp: str, strike: float) -> Dict[str, float]:
    """å°è¯•ä»åŸå§‹æ•°æ®ä¸­æå– Delta/Gamma/Theta"""
    side_map_key = "callExpDateMap" if side.upper() == "CALL" else "putExpDateMap"
    exp_map = chain.get(side_map_key, {})
    
    target_key = None
    for k in exp_map.keys():
        if k.startswith(exp):
            target_key = k
            break
    
    if not target_key: return {}
    
    strikes = exp_map[target_key]
    quote = None
    strike_str = f"{strike:.1f}"
    if strike_str in strikes:
        quote = strikes[strike_str][0]
    else:
        for s_str, q_list in strikes.items():
            if abs(float(s_str) - strike) < 0.01:
                quote = q_list[0]
                break
    
    if not quote: return {}

    return {
        "delta": float(quote.get("delta", 0.0)),
        "gamma": float(quote.get("gamma", 0.0)),
        "theta": float(quote.get("theta", 0.0))
    }

def _extract_mid_for(chain: Dict[str, Any], side: str, exp: str, strike: float) -> Optional[float]:
    side_map = chain.get("callExpDateMap" if side == "CALL" else "putExpDateMap", {})
    for k in side_map:
        if k.startswith(exp):
            strikes = side_map[k]
            for s_key, quotes in strikes.items():
                if abs(float(s_key) - strike) < 0.01:
                    q = quotes[0]
                    if "mark" in q: return float(q["mark"])
                    if "bid" in q and "ask" in q: return (float(q["bid"]) + float(q["ask"])) / 2.0
    return None

# =========================================================
# æ ¸å¿ƒä¿®æ”¹ï¼šåºŸå¼ƒç§æœ‰ Blueprint ç±»ï¼Œç»Ÿä¸€è¿”å› domain.models.Blueprint
# =========================================================

def build_diagonal_blueprint(
    *,
    symbol: str,
    underlying: float,
    chain: Dict[str, Any],
    short_exp: str,
    long_exp: str,
    target_short_strike: float,
    target_long_strike: float,
    side: str = "CALL",
) -> Optional[Blueprint]:
    
    short_mid = _extract_mid_for(chain, side=side, exp=short_exp, strike=target_short_strike)
    long_mid = _extract_mid_for(chain, side=side, exp=long_exp, strike=target_long_strike)

    est_debit = 0.0
    error_msg = None
    note = ""
    width = abs(target_short_strike - target_long_strike)

    if isinstance(short_mid, (int, float)) and isinstance(long_mid, (int, float)):
        est_debit = float(long_mid - short_mid)
        
        # å®½å®¹çš„é£æ§é€»è¾‘ï¼šåªè®°å½• Noteï¼Œä¸æŠ¥é”™
        if est_debit > width:
            excess = est_debit - width
            note = f"âš ï¸ High Debit (Net Risk: -${excess:.2f}). Vega Play."
        else:
            note = f"Healthy PMCC Setup. Width={width:.2f}"
    else:
        # ä»·æ ¼ç¼ºå¤±
        error_msg = "Missing pricing data"

    # æ„é€ æ ‡å‡† Legs
    legs = [
        OrderLeg(symbol=symbol, action="BUY", ratio=1, exp=long_exp, strike=target_long_strike, type=side),
        OrderLeg(symbol=symbol, action="SELL", ratio=1, exp=short_exp, strike=target_short_strike, type=side)
    ]

    return Blueprint(
        symbol=symbol,
        strategy="DIAGONAL",
        legs=legs,
        est_debit=round(est_debit, 2),
        note=note,
        error=error_msg
    )

def build_straddle_blueprint(
    *,
    symbol: str,
    underlying: float,
    chain: Dict[str, Any],
    exp: str,
) -> Optional[Blueprint]:
    
    # æŸ¥æ‰¾ ATM Strike
    call_map = chain.get("callExpDateMap", {})
    target_key = None
    for k in call_map:
        if k.startswith(exp):
            target_key = k
            break
    if not target_key: return None
    
    strikes = sorted([float(s) for s in call_map[target_key].keys()])
    strike = min(strikes, key=lambda x: abs(x - underlying))
    
    call_mid = _extract_mid_for(chain, "CALL", exp, strike)
    put_mid = _extract_mid_for(chain, "PUT", exp, strike)
    
    est_debit = 0.0
    if call_mid and put_mid:
        est_debit = call_mid + put_mid
        
    legs = [
        OrderLeg(symbol=symbol, action="BUY", ratio=1, exp=exp, strike=strike, type="CALL"),
        OrderLeg(symbol=symbol, action="BUY", ratio=1, exp=exp, strike=strike, type="PUT")
    ]

    return Blueprint(
        symbol=symbol,
        strategy="STRADDLE",
        legs=legs,
        est_debit=round(est_debit, 2),
        note="ATM Straddle"
    )

def build_calendar_blueprint(
    *,
    symbol: str,
    underlying: float,
    chain: Dict[str, Any],
    short_exp: str,
    long_exp: str,
    prefer_side: str = "CALL"
) -> Optional[Blueprint]:
    
    call_map = chain.get("callExpDateMap", {})
    target_key = None
    for k in call_map:
        if k.startswith(short_exp):
            target_key = k
            break
    if not target_key: return None
    strikes = sorted([float(s) for s in call_map[target_key].keys()])
    strike = min(strikes, key=lambda x: abs(x - underlying))
    
    short_mid = _extract_mid_for(chain, prefer_side, short_exp, strike)
    long_mid = _extract_mid_for(chain, prefer_side, long_exp, strike)
    
    est_debit = 0.0
    if short_mid and long_mid:
        est_debit = long_mid - short_mid
        
    legs = [
        OrderLeg(symbol=symbol, action="BUY", ratio=1, exp=long_exp, strike=strike, type=prefer_side),
        OrderLeg(symbol=symbol, action="SELL", ratio=1, exp=short_exp, strike=strike, type=prefer_side)
    ]

    return Blueprint(
        symbol=symbol,
        strategy="CALENDAR",
        legs=legs,
        est_debit=round(est_debit, 2),
        note="ATM Calendar"
    )

================================================================================
FILE_PATH: src\trade_guardian\strategies\calendar.py
================================================================================
from __future__ import annotations

from typing import Optional, Tuple

from trade_guardian.domain.models import (
    Context,
    Recommendation,
    ScanRow,
    ScoreBreakdown,
    RiskBreakdown,
)
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.domain.scoring import Scoring, ScoringRules


class CalendarStrategy:
    name = "calendar"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy
        rules = ScoringRules(min_edge_short_base=float(cfg["rules"]["min_edge_short_base"]))
        self.scoring = Scoring(rules)

    def _tag(self, regime: str, curvature: str) -> str:
        t = "F" if regime == "FLAT" else ("C" if regime == "CONTANGO" else "B")
        if curvature == "SPIKY_FRONT":
            t += "S"
        return t

    @staticmethod
    def _clamp(x: float, lo: float, hi: float) -> float:
        return max(lo, min(hi, x))

    def _risk_score(
        self,
        ctx: Context,
        *,
        short_dte: int,
        short_gamma: float,
        rank0_dte: int,
        rank0_gamma: float,
        regime: str,
        curvature: str,
        squeeze_ratio: float,
    ) -> tuple[int, RiskBreakdown]:
        """
        Continuous & explainable risk model (0..100):

        base: start at 35 (not 50) so the system has headroom.
        dte: continuous decay with DTE (shorter => higher risk)
        gamma: continuous penalty based on gamma normalized vs front (or max)
        curvature: continuous penalty based on squeeze_ratio (only when SPIKY_FRONT)
        regime: small penalty (BACKWARDATION > CONTANGO > FLAT)
        """
        bd = RiskBreakdown(base=35)

        # -------- DTE penalty (continuous) --------
        # Target behavior (approx):
        #   dte ~ 1-3  => big penalty
        #   dte ~ 6    => medium
        #   dte ~ 10   => smaller
        #   dte >= 21  => near 0
        d = float(max(0, short_dte))
        # smooth curve: 0..~22 then clamp
        dte_pen = 26.0 / (1.0 + (d / 6.5) ** 1.25)  # d=6 => ~14-16 ; d=10 => ~9-11 ; d=20 => ~4
        # extra caution if front expiry is extremely close (weekly Friday effect / 0DTE clusters)
        front_pen = 0.0
        if rank0_dte <= 1:
            front_pen = 6.0
        elif rank0_dte <= 3:
            front_pen = 3.0

        bd.dte = int(round(self._clamp(dte_pen + front_pen, 0.0, 30.0)))

        # -------- Gamma penalty (continuous) --------
        # Normalize gamma: if we have rank0_gamma use it; otherwise fall back to max gamma in eligible term
        denom = rank0_gamma if rank0_gamma and rank0_gamma > 0 else 0.0
        if denom <= 0:
            # fallback: max gamma among term points we have
            try:
                denom = max(float(p.gamma) for p in ctx.term if p.gamma is not None)  # type: ignore
            except Exception:
                denom = 0.0

        g = float(short_gamma) if short_gamma is not None else 0.0
        g_norm = (g / denom) if denom > 0 else 0.0
        g_norm = self._clamp(g_norm, 0.0, 2.0)  # allow >1 if short gamma > front (rare but possible)

        # penalty curve: small when g_norm <=0.3, grows faster after 0.6
        # map roughly into 0..22
        gamma_pen = 22.0 * (g_norm ** 0.75)
        bd.gamma = int(round(self._clamp(gamma_pen, 0.0, 22.0)))

        # -------- Curvature penalty (continuous) --------
        # Use squeeze_ratio: (rank0_iv / base_iv) as a "front spike" severity.
        # Only penalize meaningfully if SPIKY_FRONT and squeeze is above mild threshold.
        curv_pen = 0.0
        if curvature == "SPIKY_FRONT":
            sr = float(squeeze_ratio) if squeeze_ratio is not None else 0.0
            # thresholded linear ramp:
            #  sr <= 1.10 => ~0
            #  sr 1.10..1.80 => 0..10
            curv_pen = 10.0 * self._clamp((sr - 1.10) / 0.70, 0.0, 1.0)

        # [FIX] Issue A: å­—æ®µåä¿®æ­£ä¸º curvature (åŸä¸º curv)
        bd.curvature = int(round(self._clamp(curv_pen, 0.0, 10.0)))

        # -------- Regime penalty (small, not dominating) --------
        # BACKWARDATION means front richer -> short leg can be more dangerous (bigger adverse gamma & gap risk).
        if regime == "BACKWARDATION":
            bd.regime = 4
        elif regime == "CONTANGO":
            bd.regime = 2
        else:
            bd.regime = 0

        # -------- Penalties slot (reserved) --------
        bd.penalties = 0

        # [FIX] Issue A: æ±‡æ€»è®¡ç®—ä¹ŸåŒæ­¥ä¿®æ­£
        total = bd.base + bd.dte + bd.gamma + bd.curvature + bd.regime + bd.penalties
        return int(self._clamp(float(total), 0.0, 100.0)), bd

    def evaluate(self, ctx: Context) -> ScanRow:
        tsf = ctx.tsf
        regime = str(tsf["regime"])
        curvature = str(tsf["curvature"])
        short_exp = str(tsf["short_exp"])
        short_dte = int(tsf["short_dte"])
        short_iv = float(tsf["short_iv"])
        base_iv = float(tsf["base_iv"])
        edge = float(tsf["edge"])
        squeeze_ratio = float(tsf.get("squeeze_ratio", 0.0))

        eligible = [p for p in ctx.term if p.dte >= self.policy.min_dte]
        if not eligible:
            # fallback: no eligible list, treat chosen short as the only reference
            rank0_dte = short_dte
            rank0_gamma = 0.0
            short_gamma = 0.0
        else:
            # rank0 refers to nearest *eligible* expiry (respect MIN_SHORT_DTE policy)
            rank0 = eligible[0]
            rank0_dte = int(rank0.dte)
            rank0_gamma = float(rank0.gamma) if rank0.gamma is not None else 0.0

            # find the chosen short point in eligible chain by matching exp or dte
            short_point = None
            for p in eligible:
                if str(p.exp) == short_exp:
                    short_point = p
                    break
            if short_point is None:
                # fallback by dte match
                for p in eligible:
                    if int(p.dte) == short_dte:
                        short_point = p
                        break
            short_gamma = float(short_point.gamma) if (short_point and short_point.gamma is not None) else 0.0

        score, bd = self.scoring.score_calendar(
            regime=regime,
            curvature=curvature,
            edge=edge,
            hv_rank=ctx.hv.hv_rank,
        )

        risk, rbd = self._risk_score(
            ctx,
            short_dte=short_dte,
            short_gamma=short_gamma,
            rank0_dte=rank0_dte,
            rank0_gamma=rank0_gamma,
            regime=regime,
            curvature=curvature,
            squeeze_ratio=squeeze_ratio,
        )

        tag = self._tag(regime, curvature)

        return ScanRow(
            symbol=ctx.symbol,
            price=float(ctx.price),
            short_exp=short_exp,
            short_dte=short_dte,
            short_iv=short_iv,
            base_iv=base_iv,
            edge=edge,
            hv_rank=float(ctx.hv.hv_rank),
            regime=regime,
            curvature=curvature,
            tag=tag,
            cal_score=int(score),
            short_risk=int(risk),
            score_breakdown=bd,
            risk_breakdown=rbd,
        )

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        """
        Probe ranks base..base+N-1 and return first rank with risk<=max_risk AND score>=min_score.
        If none, return (None, summary).
        """
        ranks = self.policy.probe_ranks()
        eligible = [p for p in ctx.term if p.dte >= self.policy.min_dte]
        if not eligible:
            return None, "-"

        # constants for risk computation
        regime = str(ctx.tsf["regime"])
        curvature = str(ctx.tsf["curvature"])
        squeeze_ratio = float(ctx.tsf.get("squeeze_ratio", 0.0))

        rank0 = eligible[0]
        rank0_dte = int(rank0.dte)
        rank0_gamma = float(rank0.gamma) if rank0.gamma is not None else 0.0

        best_attempt: Optional[Recommendation] = None
        best_summary = "-"

        for rk in ranks:
            if rk < 0 or rk >= len(eligible):
                continue

            p = eligible[rk]
            base_iv = float(ctx.tsf["base_iv"])
            edge = (float(p.iv) / base_iv) if base_iv > 0 else 0.0

            score, bd = self.scoring.score_calendar(
                regime=regime,
                curvature=curvature,
                edge=edge,
                hv_rank=ctx.hv.hv_rank,
            )

            short_gamma = float(p.gamma) if p.gamma is not None else 0.0
            risk, rbd = self._risk_score(
                ctx,
                short_dte=int(p.dte),
                short_gamma=short_gamma,
                rank0_dte=rank0_dte,
                rank0_gamma=rank0_gamma,
                regime=regime,
                curvature=curvature,
                squeeze_ratio=squeeze_ratio,
            )

            tag = self._tag(regime, curvature)

            # [FIX] Issue E: Correctly construct Recommendation object with meta dict
            if score >= min_score and risk <= max_risk:
                meta_data = {
                    "rank": int(rk),
                    "exp": str(p.exp),
                    "dte": int(p.dte),
                    "iv": float(p.iv),
                    "tag": tag,
                    "risk_breakdown": rbd,
                    "squeeze_ratio": squeeze_ratio
                }
                
                rec = Recommendation(
                    strategy="CALENDAR",
                    symbol=ctx.symbol,
                    action="OPEN",
                    rationale=f"Score {score} > {min_score}",
                    entry_price=ctx.price,
                    score=int(score),
                    conviction="MEDIUM",
                    meta=meta_data
                )
                summary = f"ok rk{rk} {p.exp} d{p.dte} e{edge:.2f} s{score} r{risk} {tag}"
                return rec, summary

            # Track best attempt
            if best_attempt is None or score > best_attempt.score:
                meta_data = {
                    "rank": int(rk),
                    "exp": str(p.exp),
                    "dte": int(p.dte),
                    "iv": float(p.iv),
                    "tag": tag,
                    "risk_breakdown": rbd,
                    "squeeze_ratio": squeeze_ratio
                }
                
                best_attempt = Recommendation(
                    strategy="CALENDAR",
                    symbol=ctx.symbol,
                    action="WATCH",
                    rationale="Best attempt",
                    entry_price=ctx.price,
                    score=int(score),
                    conviction="LOW",
                    meta=meta_data
                )
                best_summary = f"best rk{rk} {p.exp} d{p.dte} e{edge:.2f} s{score} r{risk} {tag}"

        return None, best_summary

================================================================================
FILE_PATH: src\trade_guardian\strategies\diagonal.py
================================================================================
from __future__ import annotations

from typing import Optional, Tuple, List, Dict, Any

from trade_guardian.domain.models import (
    Context,
    Recommendation,
    ScanRow,
    ScoreBreakdown,
    RiskBreakdown,
)
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.strategies.base import Strategy
from trade_guardian.strategies.blueprint import build_diagonal_blueprint


class DiagonalStrategy(Strategy):
    """
    Strategy #6: Tactical Diagonal (Lightweight)
    
    Logic:
      - Long Leg: Uses the 'Month Anchor' (~30-45 DTE) found by Curve Analysis.
      - Short Leg: Uses the 'Short Anchor' (1-10 DTE).
      - Strikes: 
          Long @ ATM/ITM (High Vega, Low Delta Cost)
          Short @ OTM (Income)
      - Goal: Capture Term Structure Edge without the heavy capital of PMCC LEAPS.
    """
    name = "diagonal"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy

    @staticmethod
    def _clamp(x: float, lo: float, hi: float) -> float:
        return max(lo, min(hi, x))
    
    def _find_strikes(self, ctx: Context) -> Tuple[Optional[float], Optional[str], Optional[float]]:
        """
        å¯»æ‰¾è½»é‡çº§ Diagonal çš„è¡Œæƒä»·ç»“æ„ï¼š
        Long: Month Exp @ First ITM or ATM
        Short: Short Exp @ First OTM
        """
        price = ctx.price
        chain = ctx.raw_chain
        tsf = ctx.tsf
        
        # 1. é”å®šåˆ°æœŸæ—¥ (ç›´æ¥å¤ç”¨ Curve ç®—æ³•çš„ç»“æœ)
        short_exp = tsf.get("short_exp")
        long_exp = tsf.get("month_exp") # ä½¿ç”¨ä¼˜åŒ–è¿‡çš„ 35DTE é”šç‚¹ï¼Œä¸å†æ˜¯ LEAPS

        if not short_exp or not long_exp:
            return None, None, None
        
        # 2. è·å– Strike Map
        call_map = chain.get("callExpDateMap", {})
        
        # è¾…åŠ©å‡½æ•°ï¼šæ‰¾ç‰¹å®šæ—¥æœŸçš„ strikes
        def get_strikes_for_exp(exp_date_str):
            # æ¨¡ç³ŠåŒ¹é…æ—¥æœŸå‰ç¼€
            for k, v in call_map.items():
                if k.startswith(exp_date_str):
                    return sorted([float(s) for s in v.keys()])
            return []

        short_strikes = get_strikes_for_exp(short_exp)
        long_strikes = get_strikes_for_exp(long_exp)

        if not short_strikes or not long_strikes:
            return None, None, None

        # 3. é€‰æ‹©è¡Œæƒä»· (Tactical Light Setup)
        
        # Short Leg: å–å‡ºç¬¬ä¸€æ¡£è™šå€¼ (OTM)
        # é€»è¾‘ï¼šæ‰¾ > Price çš„æœ€å° Strike
        short_strike = next((s for s in short_strikes if s > price * 1.005), None)
        
        # Long Leg: ä¹°å…¥ç¬¬ä¸€æ¡£å®å€¼ (ITM) æˆ– å¹³å€¼ (ATM)
        # é€»è¾‘ï¼šæ‰¾ <= Price çš„æœ€å¤§ Strike
        # è¿™é‡Œç”¨ <= Price ç¡®ä¿æ˜¯ ITM æˆ– ATMï¼Œæ¯” OTM çš„ Short è…¿ä½ï¼Œæ„æˆæ­£å‘å¯¹è§’
        long_strike_candidates = [s for s in long_strikes if s <= price]
        long_strike = long_strike_candidates[-1] if long_strike_candidates else long_strikes[0]

        # [ä¿åº•é€»è¾‘] ç¡®ä¿ Long Strike < Short Strike (Call Diagonal è§„åˆ™)
        if long_strike >= short_strike:
            # å°è¯•ä¸‹ç§» Long Strike
            lower = [s for s in long_strikes if s < short_strike]
            if lower:
                long_strike = lower[-1]
            else:
                # å®åœ¨æ²¡ç©ºé—´ (æ¯”å¦‚è‚¡ä»·æ­£å¥½å¡åœ¨ä¸¤ä¸ª Strike ä¸­é—´)ï¼Œåš Calendar (åŒä»·)
                # Calendar ä¹Ÿæ˜¯ä¸€ç§ç‰¹æ®Šçš„ Diagonal
                long_strike = short_strike

        return short_strike, long_exp, long_strike

    def evaluate(self, ctx: Context) -> ScanRow:
        tsf = ctx.tsf
        hv_rank = float(ctx.hv.hv_rank)
        price = float(ctx.price)
        
        # åŸºç¡€æ•°æ®
        short_iv = float(tsf.get("short_iv", 0))
        edge_month = float(tsf.get("edge_month", 0)) # è¿™æ˜¯å…³é”® Edge
        
        # å¯»æ‰¾ç»“æ„
        short_strike, long_exp, long_strike = self._find_strikes(ctx)
        
        # --- Scoring ---
        bd = ScoreBreakdown(base=50)
        
        # Edge é©±åŠ¨ (æƒé‡æœ€å¤§)
        bd.edge = int(self._clamp(edge_month * 80, -20, 40))
        
        # ç»“æ„åˆ†
        if short_strike and long_strike:
            bd.base += 10 # æˆåŠŸæ„å»ºç»“æ„å¥–åŠ±
        else:
            bd.penalties = -999 # æ„å»ºå¤±è´¥

        # è´Ÿ Edge æƒ©ç½š (Backwardation ä¸é€‚åˆåš Diagonal)
        if edge_month < 0:
            bd.regime = -30

        score = bd.base + bd.regime + bd.edge + bd.hv + bd.curvature + bd.penalties
        
        # --- Risk ---
        # å¤ç”¨ Long Gamma çš„é£é™©é€»è¾‘ï¼Œå› ä¸ºè½»é‡çº§ Diagonal é£é™©ç‰¹å¾ç±»ä¼¼
        risk = 30
        if edge_month < 0: risk += 40
        
        tag = "DIAG"
        if edge_month > 0.15: tag += "+"

        row = ScanRow(
            symbol=ctx.symbol,
            price=price,
            short_exp=str(tsf.get("short_exp")),
            short_dte=int(tsf.get("short_dte", 0)),
            short_iv=short_iv,
            base_iv=float(tsf.get("month_iv", 0)),
            edge=edge_month,
            hv_rank=hv_rank,
            regime=str(tsf.get("regime")),
            curvature=str(tsf.get("curvature")),
            tag=tag,
            cal_score=int(self._clamp(float(score), 0, 100)),
            short_risk=int(self._clamp(float(risk), 0, 100)),
            score_breakdown=bd,
            risk_breakdown=RiskBreakdown(base=risk),
        )

        # æ„å»ºè“å›¾ (åœ¨æ­¤å¤„ç”Ÿæˆï¼Œæ–¹ä¾¿ Orchestrator ç›´æ¥å–ç”¨)
        if short_strike and long_strike:
            bp = build_diagonal_blueprint(
                symbol=ctx.symbol,
                underlying=price,
                chain=ctx.raw_chain,
                short_exp=str(tsf.get("short_exp")),
                long_exp=long_exp,
                target_short_strike=short_strike,
                target_long_strike=long_strike,
                side="CALL"
            )
            row.blueprint = bp
            
            # Meta æ•°æ®ç”¨äºå‰ç«¯æ˜¾ç¤º
            # Meta æ•°æ®ç”¨äºå‰ç«¯æ˜¾ç¤º
        row.meta = {
            "strategy": "diagonal",
            "short_strike": short_strike,
            "long_exp": long_exp,
            "long_strike": long_strike,
            "est_gamma": float(ctx.metrics.gamma) if ctx.metrics else 0.0,
            
            # å®Œæ•´é€ä¼  TSF æ•°æ®
            "micro_exp": tsf.get("micro_exp"),
            "micro_dte": tsf.get("micro_dte"),
            "micro_iv": tsf.get("micro_iv"),
            "edge_micro": float(tsf.get("edge_micro", 0)), # <--- è¡¥ä¸Šäº†ï¼
            
            "month_exp": tsf.get("month_exp"),
            "month_dte": tsf.get("month_dte"),
            "month_iv": tsf.get("month_iv"),
            "edge_month": edge_month,
        }
            
        return row

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        row = self.evaluate(ctx)
        
        if row.cal_score < min_score:
            return None, "Score too low"
            
        if not row.blueprint:
            return None, "Structure build failed"

        rec = Recommendation(
            strategy="DIAGONAL",
            symbol=ctx.symbol,
            action="OPEN DIAGONAL",
            rationale=f"Tactical Diagonal: Edge {row.edge:.2f}",
            entry_price=ctx.price,
            score=row.cal_score,
            conviction="HIGH",
            meta=row.meta
        )
        return rec, "OK"

================================================================================
FILE_PATH: src\trade_guardian\strategies\hv_calendar.py
================================================================================
from __future__ import annotations

from typing import Optional, Tuple

from trade_guardian.domain.models import Context, Recommendation, ScanRow
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.domain.scoring import Scoring, ScoringRules

# å¤ç”¨ calendar çš„é£é™©è¿ç»­æ¨¡å‹ + explainï¼ˆrisk_breakdownï¼‰
from trade_guardian.strategies.calendar import CalendarStrategy


class HVCalendarStrategy(CalendarStrategy):
    """
    Strategy #2: HV-aware calendar
      - score: calendar score + hv adjust (å†™å…¥ score_breakdown.hv)
      - risk : å¤ç”¨ CalendarStrategy._risk_scoreï¼ˆä½ å½“å‰ç‰ˆæœ¬éœ€è¦ gamma/squeeze ç­‰è¾“å…¥ï¼‰
    """
    name = "hv_calendar"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        super().__init__(cfg, policy)

        rules = ScoringRules(min_edge_short_base=float(cfg["rules"]["min_edge_short_base"]))
        self.scoring = Scoring(rules)

        hv_cfg = ((cfg.get("strategies", {}) or {}).get("hv_calendar", {}) or {})
        hv_rules = (hv_cfg.get("hv_rules", {}) or {})

        self.hv_low_rank = float(hv_rules.get("hv_low_rank", 20.0))
        self.hv_mid_rank = float(hv_rules.get("hv_mid_rank", 50.0))
        self.hv_high_rank = float(hv_rules.get("hv_high_rank", 70.0))

        self.hv_low_bonus = int(hv_rules.get("hv_low_bonus", 10))
        self.hv_mid_bonus = int(hv_rules.get("hv_mid_bonus", 4))
        self.hv_high_penalty = int(hv_rules.get("hv_high_penalty", -4))
        self.hv_extreme_penalty = int(hv_rules.get("hv_extreme_penalty", -10))

    def _hv_adjust(self, hv_rank: float) -> int:
        if hv_rank <= self.hv_low_rank:
            return self.hv_low_bonus
        if hv_rank <= self.hv_mid_rank:
            return self.hv_mid_bonus
        if hv_rank <= self.hv_high_rank:
            return 0
        if hv_rank <= 90.0:
            return self.hv_high_penalty
        return self.hv_extreme_penalty

    @staticmethod
    def _find_point_gamma(ctx: Context, exp: str, dte: int) -> float:
        """
        Best-effort: åœ¨ ctx.term é‡ŒæŒ‰ exp+dte æ‰¾å¯¹åº”ç‚¹çš„ gammaã€‚
        æ‰¾ä¸åˆ°å°±é€€åŒ–ä¸º 0.0ï¼ˆé£é™©æ¨¡å‹ä»å¯è·‘ï¼Œåªæ˜¯ gamma åˆ†é¡¹ä¼šåå°/ä¸º 0ï¼‰ã€‚
        """
        for p in ctx.term:
            if str(p.exp) == str(exp) and int(p.dte) == int(dte):
                try:
                    return float(getattr(p, "gamma", 0.0) or 0.0)
                except Exception:
                    return 0.0
        return 0.0

    @staticmethod
    def _best_effort_squeeze_ratio(ctx: Context) -> float:
        """
        squeeze_ratio åœ¨ä½ é¡¹ç›®é‡Œå¯èƒ½ï¼š
          - å·²ç»ç”± TSFeatureBuilder å†™å…¥ ctx.tsf["squeeze_ratio"]
          - æˆ–è€…æ²¡æœ‰ï¼ˆæ—©å…ˆè¾“å‡ºæ›¾å‡ºç° N/Aï¼‰
        è¿™é‡Œç»Ÿä¸€è¿”å› floatï¼Œç¼ºå¤±å°± 0.0ã€‚
        """
        try:
            v = ctx.tsf.get("squeeze_ratio", 0.0)  # type: ignore
            return float(v) if v is not None else 0.0
        except Exception:
            return 0.0

    def evaluate(self, ctx: Context) -> ScanRow:
        tsf = ctx.tsf
        regime = str(tsf["regime"])
        curvature = str(tsf["curvature"])
        short_exp = str(tsf["short_exp"])
        short_dte = int(tsf["short_dte"])
        short_iv = float(tsf["short_iv"])
        base_iv = float(tsf["base_iv"])
        edge = float(tsf["edge"])
        hv_rank = float(ctx.hv.hv_rank)

        # ---------------- score (HV-aware) ----------------
        score, bd = self.scoring.score_calendar(
            regime=regime,
            curvature=curvature,
            edge=edge,
            hv_rank=hv_rank,
        )
        hv_adj = self._hv_adjust(hv_rank)
        bd.hv = int(hv_adj)
        score = int(score + hv_adj)

        # ---------------- risk (reuse calendar continuous model) ----------------
        eligible = [p for p in ctx.term if int(p.dte) >= int(self.policy.min_dte)]
        rank0_dte = int(eligible[0].dte) if eligible else int(short_dte)
        rank0_gamma = float(getattr(eligible[0], "gamma", 0.0) or 0.0) if eligible else 0.0

        short_gamma = self._find_point_gamma(ctx, exp=short_exp, dte=short_dte)
        squeeze_ratio = self._best_effort_squeeze_ratio(ctx)

        # âœ… å…³é”®ï¼šä¸¥æ ¼æŒ‰ä½ å½“å‰ calendar.py çš„ keyword-only å‚æ•°ç­¾åè°ƒç”¨
        risk, rbd = self._risk_score(
            ctx,
            short_dte=short_dte,
            short_gamma=short_gamma,
            rank0_dte=rank0_dte,
            rank0_gamma=rank0_gamma,
            regime=regime,
            curvature=curvature,
            squeeze_ratio=squeeze_ratio,
        )

        tag = self._tag(regime, curvature)

        row = ScanRow(
            symbol=ctx.symbol,
            price=float(ctx.price),
            short_exp=short_exp,
            short_dte=short_dte,
            short_iv=short_iv,
            base_iv=base_iv,
            edge=edge,
            hv_rank=hv_rank,
            regime=regime,
            curvature=curvature,
            tag=tag,
            cal_score=int(score),
            short_risk=int(risk),
            score_breakdown=bd,
        )

        # renderer ç”¨ getattrï¼Œæ‰€ä»¥æˆ‘ä»¬ç”¨ setattr æŒ‚ä¸Š explain å­—æ®µ
        setattr(row, "risk_breakdown", rbd)
        setattr(row, "squeeze_ratio", squeeze_ratio)

        return row

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        ranks = self.policy.probe_ranks()
        eligible = [p for p in ctx.term if int(p.dte) >= int(self.policy.min_dte)]
        if not eligible:
            return None, "-"

        hv_rank = float(ctx.hv.hv_rank)
        hv_adj = self._hv_adjust(hv_rank)
        squeeze_ratio = self._best_effort_squeeze_ratio(ctx)

        rank0_dte = int(eligible[0].dte)
        rank0_gamma = float(getattr(eligible[0], "gamma", 0.0) or 0.0)

        best: Optional[Recommendation] = None
        best_summary = "-"

        for rk in ranks:
            if rk < 0 or rk >= len(eligible):
                continue

            p = eligible[rk]

            base_iv = float(ctx.tsf["base_iv"])
            edge = (float(p.iv) / base_iv) if base_iv > 0 else 0.0

            regime = str(ctx.tsf["regime"])
            curvature = str(ctx.tsf["curvature"])

            score, bd = self.scoring.score_calendar(regime=regime, curvature=curvature, edge=edge, hv_rank=hv_rank)
            bd.hv = int(hv_adj)
            score = int(score + hv_adj)

            short_gamma = float(getattr(p, "gamma", 0.0) or 0.0)

            risk, rbd = self._risk_score(
                ctx,
                short_dte=int(p.dte),
                short_gamma=short_gamma,
                rank0_dte=rank0_dte,
                rank0_gamma=rank0_gamma,
                regime=regime,
                curvature=curvature,
                squeeze_ratio=squeeze_ratio,
            )

            tag = self._tag(regime, curvature)

            if score >= min_score and risk <= max_risk:
                rec = Recommendation(
                    rec_rank=int(rk),
                    rec_exp=str(p.exp),
                    rec_dte=int(p.dte),
                    rec_iv=float(p.iv),
                    rec_edge=float(edge),
                    rec_score=int(score),
                    rec_risk=int(risk),
                    rec_tag=tag,
                    rec_breakdown=bd,
                )
                setattr(rec, "risk_breakdown", rbd)
                setattr(rec, "squeeze_ratio", squeeze_ratio)

                summary = f"ok rk{rk} {p.exp} d{p.dte} e{edge:.2f} s{score} r{risk} {tag}"
                return rec, summary

            if best is None or score > best.rec_score:
                best = Recommendation(
                    rec_rank=int(rk),
                    rec_exp=str(p.exp),
                    rec_dte=int(p.dte),
                    rec_iv=float(p.iv),
                    rec_edge=float(edge),
                    rec_score=int(score),
                    rec_risk=int(risk),
                    rec_tag=tag,
                    rec_breakdown=bd,
                )
                setattr(best, "risk_breakdown", rbd)
                setattr(best, "squeeze_ratio", squeeze_ratio)
                best_summary = f"best rk{rk} {p.exp} d{p.dte} e{edge:.2f} s{score} r{risk} {tag}"

        return None, best_summary


================================================================================
FILE_PATH: src\trade_guardian\strategies\long_gamma.py
================================================================================
from __future__ import annotations
from trade_guardian.domain.models import Context, ScanRow, ScoreBreakdown, RiskBreakdown
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.strategies.base import Strategy

class LongGammaStrategy(Strategy):
    name = "long_gamma"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy

    @staticmethod
    def _clamp(x: float, lo: float, hi: float) -> float:
        return max(lo, min(hi, x))

    def evaluate(self, ctx: Context) -> ScanRow:
        tsf = ctx.tsf
        symbol = ctx.symbol
        
        # 1. æå–ä¸‰ç‚¹æ•°æ®
        short_iv = float(tsf.get("short_iv", 0.0))
        edge_micro = float(tsf.get("edge_micro", 0.0))
        edge_month = float(tsf.get("edge_month", 0.0))
        
        # 2. è¯„åˆ†é€»è¾‘ (åŒå› å­é©±åŠ¨)
        score = 60
        # Micro Edge: çŸ­æœŸå¿…é¡»ä¾¿å®œ (æƒé‡ 40%)
        score += int(self._clamp(edge_micro * 40, -20, 20))
        # Month Edge: ç»“æ„å¿…é¡»æ”¯æ’‘ (æƒé‡ 60%)
        score += int(self._clamp(edge_month * 60, -20, 30))
        
        score = self._clamp(score, 0, 100)

        # 3. æ„é€  Gate ä¿¡å· (ä¸‰æ®µå¼é£æ§)
        gate = "WAIT"
        dna = "QUIET" # ç¨å Orchestrator ä¼šæ›´æ–°åŠ¨èƒ½
        
        # åŸºç¡€é—¨æ§›
        if score > 75 and edge_micro > 0.05 and edge_month > 0.10:
            gate = "READY" # ä»‹äº WAIT å’Œ EXEC ä¹‹é—´ï¼Œç­‰å¾…åŠ¨èƒ½è§¦å‘
        
        if symbol in ["TSLL", "TQQQ", "SOXL", "ONDS", "SMCI", "IWM"]:
            gate = "FORBID"

        # 4. æ„é€  Tag
        tag = "LG"
        if edge_micro > 0.15: tag += "-M" # Micro æå¥½
        if edge_month > 0.30: tag += "-K" # Month æå¥½ (K=Structure)

        # 5. è¿”å› ScanRow (meta æºå¸¦å…¨é‡åŒåŸºå‡†æ•°æ®)
        bd = ScoreBreakdown(base=60) 
        rbd = RiskBreakdown(base=20)
        
        row = ScanRow(
            symbol=symbol,
            price=float(ctx.price),
            short_exp=tsf.get("short_exp", ""),
            short_dte=int(tsf.get("short_dte", 0)),
            short_iv=short_iv,
            base_iv=tsf.get("month_iv", 0.0), # å…¼å®¹è€å­—æ®µ
            edge=edge_month,                 # å…¼å®¹è€å­—æ®µ
            hv_rank=50.0,
            regime="NORMAL",
            curvature="FLAT",
            tag=tag,
            cal_score=int(score),
            short_risk=20,
            score_breakdown=bd,
            risk_breakdown=rbd,
        )
        
        # å°†åŒåŸºå‡†æ”¾å…¥ metaï¼Œä¾› UI æ¸²æŸ“
        row.meta = {
            "micro_exp": tsf.get("micro_exp"),
            "micro_dte": tsf.get("micro_dte"),
            "micro_iv": tsf.get("micro_iv"),
            "edge_micro": edge_micro,
            
            "month_exp": tsf.get("month_exp"),
            "month_dte": tsf.get("month_dte"),
            "month_iv": tsf.get("month_iv"),
            "edge_month": edge_month,
            
            "est_gamma": float(ctx.metrics.gamma) * 2.0 if ctx.metrics else 0.0,
            "strike": round(float(ctx.price), 1)
        }
        return row

================================================================================
FILE_PATH: src\trade_guardian\strategies\placeholder.py
================================================================================
from __future__ import annotations

from trade_guardian.domain.models import Context, ScanRow, ScoreBreakdown
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.strategies.base import Strategy


class PlaceholderStrategy(Strategy):
    """
    Strategy #2/#3 placeholder.
    Exists to prove the framework: registry, CLI, orchestrator wiring.
    Not intended for trading logic.
    """
    name = "placeholder"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy

    def evaluate(self, ctx: Context) -> ScanRow:
        bd = ScoreBreakdown(base=0)
        return ScanRow(
            symbol=ctx.symbol,
            price=float(ctx.price),
            short_exp=ctx.tsf.get("short_exp", ""),
            short_dte=int(ctx.tsf.get("short_dte", 0)),
            short_iv=float(ctx.tsf.get("short_iv", 0.0)),
            base_iv=float(ctx.tsf.get("base_iv", 0.0)),
            edge=float(ctx.tsf.get("edge", 0.0)),
            hv_rank=float(ctx.hv.hv_rank),
            regime=str(ctx.tsf.get("regime", "FLAT")),
            curvature=str(ctx.tsf.get("curvature", "NORMAL")),
            tag="NA",
            cal_score=0,
            short_risk=100,
            score_breakdown=bd,
        )


================================================================================
FILE_PATH: src\trade_guardian\strategies\strategy2_stub.py
================================================================================
from typing import Optional, Tuple

from trade_guardian.domain.models import Context, ScanRow, Recommendation, ScoreBreakdown


class Strategy2Stub:
    """
    Reserved for strategy #2. Framework is in place.
    This stub intentionally does not implement real logic yet.
    """
    name = "strategy2"

    def __init__(self, cfg: dict):
        self.cfg = cfg

    def evaluate(self, ctx: Context) -> ScanRow:
        raise NotImplementedError("strategy2 is not implemented yet.")

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        return None, "-"


================================================================================
FILE_PATH: src\trade_guardian\strategies\__init__.py
================================================================================


================================================================================
FILE_PATH: src\trade_guardian.egg-info\dependency_links.txt
================================================================================



================================================================================
FILE_PATH: src\trade_guardian.egg-info\requires.txt
================================================================================
requests
pandas
numpy
tabulate
colorama


================================================================================
FILE_PATH: src\trade_guardian.egg-info\SOURCES.txt
================================================================================
pyproject.toml
src/trade_guardian/__init__.py
src/trade_guardian.egg-info/PKG-INFO
src/trade_guardian.egg-info/SOURCES.txt
src/trade_guardian.egg-info/dependency_links.txt
src/trade_guardian.egg-info/requires.txt
src/trade_guardian.egg-info/top_level.txt
src/trade_guardian/app/__init__.py
src/trade_guardian/app/cli.py
src/trade_guardian/app/orchestrator.py
src/trade_guardian/app/renderer.py
src/trade_guardian/domain/__init__.py
src/trade_guardian/domain/features.py
src/trade_guardian/domain/hv.py
src/trade_guardian/domain/models.py
src/trade_guardian/domain/policy.py
src/trade_guardian/domain/registry.py
src/trade_guardian/domain/scoring.py
src/trade_guardian/infra/__init__.py
src/trade_guardian/infra/cache.py
src/trade_guardian/infra/config.py
src/trade_guardian/infra/rate_limit.py
src/trade_guardian/infra/schwab_client.py
src/trade_guardian/infra/schwab_token_manager.py
src/trade_guardian/infra/tickers.py
src/trade_guardian/strategies/__init__.py
src/trade_guardian/strategies/base.py
src/trade_guardian/strategies/calendar.py
src/trade_guardian/strategies/placeholder.py
src/trade_guardian/strategies/strategy2_stub.py

================================================================================
FILE_PATH: src\trade_guardian.egg-info\top_level.txt
================================================================================
trade_guardian



================================================================================
FILE_PATH: pyproject.toml
================================================================================
[build-system]
requires = ["setuptools>=68"]
build-backend = "setuptools.build_meta"

[project]
name = "trade-guardian"
version = "0.1.0"
requires-python = ">=3.10"
dependencies = [
  "requests",
  "pandas",
  "numpy",
  "tabulate",
  "colorama",
]

[tool.setuptools]
package-dir = {"" = "src"}

[tool.setuptools.packages.find]
where = ["src"]


================================================================================
FILE_PATH: README.md
================================================================================


# ğŸ§  Trade Guardian (v2.0)

**Trade Guardian** æ˜¯ä¸€æ¬¾é¢å‘ä¸“ä¸šæœŸæƒäº¤æ˜“è€…çš„è‡ªåŠ¨åŒ–æ‰«æä¸æ‰§è¡Œè®¡åˆ’å·¥å…·ã€‚å®ƒä¸ä»…èƒ½å‘ç°å¸‚åœºä¸­å®šä»·åä½çš„æ³¢åŠ¨ç‡æœºä¼šï¼ˆEdgeï¼‰ï¼Œæ›´èƒ½é€šè¿‡å†…ç½®çš„ **Planner (è®¡åˆ’å™¨)** å¼ºåˆ¶æ‰§è¡Œç¡¬æ€§é£é™©æ‹¦æˆªã€‚

> **è®¾è®¡å“²å­¦**ï¼šScanner è´Ÿè´£æµ·é€‰æœºä¼šï¼ŒPlanner è´Ÿè´£ç¡®ä¿å¯äº¤æ˜“æ€§ä¸ç¡¬é£é™©é—¸é—¨ã€‚

---

## ğŸš€ æ ¸å¿ƒè¿›åŒ–åŠŸèƒ½

### 1. çœŸå®æ•°æ®é©±åŠ¨ (Schwab API)

ç³»ç»Ÿå·²å®Œå…¨æ‰“é€š **Schwab API**ï¼Œå®æ—¶è·å–ï¼š

* æ ‡çš„ç°ä»·ã€å†å²æ³¢åŠ¨ç‡ (HV) åŠ HV Rankã€‚
* ATM æœŸæƒé“¾ã€éšå«æ³¢åŠ¨ç‡ (IV) æœŸé™ç»“æ„åŠ Greeks (Gamma/Delta/Theta)ã€‚
* è‡ªåŠ¨é”å®šæµåŠ¨æ€§æœ€ä½³çš„ **æœˆåº¦æœŸæƒåˆçº¦ (Monthly OpEx)**ã€‚

### 2. å¢å¼ºå‹é£é™©å¼•æ“ (The Guardian)

* **Total Gamma ç›‘æµ‹**ï¼šè‡ªåŠ¨è®¡ç®—ç»„åˆï¼ˆå¦‚è·¨å¼ç»„åˆ Straddleï¼‰çš„æ€» Gammaï¼Œå¹¶è¿›è¡Œåˆ†çº§ï¼š
* **EXTREME â›”** (Î“ â‰¥ 0.20): æç«¯æ³¢åŠ¨é£é™©ã€‚
* **HIGH âš ï¸** (Î“ â‰¥ 0.12): é«˜é£é™©ï¼Œéœ€å¤§å¹…ç¼©å‡ä»“ä½ã€‚
* **ELEVATED ğŸ”¸** (Î“ â‰¥ 0.08): é¢„è­¦åŒºã€‚


* **PMCC å®‰å…¨é”**ï¼šç¡¬æ€§æ‰§è¡Œ `Debit < Width` æ£€æŸ¥ï¼Œè‡ªåŠ¨æ‹¦æˆªæ³¨å®šäºæŸçš„é”æ­»äº¤æ˜“ï¼ˆLocked Lossï¼‰ï¼Œå¹¶ç»™å‡ºä¿®æ­£å»ºè®®ã€‚

### 3. äº¤æ˜“å‘˜çœ‹æ¿å¼è¾“å‡º

* **Gate çŠ¶æ€åˆ—**ï¼šåœ¨æ‰«æç»“æœä¸­ç›´è§‚æ˜¾ç¤º `âœ… å¯æ‰§è¡Œ`ã€`âš ï¸ é«˜é£é™©`ã€`â›” å·²æ‹’ç»`ã€‚
* **Trader's Sort**ï¼šä¼˜å…ˆæ’åˆ—â€œé«˜ Edgeã€ä½ Riskã€Gate âœ…â€çš„æ ‡çš„ã€‚
* **Actionable Blueprints**ï¼šç”Ÿæˆå«å…·ä½“æ—¥æœŸã€è¡Œæƒä»·ã€æ–¹å‘åŠæˆæœ¬ä¼°ç®—çš„æ‰§è¡Œè“å›¾ã€‚

---

## ğŸ› ï¸ å®‰è£…ä¸é…ç½®

1. **ç¯å¢ƒè¦æ±‚**ï¼šPython 3.8+
2. **å®‰è£…ä¾èµ–**ï¼š
```bash
pip install requests pandas numpy

```


3. **æ•°æ®é…ç½®**ï¼š
* åœ¨ `data/tickers.csv` ä¸­å¡«å…¥ä½ æƒ³æ‰«æçš„è‚¡ç¥¨ä»£ç ï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰ã€‚
* ç¡®ä¿ `src/trade_guardian/infra/schwab_token_manager.py` èƒ½å¤Ÿè·å–æœ‰æ•ˆçš„ API Tokenã€‚



---

## ğŸ“– ä½¿ç”¨æŒ‡å—

### å¯åŠ¨å…¨è‡ªåŠ¨æ‰«æ

```bash
python src/trade_guardian.py scanlist --strategy auto --days 600 --detail --top 5

```

**å‚æ•°è¯´æ˜**ï¼š

* `--strategy auto`: åŒæ—¶è¿è¡Œ Long Gamma (Straddle) å’Œ Diagonal (PMCC) ç­–ç•¥ã€‚
* `--days 600`: æ‰«æè¿œç«¯æœŸæƒé“¾ï¼ˆç”¨äº PMCC å¯»æ‰¾ LEAPSï¼‰ã€‚
* `--detail`: è¾“å‡ºå…·ä½“çš„æ‰§è¡Œè“å›¾ï¼ˆActionable Blueprintsï¼‰ã€‚
* `--top 5`: ç»è¿‡æ’åºåï¼Œåªæ˜¾ç¤ºæœ€ä¼˜è´¨çš„å‰ 5 ä¸ªäº¤æ˜“è®¡åˆ’ã€‚

---

## ğŸ“Š è¾“å‡ºè§£è¯»

### æ‰«æè¡¨ (Scanner View)

| Sym | Px | ShortExp | DTE | ShortIV | Edge | Risk | Gate |
| --- | --- | --- | --- | --- | --- | --- | --- |
| AMD | 202.0 | 2026-01-16 | 29 | 45.2% | +0.13x | 20 | âœ… |
| ONDS | 7.87 | 2026-01-16 | 29 | 120.4% | +0.26x | 70 | âš ï¸ |
| MSTR | 159.2 | 2026-01-16 | 29 | 77.6% | +0.02x | 30 | â›” |

### æ‰§è¡Œè“å›¾ç¤ºä¾‹ (Execution Plan)

```text
 MSTR DIAGONAL    Est.Debit: $55.87
    +1 2026-06-18 111.0  CALL
    -1 2026-01-16 162.0  CALL
    ==============================
    â›” REJECTED: Debit > Width. Excess: $4.87.
    ==============================
    Strategy Gate: Blocked by Risk Policy.
       â€¢ Try buying deeper ITM LEAPS or RAISING Short Strike.

```

---

## ğŸ§¾ è¯Šæ–­æŒ‡æ ‡ (Diagnostics)

* **Avg |Edge|**: å¸‚åœºæ•´ä½“æ³¢åŠ¨ç‡åç¦»å¼ºåº¦ã€‚
* **Cheap Vol (%)**: å¸‚åœºä¸­å¤„äºâ€œä¾¿å®œâ€çŠ¶æ€ï¼ˆIV < HVï¼‰çš„æ ‡çš„æ¯”ä¾‹ï¼Œä½œä¸ºå¤šç©ºæƒ…ç»ªæ¸©åº¦è®¡ã€‚

---

## âš–ï¸ å…è´£å£°æ˜

æœ¬å·¥å…·ä»…ä¾›ç ”ç©¶ä¸å‚è€ƒä½¿ç”¨ï¼Œä¸æ„æˆä»»ä½•æŠ•èµ„å»ºè®®ã€‚æœŸæƒäº¤æ˜“æ¶‰åŠé«˜é£é™©ï¼Œåœ¨ä½¿ç”¨è“å›¾æ‰§è¡Œäº¤æ˜“å‰ï¼Œè¯·åŠ¡å¿…æ ¸å®å®æ—¶æŠ¥ä»·å¹¶è¿›è¡Œä¸ªäººé£é™©è¯„ä¼°ã€‚

---

**Current Version**: 2.0.0 | **Last Updated**: 2025-12-18

================================================================================
FILE_PATH: requirements.txt
================================================================================
requests
pandas
numpy
tabulate
colorama
PyYAML


================================================================================
FILE_PATH: test_action.py
================================================================================
import sys
import os

# 1. è·¯å¾„è®¾ç½®
current_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, os.path.join(current_dir, "src"))

from trade_guardian.infra.config import load_config, DEFAULT_CONFIG
from trade_guardian.infra.schwab_client import SchwabClient
from trade_guardian.action.sniper import Sniper

# 2. åˆå§‹åŒ–
print("ğŸš€ Initializing Trade Guardian Action Test...")
cfg = load_config("config/config.json", DEFAULT_CONFIG)
client = SchwabClient(cfg)
sniper = Sniper(client)

# ==========================================
# 3. æµ‹è¯•åœºæ™¯ï¼šNVDA Diagonal (æ¨¡æ‹Ÿ Radar ä¿¡å·)
# ==========================================
symbol = "NVDA"
strategy = "DIAGONAL"

# Radar æ¨èå‚æ•°
short_exp = "2025-12-26"
short_strike = 185.0  # å–å‡ºè¿‘ç«¯ OTM Call

long_exp = "2026-01-23" # è¿œç«¯ Month Anchor
long_strike = 180.0   # ä¹°å…¥è¿œç«¯ ITM Call

# Fire!
result = sniper.lock_target(
    symbol=symbol, 
    strategy=strategy, 
    short_exp=short_exp, 
    short_strike=short_strike,
    long_exp=long_exp,
    long_strike=long_strike
)

print("\nâœ… Final Result:", result)

================================================================================
FILE_PATH: TRADE GUARDIAN è·¯ç”±çŸ©é˜µ.md
================================================================================
**â€œShape Ã— Strategy Ã— Gateâ€ è·¯ç”±çŸ©é˜µ**ï¼ˆTrade Graduation / Tactical Mode ä¸“ç”¨ï¼‰ã€‚
**å…ˆå®šå½¢æ€(Shape)** â†’ **å†å®šç­–ç•¥(Route)** â†’ **å†å®šé—¨æ§›(Gate)** â†’ **æœ€åç»™æ‰§è¡ŒæŒ‡ä»¤**ã€‚

---

# TRADE GUARDIAN è·¯ç”±çŸ©é˜µï¼ˆBrain + Gate ç»Ÿä¸€ç‰ˆï¼‰

## 0) æ ¸å¿ƒè¾“å…¥ï¼ˆç³»ç»Ÿåªçœ‹è¿™å‡ é¡¹ï¼‰

* `em = edge_micro`ï¼ˆå‰ç«¯ç»“æ„ä¼˜åŠ¿ï¼‰
* `ek = edge_month`ï¼ˆåç«¯ç»“æ„ä¼˜åŠ¿ï¼‰
* `short_dte`ï¼ˆçŸ­è…¿ DTEï¼‰
* `regime`ï¼ˆBACKWARDATION / CONTANGO / FLATï¼‰
* `is_squeeze`ï¼ˆmicro_iv > month_iv * 1.05ï¼‰
* `curvature`ï¼ˆSPIKY_FRONT / NORMALï¼‰
* `momentum`ï¼ˆCRUSH / QUIET / TREND / PULSEï¼‰
* `est_gamma`ï¼ˆé£é™©ç¡¬é˜ˆå€¼ï¼‰
* Blueprint æ˜¯å¦æˆåŠŸï¼ˆbp.errorï¼‰

---

## 1) Shape åˆ†ç±»çŸ©é˜µï¼ˆå…ˆæŠŠåœ°å½¢è¯´æ¸…æ¥šï¼‰

æŒ‰ **ä¼˜å…ˆçº§** ä»ä¸Šåˆ°ä¸‹åŒ¹é…ï¼ˆå‘½ä¸­å³åœæ­¢ï¼‰ï¼š

| Priority | Shape        | åˆ¤å®šè§„åˆ™ï¼ˆå»ºè®®æ ‡å‡†ï¼‰                                               | äº¤æ˜“å«ä¹‰               |
| -------: | ------------ | -------------------------------------------------------- | ------------------ |
|        1 | **BACKWARD** | `regime == BACKWARDATION`                                | å€’æŒ‚ï¼Œå–è¿‘ç«¯=è‡ªæ€          |
|        2 | **FFBS**     | `ek >= 0.20 and em < 0.08`                               | å‰ç«¯å¹³ç¨³ã€åç«¯é™¡å³­ï¼šé»„é‡‘å¯¹è§’çº¿    |
|        3 | **SPIKE**    | `is_squeeze == True OR em >= 0.12`ï¼ˆ*ä¸è¦ç”¨ curvature å•ç‹¬è§¦å‘*ï¼‰ | å‰ç«¯æŒ¤å‹/äº‹ä»¶æ³¢ï¼šgamma é£é™©é«˜ |
|        4 | **STEEP**    | `ek >= 0.20`                                             | æ­£å¸¸åç«¯é™¡å³­ï¼Œæœ‰ç»“æ„å¯åƒ       |
|        5 | **MILD**     | `0.15 <= ek < 0.20`                                      | è½»åº¦ç»“æ„ï¼Œè¾¹ç¼˜ä¸€èˆ¬          |
|        6 | **FLAT**     | `ek < 0.15`                                              | ç»“æ„å¹³å¦ï¼Œé çº¯æ³¢åŠ¨          |

> å¤‡æ³¨ï¼šä½ ç°åœ¨è¾“å‡ºé‡Œ NVDAï¼ˆek=0.15ï¼‰åº”è¯¥æ›´åƒ **MILD** è€Œä¸æ˜¯ STEEPã€‚
> SPY é‚£ç§ â€œè¶…çŸ­ç«¯ä½IVå¯¼è‡´ curvature è™šè§¦å‘â€ ä¸åº”ç›´æ¥å˜ SPIKEâ€”â€”SPIKE å¿…é¡»é  em / squeeze ç¡®è®¤ã€‚

---

## 2) Routeï¼ˆç­–ç•¥è·¯ç”±ï¼‰çŸ©é˜µï¼šShape â†’ é€‰å“ªç§ç­–ç•¥

è¿™éƒ¨åˆ†å°±æ˜¯ä½  Brain V5 çš„â€œç»“æ„ä¼˜å…ˆâ€å“²å­¦ + äº¤æ˜“å‘˜ç°å®ï¼š

| Shape        | é»˜è®¤ç­–ç•¥ Route                    | åŸå› ï¼ˆäº¤æ˜“è¯­è¨€ï¼‰                     |
| ------------ | ----------------------------- | ---------------------------- |
| **BACKWARD** | **LGï¼ˆLong Gamma / Straddleï¼‰** | å€’æŒ‚æ—¶å–è¿‘ç«¯é£é™©çˆ†ç‚¸ï¼Œåªèƒ½ä¹° gamma é˜²å®ˆ      |
| **FFBS**     | **DIAGï¼ˆDiagonalï¼‰**            | å‰ç«¯ä½IV + åç«¯é«˜æº¢ä»·ï¼ŒTheta/Vega å·®æœ€è‚¥ |
| **STEEP**    | **DIAG ä¼˜å…ˆ**ï¼ˆè‹¥æ„å»ºå¤±è´¥â†’LGï¼‰         | æœ‰ç»“æ„å¯æ”¶å‰²ï¼Œä¸”å‰ç«¯æœªå¿…å±é™©               |
| **SPIKE**    | **LG ä¼˜å…ˆ**ï¼ˆç‰¹æ®Šæƒ…å†µæ‰ DIAGï¼‰         | å‰ç«¯æŒ¤å‹ï¼ŒçŸ­è…¿ gamma åå™¬æ¦‚ç‡é«˜          |
| **MILD**     | **LG ä¼˜å…ˆ**ï¼ˆé™¤é ek å¾ˆç¨³/ä½ æƒ³åŠ æ¡ä»¶ï¼‰     | ç»“æ„è¾¹ç¼˜ï¼Œåš DIAG æ€§ä»·æ¯”ä¸€èˆ¬            |
| **FLAT**     | **LG**                        | æ²¡ç»“æ„å°±èµŒæ³¢åŠ¨æ‰©å¼                     |

**è¡¥å……ï¼šDIAG æ„å»ºå¤±è´¥å…œåº•**

* `if diagonal.evaluate(ctx) å¤±è´¥ or metaç¼º long_strike` â†’ è‡ªåŠ¨å›è½ **LG**
  ï¼ˆä½ å·²ç»åšäº†ï¼‰

---

## 3) Gateï¼ˆæ”¾è¡ŒçŸ©é˜µï¼‰ï¼šRoute + Shape + Momentum â†’ WAIT / LIMIT / EXEC

Gate æ˜¯ â€œèƒ½ä¸èƒ½åš / æ€ä¹ˆåšâ€ çš„æœ€åè£åˆ¤ï¼Œåˆ†ä¸‰å±‚ï¼š

### 3.1 Hard Killï¼ˆæ— æ¡ä»¶ FORBIDï¼‰

| æ¡ä»¶                        | Gate       |
| ------------------------- | ---------- |
| `bp is None` æˆ– `bp.error` | **FORBID** |
| `est_gamma >= 0.30`       | **FORBID** |
| `momentum == CRUSH`       | **FORBID** |

---

### 3.2 ç»“æ„é—¨æ§›ï¼ˆSoft Gateï¼‰

ä½ ç°åœ¨çš„åº•çº¿å‚æ•°ï¼š

* `MICRO_MIN = 0.10`
* `MONTH_MIN = 0.15`

#### A) å¯¹ LGï¼ˆLong Gammaï¼‰

LG è¦æ±‚â€œå‰ç«¯ä¸èƒ½å¤ªçƒ‚â€ï¼Œå¦åˆ™ä¹°äº†ä¹Ÿæ˜¯ç£¨æŸï¼š

| æ¡ä»¶                                  | Gate     |
| ----------------------------------- | -------- |
| `em < MICRO_MIN AND ek < MONTH_MIN` | **WAIT** |
| å…¶å®ƒ                                  | è¿›å…¥åŠ¨èƒ½åˆ¤å®š   |

#### B) å¯¹ DIAGï¼ˆDiagonalï¼‰â€”â€”æ ¸å¿ƒï¼šçœ‹ ekï¼Œå¾®ç»“æ„è±å… em

| Shape                   | DIAG çš„ç»“æ„è¦æ±‚                            | Gate        |
| ----------------------- | ------------------------------------- | ----------- |
| **FFBS / STEEP**        | `ek >= MONTH_MIN`ï¼ˆè±å… emï¼‰              | è¿›å…¥åŠ¨èƒ½åˆ¤å®š      |
| **å…¶å®ƒï¼ˆFLAT/MILD/SPIKEï¼‰** | `ek >= MONTH_MIN AND em >= MICRO_MIN` | å¦åˆ™ **WAIT** |

---

### 3.3 åŠ¨èƒ½åˆ¤å®šï¼ˆEXEC vs LIMITï¼‰

åŠ¨èƒ½æ¥è‡ªä½ çš„ 15m IV å˜åŒ–ï¼ˆQUIET/TREND/PULSEï¼‰ï¼š

| Momentum          | Gate      | æ‰§è¡Œå«ä¹‰        |
| ----------------- | --------- | ----------- |
| **PULSE / TREND** | **EXEC**  | åŠ¨èƒ½ç¡®ç«‹ï¼šå¯ä»¥ä¸»åŠ¨æˆäº¤ |
| **QUIET**         | **LIMIT** | ç­‰è§¦å‘ï¼šæŒ‚å•æ½œä¼    |

---

## 4) æœ€é‡è¦çš„â€œäº¤æ˜“å‘˜è¡¥ä¸â€ï¼šSPIKE çš„ DIAG é™çº§è§„åˆ™ï¼ˆå¼ºçƒˆå»ºè®®ï¼‰

å› ä¸º SPIKE æ˜¯æœ€å®¹æ˜“æŠŠä½ ç‚¸æ‰çš„å½¢æ€ã€‚

### è§„åˆ™ï¼ˆæ¨èæœ€å°è¡¥ä¸ï¼‰

* å¦‚æœ `tag` æ˜¯ DIAG ä¸” `shape == SPIKE` ä¸” `short_dte <= 7` ä¸” `momentum == QUIET`
  â†’ **å¼ºåˆ¶ WAIT**ï¼ˆä¸å…è®¸ LIMIT è¢«åŠ¨åƒ gamma é£é™©ï¼‰

| æ¡ä»¶                                    | Gate               |
| ------------------------------------- | ------------------ |
| `DIAG & SPIKE & short_dte<=7 & QUIET` | **WAIT**           |
| `DIAG & SPIKE & (TREND/PULSE)`        | **EXEC**ï¼ˆåªæœ‰åŠ¨èƒ½ç¡®è®¤æ‰æ‰“ï¼‰ |

è¿™æ¡ä¼šè®© TSLA/QQQ/TQQQ è¿™ç§ â€œç»“æ„å¥½ä½†å‰ç«¯ä¸å®‰ç¨³â€ ä¸ä¼šå¤©å¤© LIMITã€‚

---

# æœ€ç»ˆæ€»è¡¨ï¼ˆä½ å¯ä»¥è´´ README çš„â€œå†³ç­–æ€»çŸ©é˜µâ€ï¼‰

æŒ‰å®é™…æ‰§è¡Œé¡ºåºï¼š

1. **Hard Kill**ï¼šbp/error, gamma, CRUSH â†’ FORBID
2. **Shape**ï¼šBACKWARD / FFBS / SPIKE / STEEP / MILD / FLAT
3. **Route**ï¼šBACKWARDâ†’LGï¼›FFBS/STEEPâ†’DIAGï¼›SPIKE/MILD/FLATâ†’LGï¼ˆSPIKE ç‰¹åˆ¤ï¼‰
4. **Gate-ç»“æ„**ï¼šDIAG çœ‹ ekï¼ˆFFBS/STEEP è±å… emï¼‰ï¼›LG çœ‹ em/ek åŒä½
5. **Gate-åŠ¨èƒ½**ï¼šTREND/PULSEâ†’EXECï¼›QUIETâ†’LIMIT
6. **SPIKE-DIAG é™çº§è¡¥ä¸**ï¼šSPIKE + DIAG + short_dte<=7 + QUIET â†’ WAIT

---

## å¿«é€Ÿ sanity checkï¼ˆç”¨ä½ å½“å‰è¾“å‡ºéªŒè¯ï¼‰

* **IWMï¼šFFBS + ek=0.24 + em=0.01**
  â†’ Route=DIAGï¼ŒGate ä¸æŸ¥ emï¼ˆè±å…ï¼‰â†’ QUIET â†’ LIMIT âœ…
* **SPYï¼šè¶…çŸ­ç«¯ä½IVï¼Œä½† em ä½ã€ek=0.17ï¼ˆMILDï¼‰**
  â†’ Route=LG â†’ em/ek æ˜¯å¦åŒä½ï¼Ÿä¸åŒä½ â†’ QUIET â†’ LIMITï¼ˆä½†ä½ ä¹Ÿå¯ä»¥è®© MILD é»˜è®¤ WAITï¼‰
* **TSLAï¼šSPIKE + DIAG + QUIET + short_dte=6**
  â†’ ä¼šè¢«â€œSPIKE-DIAG é™çº§è¡¥ä¸â€æ‰“å› WAITï¼ˆé¿å…æŒ‚å•è¢«åŠ¨åƒé£é™©ï¼‰âœ…

---


# ğŸ§  Trade Guardian: Decision Engine Logic

Trade Guardian é‡‡ç”¨ **"Shape-First" (å½¢æ€ä¼˜å…ˆ)** çš„å†³ç­–é€»è¾‘ï¼Œå°†æœŸæƒæœŸé™ç»“æ„æ•°æ®è½¬åŒ–ä¸ºå…·ä½“çš„æˆ˜æœ¯æŒ‡ä»¤ã€‚ç³»ç»Ÿä¸å†å•çº¯ä¾èµ–ç»å¯¹æ³¢åŠ¨ç‡æ•°å€¼ï¼Œè€Œæ˜¯ä¾èµ–**ç›¸å¯¹ç»“æ„ä¼˜åŠ¿**ã€‚

### æ ¸å¿ƒæµç¨‹
`Raw Data` $\to$ `Stabilized Edges` $\to$ `Shape Classifier` $\to$ `Strategy Route` $\to$ `Safety Gate` $\to$ `Action`

---

## 1. æ ¸å¿ƒè¾“å…¥ (Key Inputs)

ä¸ºäº†æ¶ˆé™¤çŸ­ç«¯å™ªéŸ³å¹¶è¿˜åŸçœŸå®åœ°å½¢ï¼Œç³»ç»Ÿåœ¨åŸå§‹æ•°æ®ä¹‹ä¸Šè¿›è¡Œäº†æ•°å­¦ç¨³å®šåŒ–å¤„ç†ï¼š

* **Edge Micro (`em`)**: å‰ç«¯ç»“æ„ä¼˜åŠ¿ã€‚
    * *Stabilizer V3*: é‡‡ç”¨ `1-10 DTE Median Base` æ¶ˆé™¤å•ç‚¹å™ªéŸ³ï¼Œå¹¶å¯¹ `< 6 DTE` è¿›è¡Œè¿ç»­å¹³æ»‘è¡°å‡ã€‚
* **Edge Month (`ek`)**: åç«¯ç»“æ„ä¼˜åŠ¿ã€‚
    * *Anchor*: åŠ¨æ€é”šå®š `30-45 DTE` æˆ˜æœ¯åŒºã€‚
* **Regime**: å¸‚åœºçŠ¶æ€ (`BACKWARDATION` / `CONTANGO` / `FLAT`).
* **Momentum**: 15åˆ†é’Ÿçº§åˆ« IV åŠ¨èƒ½ (`PULSE` / `TREND` / `QUIET` / `CRUSH`).

---

## 2. å½¢æ€åˆ†ç±»çŸ©é˜µ (Shape Matrix)

ç³»ç»ŸæŒ‰ **ä¼˜å…ˆçº§ (Priority)** ä¾æ¬¡è¯†åˆ«ä»¥ä¸‹æœŸé™ç»“æ„å½¢æ€ï¼Œå‘½ä¸­å³åœæ­¢ï¼š

| ä¼˜å…ˆçº§ | å½¢æ€ (Shape) | åˆ¤å®šè§„åˆ™ (ä¼ªä»£ç ) | äº¤æ˜“å«ä¹‰ |
| :---: | :--- | :--- | :--- |
| **1** | **BACKWARD** | `Regime == BACKWARDATION` | **å€’æŒ‚**ã€‚å–æ–¹ç¦åŒºï¼Œé˜²å¾¡æ¨¡å¼ã€‚ |
| **2** | **FFBS** | `ek >= 0.20` & `em < 0.08` | **å‰å¹³åé™¡** (Front-Flat Back-Steep)ã€‚é»„é‡‘å¯¹è§’çº¿å½¢æ€ã€‚ |
| **3** | **SPIKE** | `Squeeze` æˆ– `em >= 0.12` | **å‰ç«¯åˆºå¤´**ã€‚çŸ­æœŸ IV æš´æ¶¨ï¼ŒGamma é£é™©é«˜ã€‚ |
| **4** | **STEEP** | `ek >= 0.20` | **é™¡å³­**ã€‚æ ‡å‡†çš„æœŸé™ç»“æ„å¥—åˆ©æœºä¼šã€‚ |
| **5** | **MILD** | `0.15 <= ek < 0.20` | **æ¸©å’Œ**ã€‚ç»“æ„ä¸€èˆ¬ï¼Œå¤„äºä¸´ç•Œç‚¹ã€‚ |
| **6** | **FLAT** | `ek < 0.15` | **å¹³å¦**ã€‚æ— ç»“æ„ä¼˜åŠ¿ï¼Œçº¯æ³¢åŠ¨ç‡åšå¼ˆã€‚ |

---

## 3. ç­–ç•¥è·¯ç”± (Strategy Route)

åŸºäº **Brain V5 (ç»“æ„ä¼˜å…ˆï¼Œä½æ³¢å…œåº•)** å“²å­¦ï¼š

### ğŸŸ¢ AUTO-DIAG (Diagonal Strategy)
**è§¦å‘é€»è¾‘**ï¼šå½“ç»“æ„ä¼˜åŠ¿æ˜æ˜¾æ—¶è§¦å‘ã€‚
* **é€‚ç”¨å½¢æ€**ï¼š`FFBS`, `STEEP`, æˆ– `edge_month >= 0.20`ã€‚
* **æ ¸å¿ƒæ€æƒ³**ï¼šåªè¦å¡åº¦å¤Ÿé™¡ï¼Œå³ä½¿ç»å¯¹ IV è¾ƒä½ï¼Œä¹Ÿä¼˜å…ˆåˆ©ç”¨æ—¶é—´ä»·å€¼è¡°å‡å·®å¼‚ï¼ˆTheta/Vega Arbï¼‰è·åˆ©ã€‚

### ğŸ”µ AUTO-LG (Long Gamma / Straddle)
**è§¦å‘é€»è¾‘**ï¼šå½“ç»“æ„å¹³åº¸æˆ–æ³¢åŠ¨ç‡æä½æ—¶è§¦å‘ã€‚
* **é€‚ç”¨å½¢æ€**ï¼š`MILD`, `FLAT`, `BACKWARD`, `SPIKE` (é€šå¸¸), æˆ– `HV Rank < 30`ã€‚
* **æ ¸å¿ƒæ€æƒ³**ï¼šæ²¡æœ‰ç»“æ„ä¼˜åŠ¿æ—¶ï¼Œä¹°å…¥è·¨å¼æœŸæƒï¼ˆStraddleï¼‰åšå–æ³¢åŠ¨ç‡å›å½’æˆ–æ–¹å‘æ€§çªç ´ã€‚

---

## 4. å®‰å…¨é—¨é˜€ (Safety Gate V6)

Gate æ˜¯ç³»ç»Ÿçš„æœ€åä¸€é“é˜²çº¿ï¼Œå†³å®šæœ€ç»ˆçŠ¶æ€æ˜¯ `EXEC` (æ‰§è¡Œ)ã€`LIMIT` (æŒ‚å•) è¿˜æ˜¯ `WAIT` (è§‚æœ›)ã€‚

### ğŸ›‘ Hard Kill (ä¸€ç¥¨å¦å†³)
* **Blueprint Error**: å»ºä»“å¤±è´¥æˆ–æ•°æ®ç¼ºå¤± $\to$ `FORBID`
* **Gamma Risk**: `est_gamma >= 0.30` $\to$ `FORBID`
* **Vol Collapse**: `Momentum == CRUSH` $\to$ `FORBID`

### ğŸš§ Structural Gate (ç»“æ„æ”¾è¡Œ)

1.  **DIAG è±å…æƒ (The FFBS Privilege)**:
    * è‹¥å½¢æ€ä¸º **`FFBS`** æˆ– **`STEEP`**ï¼Œ**è±å…**å¯¹ Micro Edge (`em`) çš„æœ€ä½è¦æ±‚ã€‚
    * *ç†ç”±ï¼šæ­¤æ—¶å‰ç«¯è¶Šå¹³è¶Šå¥½ï¼Œä¸éœ€è¦å‰ç«¯æœ‰ Edgeã€‚*

2.  **SPIKE é™çº§ä¿æŠ¤ (Rule #4)**:
    * è‹¥å½¢æ€ä¸º **`SPIKE`** ä¸” `Short DTE <= 7` ä¸”åŠ¨èƒ½ä¸è¶³ (`QUIET`) $\to$ å¼ºåˆ¶ **`WAIT`**ã€‚
    * *ç†ç”±ï¼šå‰ç«¯æŒ¤å‹æ—¶æŒ‚ Limit å•å®¹æ˜“è¢«åŠ¨æˆäº¤å¹¶ç«‹åˆ»é­å— Gamma åå™¬ã€‚*

3.  **LG æ ‡å‡†**:
    * è‹¥ `em` å’Œ `ek` åŒä½ (`< Threshold`) $\to$ **`WAIT`**ã€‚

### ğŸš€ Momentum Gate (æ‰§è¡Œå±‚)

* **`PULSE` / `TREND`**: åŠ¨èƒ½ç¡®ç«‹ $\to$ **`EXEC`** (å»ºè®® Market æˆ– Mid+)
* **`QUIET`**: åŠ¨èƒ½æ²‰å¯‚ $\to$ **`LIMIT`** (å»ºè®® Mid-)

---

## 5. æœ¯è¯­å¯¹ç…§è¡¨

* **S_IV**: Short Leg IV (Base Denominator)
* **EdgM**: Micro Edge (Stabilized Front-end Slope)
* **EdgK**: Month Edge (Stabilized Back-end Slope)
* **Scr**: Score (ç»¼åˆè¯„åˆ†)

================================================================================
FILE_PATH: config\config.yaml
================================================================================
# ==========================================
# ğŸ›¡ï¸ Trade Guardian Config (V4.4 Final Closed Loop)
# ==========================================

paths:
  tickers_csv: "data/tickers.csv"
  cache_dir: "cache"

scan:
  throttle_sec: 0.5
  contract_type: "ALL"

rules:
  # ç»“æ„ä¼˜åŠ¿é—¨æ§›
  min_edge_short_base: 1.05

  # [Long Gamma] ç¡¬æ€§é£æ§å‚æ•°
  lg_min_dte_etf: 7
  lg_min_dte_stock: 10
  lg_max_spread_pct: 0.08

  # [Risk Caps]
  gamma_soft_cap: 0.24
  gamma_hard_cap: 0.32

  # [Pin Risk]
  pin_risk_cap: 0.25
  pin_risk_coeff: 0.3

  # [Time Stop]
  lg_time_stop_min: 90
  lg_no_move_frac: 0.25

  # [Momentum]
  lg_allowed_dna_exec: ["PULSE"]
  lg_allowed_dna_limit: ["TREND"]
  lg_dna_quiet_action: "WAIT"

  # ==========================================
  # [Anchor] ç”¨äºç»“æ„è¯„ä¼°ï¼ˆEdge/Shapeï¼‰çš„â€œé”šç‚¹â€
  # ==========================================
  anchor_min_dte: 20
  anchor_max_dte: 45
  anchor_fallback_max_dte: 90
  anchor_target_dte: 35
  anchor_lambda_dist: 0.35
  anchor_prefer_monthly: true   # ä¸»çª—å£å†…ä¼˜å…ˆç¬¬ä¸‰å‘¨äº”ï¼ˆé¿å… 59DTE åœ¨ fallback å¸èµ°ä¸€åˆ‡ï¼‰

  # ------------------------------------------
  # [Compatibility] å…¼å®¹æ—§å­—æ®µï¼šmonth_* = anchor_*
  # ï¼ˆå¦‚æœä½ å·²æŠŠä»£ç æ”¹æˆè¯» anchor_*ï¼Œè¿™æ®µå¯ä»¥åˆ ï¼‰
  # ------------------------------------------
  month_min_dte: 20
  month_max_dte: 45
  month_fallback_max_dte: 90
  month_target_dte: 35
  month_lambda_dist: 0.35
  month_prefer_monthly: true

  # ==========================================
  # [Diagonal Long] ç”¨äºâ€œå¯¹è§’çº¿é•¿è…¿â€çš„çœŸå® long expï¼ˆäº¤æ˜“ç”¨ï¼‰
  # ==========================================
  diag_long_min_dte: 45
  diag_long_max_dte: 75
  diag_long_fallback_max_dte: 120
  diag_long_target_dte: 60
  diag_long_lambda_dist: 0.25
  diag_long_prefer_monthly: true
  diag_long_min_gap_vs_short: 20   # long_dte è‡³å°‘æ¯” short_dte å¤š 20 å¤©



policy:
  base_rank: 1
  min_dte: 1
  probe_count: 3

strategies:
  diagonal:
    use_rank_0_for_short: true
    short_min_dte: 1
    short_max_dte: 14
  
  hv_calendar:
    hv_rules:
      hv_low_rank: 20.0
      hv_mid_rank: 50.0
      hv_high_rank: 70.0
      hv_low_bonus: 10
      hv_mid_bonus: 4
      hv_high_penalty: -4
      hv_extreme_penalty: -10

================================================================================
FILE_PATH: src\trade_guardian.py
================================================================================
import time
import sys
import os
from datetime import datetime

# ç¡®ä¿ src ç›®å½•åœ¨è·¯å¾„ä¸­ï¼Œä»¥ä¾¿æ­£ç¡®å¯¼å…¥
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from trade_guardian.app.cli import main

def run_guardian_loop():
    """
    å®ˆæŠ¤è€…æ¨¡å¼ï¼šæ¯ 15 åˆ†é’Ÿè‡ªåŠ¨æ‰§è¡Œä¸€æ¬¡å…¨é‡æ‰«æå¹¶å­˜åº“
    """
    INTERVAL = 10 * 60  # 10 åˆ†é’Ÿ (600ç§’)
    
    print("="*80)
    print(f"ğŸ›¡ï¸  TRADE GUARDIAN - DAEMON MODE ACTIVE")
    print(f"â° Polling Interval: {INTERVAL/60} minutes")
    print(f"ğŸ“‚ Project Root: {project_root}")
    print("="*80)
    
    try:
        while True:
            start_ts = time.time()
            now_str = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            # æ¨¡æ‹Ÿå‘½ä»¤è¡Œå‚æ•°ç»™ cli.main()
            # è¿™é‡Œä½ å¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´é»˜è®¤å‚æ•°
            sys.argv = [
                "trade_guardian.py", 
                "scanlist", 
                "--strategy", "auto", 
                "--days", "600", 
                "--detail",
                "--top", "10" # è‡ªåŠ¨æ¨¡å¼ä¸‹åªæ˜¾ç¤ºæœ€æœ‰ä»·å€¼çš„10ä¸ªè®¡åˆ’
            ]
            
            print(f"\nğŸ”„ [LOOP START] {now_str}")
            
            try:
                # æ‰§è¡ŒåŸæœ‰çš„ cli ä¸»å‡½æ•°
                main()
            except Exception as e:
                print(f"âŒ Session Execution Error: {e}")

            elapsed = time.time() - start_ts
            wait_time = max(0, INTERVAL - elapsed)
            
            next_run = datetime.fromtimestamp(time.time() + wait_time).strftime('%H:%M:%S')
            
            print(f"\nâœ… SESSION COMPLETE. Duration: {elapsed:.2f}s")
            print(f"â³ Sleeping {wait_time/60:.1f} min. Next run at: {next_run} (Ctrl+C to stop)")
            
            time.sleep(wait_time)
            
    except KeyboardInterrupt:
        print("\nğŸ›‘ Guardian daemon stopped by user. exiting...")
        sys.exit(0)

if __name__ == "__main__":
    # é€»è¾‘åˆ¤å®šï¼š
    # 1. å¦‚æœä½ è¾“å…¥ python src/trade_guardian.py scanlist ... (å¸¦å‚æ•°) -> è¿è¡Œä¸€æ¬¡å°±ç»“æŸ
    # 2. å¦‚æœä½ ç›´æ¥è¾“å…¥ python src/trade_guardian.py (ä¸å¸¦å‚æ•°) -> è¿›å…¥15åˆ†é’Ÿè½®è¯¢æ¨¡å¼
    if len(sys.argv) > 1:
        main()
    else:
        run_guardian_loop()

================================================================================
FILE_PATH: src\trade_guardian\__init__.py
================================================================================
__all__ = ["app", "domain", "infra", "strategies"]
__version__ = "0.1.0"


================================================================================
FILE_PATH: src\trade_guardian\action\safety.py
================================================================================
from typing import Dict, Tuple

class SafetyCheckResult:
    def __init__(self, passed: bool, reason: str, mid: float = 0.0, spread: float = 0.0):
        self.passed = passed
        self.reason = reason
        self.mid = mid
        self.spread = spread

def check_liquidity(quote: Dict, strict_mode: bool = True) -> SafetyCheckResult:
    """
    æ£€æŸ¥æœŸæƒæŠ¥ä»·çš„æµåŠ¨æ€§å¥åº·åº¦
    quote ç»“æ„: {'bid': 3.30, 'ask': 3.35, 'mark': 3.325}
    """
    bid = float(quote.get('bid', 0.0))
    ask = float(quote.get('ask', 0.0))
    
    if bid <= 0 or ask <= 0:
        return SafetyCheckResult(False, "Zero Liquidity (Bid/Ask is 0)")
    
    mid = (bid + ask) / 2.0
    spread = ask - bid
    
    # 1. ç»å¯¹å€¼ä¿æŠ¤ï¼šé˜²æ­¢é”™ä»· (Crossed Market)
    if bid > ask:
        return SafetyCheckResult(False, f"Crossed Market (Bid {bid} > Ask {ask})", mid, spread)
        
    # 2. Spread æ¯”ä¾‹æ£€æŸ¥
    # å¯¹äºé«˜ä»·æœŸæƒ (> $1.0)ï¼ŒSpread ä¸åº”è¶…è¿‡ Mid çš„ 15% (Strict) æˆ– 25% (Loose)
    # å¯¹äºä½ä»·æœŸæƒ (< $1.0)ï¼Œå…è®¸æ›´å®½çš„æ¯”ä¾‹ï¼Œä½†é™åˆ¶ç»å¯¹å€¼
    spread_ratio = spread / mid
    
    threshold = 0.15 if strict_mode else 0.25
    
    # é’ˆå¯¹ä½ä»·ç¥¨çš„è±å… (e.g. Bid 0.05 Ask 0.10, ratio=66% ä½†å…¶å®æ­£å¸¸)
    if mid < 0.50:
        threshold = 0.50 
    elif mid < 1.0:
        threshold = 0.30

    if spread_ratio > threshold:
        return SafetyCheckResult(
            False, 
            f"Spread Too Wide: {spread:.2f} ({spread_ratio:.1%}) > {threshold:.0%}", 
            mid, 
            spread
        )
        
    return SafetyCheckResult(True, "OK", mid, spread)

================================================================================
FILE_PATH: src\trade_guardian\action\sights.py
================================================================================
from typing import List, Tuple, Optional
import math

def find_nearest_strike(price: float, strikes: List[float]) -> float:
    """æ‰¾åˆ°ç¦»å½“å‰ä»·æ ¼æœ€è¿‘çš„ Strike (ATM)"""
    if not strikes:
        return 0.0
    return min(strikes, key=lambda x: abs(x - price))

def get_strike_step(price: float) -> float:
    """ä¼°ç®— Strike æ­¥é•¿ (ç”¨äºåˆ¤æ–­æ¼‚ç§»æ˜¯å¦æ˜¾è‘—)"""
    if price < 50: return 0.5
    if price < 100: return 1.0
    if price < 200: return 2.5 # NVDA/BABA è¿™ç§çº§åˆ«
    if price < 500: return 5.0
    return 10.0

def recenter_target(
    current_price: float, 
    proposed_strike: float, 
    available_strikes: List[float],
    strategy_type: str = "STRADDLE"
) -> Tuple[float, bool]:
    """
    åˆ¤æ–­æ˜¯å¦éœ€è¦é‡æ–°ç„å‡†
    Returns: (NewStrike, IsChanged)
    """
    if not available_strikes:
        return proposed_strike, False

    # 1. ç¡®å®šç›®æ ‡ Strike
    # å¯¹äº Straddle/Calendar/IronFlyï¼Œæˆ‘ä»¬æ°¸è¿œè¿½æ±‚ç»å¯¹ ATM
    target_strike = find_nearest_strike(current_price, available_strikes)
    
    # 2. åˆ¤æ–­æ˜¯å¦å‘ç”Ÿæ˜¾è‘—æ¼‚ç§»
    # åªæœ‰å½“ç›®æ ‡ Strike ç¡®å®æ”¹å˜äº†ï¼Œæ‰è§¦å‘å˜æ›´
    if abs(target_strike - proposed_strike) > 0.01:
        return target_strike, True
        
    return proposed_strike, False

================================================================================
FILE_PATH: src\trade_guardian\action\sniper.py
================================================================================
from __future__ import annotations

from typing import Dict, Any, Optional, List
from colorama import Fore, Style

from trade_guardian.infra.schwab_client import SchwabClient
from trade_guardian.action import sights, safety


def _safe_float(x: Any, default: float = 0.0) -> float:
    try:
        if x is None:
            return default
        return float(x)
    except Exception:
        return default


def _pick_spot(quote_obj: Dict[str, Any]) -> float:
    # Schwab quote keys can vary
    for k in ("lastPrice", "last", "mark", "regularMarketLastPrice"):
        v = _safe_float(quote_obj.get(k), 0.0)
        if v > 0:
            return v
    return 0.0


def _hard_mid(bid: float, ask: float, mark: float, last: float) -> float:
    # mark -> (bid+ask)/2 -> last -> 0
    if mark > 0:
        return mark
    if bid > 0 and ask > 0:
        return (bid + ask) / 2.0
    if last > 0:
        return last
    return 0.0


def _norm_quote(q: Dict[str, Any]) -> Dict[str, float]:
    bid = _safe_float(q.get("bid"), 0.0)
    ask = _safe_float(q.get("ask"), 0.0)
    mark = _safe_float(q.get("mark"), 0.0)
    last = _safe_float(q.get("last"), 0.0)
    mid = _hard_mid(bid=bid, ask=ask, mark=mark, last=last)
    return {"bid": bid, "ask": ask, "mark": mark, "last": last, "mid": mid}


class Sniper:
    def __init__(self, client: SchwabClient):
        self.client = client

    def _get_tick_size(self, price: float) -> float:
        if price < 3.0:
            return 0.01
        return 0.05

    def _round_to_tick(self, price: float, tick: float) -> float:
        if tick <= 0:
            return round(price, 2)
        return round(round(price / tick) * tick, 2)

    def _fetch_chain_one_exp(self, symbol: str, exp: str) -> Dict[str, Any]:
        # ä½ å½“å‰ SchwabClient çš„ç­¾åï¼š_fetch_chain(symbol, from_d, to_d, range_val="ALL")
        return self.client._fetch_chain(symbol, exp, exp, range_val="ALL")

    def _list_strikes(self, exp_map: Dict[str, Any], exp: str) -> List[float]:
        target_exp_key = None
        for k in exp_map.keys():
            if str(k).startswith(exp):
                target_exp_key = k
                break
        if not target_exp_key:
            return []
        strikes_map = exp_map.get(target_exp_key) or {}
        out: List[float] = []
        for s in strikes_map.keys():
            try:
                out.append(float(s))
            except Exception:
                continue
        out.sort()
        return out

    def _extract_quote(self, chain: Dict[str, Any], map_key: str, exp: str, strike: float) -> Optional[Dict[str, Any]]:
        exp_map = chain.get(map_key, {}) or {}

        target_exp_key = None
        for k in exp_map.keys():
            if str(k).startswith(exp):
                target_exp_key = k
                break
        if not target_exp_key:
            return None

        strikes_map = exp_map.get(target_exp_key) or {}
        target = float(strike)

        for s_str, q_list in strikes_map.items():
            try:
                s_val = float(s_str)
            except Exception:
                continue
            if abs(s_val - target) < 0.01:
                if q_list and isinstance(q_list, list):
                    return q_list[0] or None
                return None

        return None

    def lock_target(
        self,
        symbol: str,
        strategy: str,
        short_exp: str,
        short_strike: float,
        long_exp: Optional[str] = None,
        long_strike: Optional[float] = None,
        urgency: str = "PASSIVE",
    ) -> Dict[str, Any]:
        """
        æ”¯æŒ Straddle å’Œ Diagonal
        âœ… å¯¹é½ä½ çš„ SchwabClientï¼šåªç”¨ _fetch_chain()
        âœ… æ›´ä¸¥æ ¼ï¼šä»»ä¸€è…¿ bid/ask <=0 ç›´æ¥ FAILï¼ˆå¦åˆ™ UI ä¼šä¸€ç›´ ---ï¼‰
        """
        strat = (strategy or "").strip().upper()
        urg = (urgency or "PASSIVE").strip().upper()

        print(f"\nğŸ”­ {Fore.CYAN}SNIPER: Locking Target for {symbol} ({strat})...{Style.RESET_ALL}")

        quote_underlying = self.client.get_quote(symbol)
        current_price = _pick_spot(quote_underlying)
        if current_price <= 0:
            return {"status": "FAIL", "msg": "No Spot Price"}

        print(f"   â€¢ Spot Price: {Fore.YELLOW}{current_price:.2f}{Style.RESET_ALL}")

        bid: float = 0.0
        ask: float = 0.0
        comp_mid: float = 0.0
        legs_desc: str = ""
        final_short_strike: float = float(short_strike)

        # A) STRADDLE / LG
        if strat in {"STRADDLE", "LG", "LONG_GAMMA", "AUTO-LG", "AUTO_LG"}:
            chain_data = self._fetch_chain_one_exp(symbol=symbol, exp=short_exp)
            call_map = chain_data.get("callExpDateMap", {}) or {}

            valid_strikes = self._list_strikes(call_map, short_exp)
            if not valid_strikes:
                return {"status": "FAIL", "msg": "No Strikes (Straddle)"}

            final_short_strike, changed = sights.recenter_target(
                current_price, float(short_strike), valid_strikes
            )
            if changed:
                print(f"   â€¢ Recenter: {short_strike} -> {final_short_strike}")

            q_call_raw = self._extract_quote(chain_data, "callExpDateMap", short_exp, final_short_strike)
            q_put_raw = self._extract_quote(chain_data, "putExpDateMap", short_exp, final_short_strike)
            if not q_call_raw or not q_put_raw:
                return {"status": "FAIL", "msg": "Missing Quotes (Straddle)"}

            q_call = _norm_quote(q_call_raw)
            q_put = _norm_quote(q_put_raw)

            if q_call["bid"] <= 0 or q_call["ask"] <= 0 or q_put["bid"] <= 0 or q_put["ask"] <= 0:
                return {"status": "FAIL", "msg": "Zero Liquidity (Straddle legs bid/ask)"}

            bid = q_call["bid"] + q_put["bid"]
            ask = q_call["ask"] + q_put["ask"]
            comp_mid = q_call["mid"] + q_put["mid"]
            legs_desc = f"+{short_exp} {final_short_strike}C +{short_exp} {final_short_strike}P"

        # B) DIAGONAL / PMCC
        elif strat in {"DIAGONAL", "PMCC", "AUTO-DIAG", "AUTO_DIAG"}:
            if not long_exp or long_strike is None:
                return {"status": "FAIL", "msg": "Diagonal requires long_exp and long_strike"}

            chain_short = self._fetch_chain_one_exp(symbol=symbol, exp=short_exp)
            chain_long = self._fetch_chain_one_exp(symbol=symbol, exp=long_exp)

            q_short_raw = self._extract_quote(chain_short, "callExpDateMap", short_exp, float(short_strike))
            q_long_raw = self._extract_quote(chain_long, "callExpDateMap", long_exp, float(long_strike))

            if not q_short_raw or not q_long_raw:
                missing = []
                if not q_short_raw:
                    missing.append(f"Short({short_exp} {short_strike})")
                if not q_long_raw:
                    missing.append(f"Long({long_exp} {long_strike})")
                return {"status": "FAIL", "msg": f"Missing Diagonal Quotes: {', '.join(missing)}"}

            q_short = _norm_quote(q_short_raw)
            q_long = _norm_quote(q_long_raw)

            if q_short["bid"] <= 0 or q_short["ask"] <= 0 or q_long["bid"] <= 0 or q_long["ask"] <= 0:
                return {"status": "FAIL", "msg": "Zero Liquidity (Diagonal legs bid/ask)"}

            bid = q_long["bid"] - q_short["ask"]
            ask = q_long["ask"] - q_short["bid"]
            comp_mid = q_long["mid"] - q_short["mid"]

            legs_desc = f"+{long_exp} {float(long_strike)}C / -{short_exp} {float(short_strike)}C"

        else:
            return {"status": "FAIL", "msg": f"Unknown Strategy: {strategy}"}

        if comp_mid <= 0 and bid > 0 and ask > 0:
            comp_mid = (bid + ask) / 2.0

        comp_spread = ask - bid

        safe_res = safety.check_liquidity({"bid": bid, "ask": ask})
        if not safe_res.passed:
            print(f"   â€¢ {Fore.RED}SAFETY BLOCK: {safe_res.reason}{Style.RESET_ALL}")
            return {"status": "FAIL", "msg": safe_res.reason}

        if comp_mid <= 0:
            return {"status": "FAIL", "msg": "Zero Mid Price (Composite)"}

        print(f"   â€¢ Liquidity: OK (Spread: {comp_spread:.2f})")

        tick = self._get_tick_size(comp_mid)

        if urg == "AGGRESSIVE":
            target_price = ask
            desc = "AGGRESSIVE (Hit Ask)"
            color = Fore.RED
        elif urg == "NEUTRAL":
            target_price = comp_mid
            desc = "NEUTRAL (Fair Value)"
            color = Fore.YELLOW
        else:
            improvement = max(tick, 0.03)
            target_price = comp_mid - improvement
            desc = "PASSIVE (Fishing)"
            color = Fore.CYAN

        limit_price = self._round_to_tick(target_price, tick)

        print(f"   â€¢ {Fore.GREEN}ğŸ¯ FIRE SOLUTION COMPUTED [{desc}]{Style.RESET_ALL}")
        print(f"     Legs: {legs_desc}")
        print(f"     Mkt: {bid:.2f}/{ask:.2f} (Mid {comp_mid:.2f}) -> Limit: {color}{limit_price:.2f}{Style.RESET_ALL}")

        return {
            "status": "READY",
            "symbol": symbol,
            "strategy": strat,
            "limit_price": float(limit_price),
            "est_cost": float(limit_price) * 100.0,
            "bid": float(bid),
            "ask": float(ask),
            "mid": float(comp_mid),
            "spread": float(comp_spread),
            "legs_desc": legs_desc,
            "short_exp": short_exp,
            "short_strike": float(final_short_strike),
            "long_exp": long_exp,
            "long_strike": float(long_strike) if long_strike is not None else None,
        }


================================================================================
FILE_PATH: src\trade_guardian\action\__init__.py
================================================================================

from .sniper import Sniper

================================================================================
FILE_PATH: src\trade_guardian\app\cli.py
================================================================================
import argparse
import os
import time
import json
import sqlite3

from trade_guardian.infra.config import (
    DEFAULT_CONFIG,
    load_config,
    write_config_template,
    merge_config_paths,
    policy_from_cfg_and_cli,
)
from trade_guardian.infra.schwab_client import SchwabClient
from trade_guardian.domain.registry import StrategyRegistry
from trade_guardian.app.orchestrator import TradeGuardian
from trade_guardian.action.sniper import Sniper

def main():
    parser = argparse.ArgumentParser("Trade Guardian")
    sub = parser.add_subparsers(dest="cmd", required=True)

    # ---------- initconfig ----------
    p_init = sub.add_parser("initconfig", help="Generate config/config.json template")
    #p_init.add_argument("--path", type=str, default=None, help="Output path (default: ./config/config.json)")
    p_init.add_argument("--path", type=str, default=None, help="Output path (default: ./config/config.yaml)")
    p_init.add_argument("--force", action="store_true", help="Overwrite if exists")

    # ---------- scanlist ----------
    p_scan = sub.add_parser("scanlist", help="Scan tickers.csv and output candidates")
    #p_scan.add_argument("--config", type=str, default=None, help="Config path (default: ./config/config.json)")
    p_scan.add_argument("--config", type=str, default=None, help="Config path (default: ./config/config.yaml)")
    p_scan.add_argument("--autogen-config", action="store_true", help="Auto-generate config if missing")
    p_scan.add_argument("--no-autogen-config", action="store_true", help="Disable auto-generate config")

    p_scan.add_argument("--strategy", type=str, default="auto", help="Strategy name (default: auto)")
    p_scan.add_argument("--days", type=int, default=600)
    p_scan.add_argument("--csv", type=str, default=None, help="Tickers csv path")
    p_scan.add_argument("--min-score", type=int, default=60)
    p_scan.add_argument("--max-risk", type=int, default=70)
    p_scan.add_argument("--limit", type=int, default=0)
    p_scan.add_argument("--detail", action="store_true", help="Print blueprints and detailed logic")
    p_scan.add_argument("--top", type=int, default=None, help="Only show top N sorted blueprints")

    # Policy overrides
    p_scan.add_argument("--short-rank", type=int, default=None)
    p_scan.add_argument("--min-short-dte", type=int, default=None)
    p_scan.add_argument("--max-probe-rank", type=int, default=None)

    # ---------- [NEW] fire (æ™ºèƒ½å¼€ç«) ----------
    p_fire = sub.add_parser("fire", help="Execute tactical lock & order generation")
    p_fire.add_argument("symbol", type=str, help="Target Symbol (e.g. NVDA)")
    p_fire.add_argument("--strategy", type=str, default=None, help="Strategy type (Optional, auto-load from DB)")
    
    # çŸ­è…¿/ä¸»è…¿å‚æ•° (å¯é€‰ï¼Œä¸å¡«åˆ™æŸ¥åº“)
    p_fire.add_argument("--date", type=str, default=None, help="Short Expiry (YYYY-MM-DD)")
    p_fire.add_argument("--strike", type=float, default=None, help="Short Strike")
    
    # é•¿è…¿å‚æ•° (ä»… Diagonal éœ€è¦ï¼Œå¯é€‰ï¼Œä¸å¡«åˆ™æŸ¥åº“)
    p_fire.add_argument("--long-date", type=str, default=None, help="Long Expiry (YYYY-MM-DD)")
    p_fire.add_argument("--long-strike", type=float, default=None, help="Long Strike")

    # å®šä»·æ€¥è¿«åº¦
    p_fire.add_argument("--mode", type=str, default="PASSIVE", choices=["PASSIVE", "NEUTRAL", "AGGRESSIVE"], help="Pricing urgency")
    
    args = parser.parse_args()

    # å®šä½é¡¹ç›®æ ¹ç›®å½• (cli.py -> app -> trade_guardian -> src -> project_root)
    root = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "..", ".."))

    # ==========================================
    # 1. initconfig
    # ==========================================
    if args.cmd == "initconfig":
        #out = args.path or os.path.join(root, "config", "config.json")
        out = args.path or os.path.join(root, "config", "config.yaml")
        os.makedirs(os.path.dirname(out), exist_ok=True)
        write_config_template(out, DEFAULT_CONFIG, overwrite=args.force)
        print(f"âœ… Wrote config template: {out}")
        return

    # ==========================================
    # 2. scanlist
    # ==========================================
    if args.cmd == "scanlist":
        # è®°å½•å¼€å§‹æ—¶é—´ï¼Œç”¨äºæ•°æ®åº“å­˜ç›˜
        start_ts = time.time()

        #cfg_path = args.config or os.path.join(root, "config", "config.json")
        cfg_path = args.config or os.path.join(root, "config", "config.yaml")

        # æ£€æŸ¥æ˜¯å¦éœ€è¦è‡ªåŠ¨ç”Ÿæˆé…ç½®
        autogen_default = bool(DEFAULT_CONFIG.get("runtime", {}).get("autogen_config_if_missing", True))
        autogen = autogen_default
        if args.autogen_config: autogen = True
        if args.no_autogen_config: autogen = False

        if autogen and not os.path.exists(cfg_path):
            os.makedirs(os.path.dirname(cfg_path), exist_ok=True)
            write_config_template(cfg_path, DEFAULT_CONFIG, overwrite=False)

        # åŠ è½½ä¸åˆå¹¶è·¯å¾„
        cfg = load_config(cfg_path, DEFAULT_CONFIG)
        cfg = merge_config_paths(cfg, root, args.csv)

        # æ„å»ºç­–ç•¥å’Œå®¢æˆ·ç«¯
        policy = policy_from_cfg_and_cli(cfg, args)
        client = SchwabClient(cfg)
        registry = StrategyRegistry(cfg, policy)
        strategy = registry.get(args.strategy)

        # åˆå§‹åŒ–ä¸»æ§ç¨‹åº
        tg = TradeGuardian(client=client, cfg=cfg, policy=policy, strategy=strategy)
        
        # æ‰§è¡Œæ‰«æ
        tg.scanlist(
            strategy_name=args.strategy,
            days=args.days,
            min_score=args.min_score,
            max_risk=args.max_risk,
            limit=args.limit,
            detail=args.detail,
            top=args.top,
            elapsed=0.0  # åˆå§‹è®¾ä¸º0ï¼ŒOrchestrator å†…éƒ¨ä¼šè®¡ç®—çœŸå®å€¼æˆ–ç”±è¿™é‡Œä¼ é€’
        )
        return

    # ==========================================
    # 3. fire (æ™ºèƒ½æ‰§è¡Œ)
    # ==========================================
    if args.cmd == "fire":
        symbol = args.symbol.upper()
        print(f"ğŸ”¥ Guardian Sniper System Activated: {symbol}")
        
        # A. åˆå§‹åŒ–åŸºç¡€è®¾æ–½
        cfg_path = os.path.join(root, "config", "config.json")
        cfg = load_config(cfg_path, DEFAULT_CONFIG)
        client = SchwabClient(cfg)
        sniper = Sniper(client)
        
        # B. å‚æ•°è§£æä¸æ™ºèƒ½æŸ¥åº“
        target_strategy = args.strategy
        short_exp = args.date
        short_strike = args.strike
        long_exp = args.long_date
        long_strike = args.long_strike

        # å¦‚æœæ²¡æœ‰æä¾›å…³é”®å‚æ•°ï¼Œå°è¯•ä»æ•°æ®åº“è·å–â€œæœ€æ–°ä½œæˆ˜è®¡åˆ’â€
        if not short_exp:
            print(f"   ... Fetching latest strategic blueprint for {symbol} from DB ...")
            try:
                db_path = os.path.join(root, "db", "trade_guardian.db")
                if os.path.exists(db_path):
                    conn = sqlite3.connect(db_path)
                    cursor = conn.cursor()
                    
                    # æŸ¥è¯¢è¯¥æ ‡çš„æœ€è¿‘ä¸€æ¬¡ç”Ÿæˆçš„ã€é FORBID çš„äº¤æ˜“è®¡åˆ’
                    query = """
                        SELECT p.strategy_type, p.blueprint_json, b.timestamp, p.tag
                        FROM trade_plans p
                        JOIN market_snapshots s ON p.snapshot_id = s.snapshot_id
                        JOIN scan_batches b ON s.batch_id = b.batch_id
                        WHERE s.symbol = ? AND p.gate_status != 'FORBID'
                        ORDER BY b.batch_id DESC
                        LIMIT 1
                    """
                    row = cursor.execute(query, (symbol,)).fetchone()
                    conn.close()
                    
                    if row:
                        db_strat, bp_json, ts, db_tag = row
                        print(f"   âœ… Found Plan from {ts}: {db_tag} ({db_strat})")
                        
                        if bp_json:
                            bp_data = json.loads(bp_json)
                            legs = bp_data.get("legs", [])
                            
                            # ç¡®å®šç­–ç•¥ç±»å‹
                            if not target_strategy:
                                if "DIAGONAL" in str(db_strat).upper() or "DIAGONAL" in str(db_tag).upper():
                                    target_strategy = "DIAGONAL"
                                else:
                                    target_strategy = "STRADDLE"

                            # è§£æ Legs (æ™ºèƒ½è¯†åˆ«ä¹°å–è…¿)
                            if target_strategy == "DIAGONAL":
                                # å‡è®¾å¯¹è§’çº¿é€šå¸¸æ˜¯ä¹°è¿œå–è¿‘
                                for leg in legs:
                                    if leg['action'] == 'SELL':
                                        short_exp = leg['exp']
                                        short_strike = float(leg['strike'])
                                    elif leg['action'] == 'BUY':
                                        long_exp = leg['exp']
                                        long_strike = float(leg['strike'])
                            else:
                                # Straddle/LG: ä¸¤æ¡è…¿éƒ½æ˜¯ Buyï¼Œæˆ–è€…åŒ Exp
                                if legs:
                                    short_exp = legs[0]['exp']
                                    short_strike = float(legs[0]['strike'])
                            
                            print(f"   ğŸ“– Loaded Params: {target_strategy} | Short: {short_exp} {short_strike} | Long: {long_exp} {long_strike}")
                        else:
                            print("   âš ï¸  Plan found but blueprint data is empty.")
                    else:
                        print(f"   âš ï¸  No active plan found in DB for {symbol}. Will attempt fallback.")
                else:
                    print("   âš ï¸  Database not found.")
            
            except Exception as e:
                print(f"   âŒ DB Lookup Error: {e}")

        # C. å…œåº•é€»è¾‘ï¼šå¦‚æœæŸ¥åº“å¤±è´¥ï¼Œè‡³å°‘èƒ½è·‘ä¸ª Straddle
        if not short_exp:
            print("   ... Auto-scanning for nearest expiry (Fallback) ...")
            try:
                _, term, _ = client.scan_atm_term(symbol, days=14)
                if term:
                    valid = [p for p in term if p.dte >= 0] 
                    if valid:
                        short_exp = valid[0].exp
                        target_strategy = target_strategy or "STRADDLE"
                        print(f"   -> Auto-selected Short Expiry: {short_exp}")
            except Exception as e:
                print(f"   âŒ Fallback Scan Failed: {e}")

        if not short_exp:
            print("âŒ Error: Could not determine expiry. Run 'scanlist' first or specify --date.")
            return

        # D. é”å®šç›®æ ‡ (Call Sniper)
        # å¦‚æœæ²¡æœ‰æŒ‡å®š Strikeï¼Œä¼  0.0 ç»™ Sniper è®©å®ƒè‡ªå·± Recenter ATM
        final_short_strike = short_strike if short_strike else 0.0
        final_strategy = target_strategy if target_strategy else "STRADDLE"

        result = sniper.lock_target(
            symbol=symbol,
            strategy=final_strategy,
            short_exp=short_exp,
            short_strike=final_short_strike,
            long_exp=long_exp,
            long_strike=long_strike,
            urgency=args.mode.upper() # [NEW] ä¼ å…¥å®šä»·æ€¥è¿«åº¦
        )
        
        # E. è¾“å‡ºç»“æœ
        if result['status'] == 'READY':
            print(f"\nâœ… COMMAND READY: {result['symbol']}")
            if 'strike' in result:
                print(f"   STRIKE: {result['strike']}")
            print(f"   LIMIT : ${result['limit_price']}")
            print(f"   COST  : ${result['est_cost']:.2f}")
        else:
            print(f"\nâ›” ABORT: {result.get('msg', 'Unknown Error')}")
            
        return

if __name__ == "__main__":
    main()

================================================================================
FILE_PATH: src\trade_guardian\app\orchestrator.py
================================================================================
from __future__ import annotations

import os
import sys
import time
from datetime import datetime, date
from typing import List, Tuple, Optional, Any

import pandas as pd
from colorama import Fore, Style

from trade_guardian.domain.models import Context, ScanRow, Blueprint, OrderLeg, TermPoint
from trade_guardian.app.persistence import PersistenceManager
from trade_guardian.strategies.blueprint import build_straddle_blueprint
from trade_guardian.infra.rate_limit import RateLimiter

# [FIX] ç§»é™¤ç¡¬ç¼–ç ï¼Œä»…ä¿ç•™é»˜è®¤å¸¸é‡ä½œä¸º Config ä¸å­˜åœ¨æ—¶çš„å…œåº•
DEFAULT_GAMMA_SOFT = 0.24
DEFAULT_GAMMA_HARD = 0.32

LEV_ETFS = ["TQQQ", "SQQQ", "SOXL", "SOXS", "TSLL", "TSLS", "NVDL", "LABU", "UVXY"]


class TradeGuardian:
    def __init__(self, client, cfg: dict, policy, strategy=None):
        self.client = client
        self.cfg = cfg
        self.policy = policy
        self.strategy = strategy

        self.tickers_path = cfg.get("paths", {}).get("tickers_csv", "data/tickers.csv")
        throttle = float(cfg.get("scan", {}).get("throttle_sec", 0.5))
        self.limiter = RateLimiter(throttle)

        self.db = PersistenceManager()
        self.last_batch_df: Optional[pd.DataFrame] = None

        # [FIX] è¯»å–é…ç½®ï¼ˆç”¨è§„åˆ™å±‚é˜ˆå€¼ï¼‰
        self.micro_min = float(cfg.get("rules", {}).get("diag_micro_min", 0.08))
        self.month_min = float(cfg.get("rules", {}).get("diag_month_min", 0.15))
        self.gamma_soft = float(cfg.get("rules", {}).get("gamma_soft_cap", DEFAULT_GAMMA_SOFT))
        self.gamma_hard = float(cfg.get("rules", {}).get("gamma_hard_cap", DEFAULT_GAMMA_HARD))

        # LG Spread é£æ§ï¼ˆå¦‚æœ config é‡Œæœ‰ï¼‰
        self.lg_max_spread_pct = cfg.get("rules", {}).get("lg_max_spread_pct", None)

    def _get_universe(self) -> List[str]:
        if not os.path.exists(self.tickers_path):
            fallback = os.path.join("data", "tickers.csv")
            if os.path.exists(fallback):
                self.tickers_path = fallback
            else:
                print(f"\nâŒ [CRITICAL ERROR] Tickers file NOT FOUND at {self.tickers_path}")
                sys.exit(1)
        df = pd.read_csv(self.tickers_path, header=None)
        return df[0].dropna().apply(lambda x: str(x).strip().upper()).tolist()

    # -------------------------
    # Core Scan Loop
    # -------------------------
    def scanlist(
        self,
        strategy_name: str = "auto",
        days: int = 600,
        min_score: int = 60,
        max_risk: int = 70,
        detail: bool = False,
        limit: int = None,
        **kwargs,
    ):
        start_ts = time.time()

        try:
            vix_q = self.client.get_quote("$VIX")
            current_vix = float(vix_q.get("lastPrice") or 0.0)
        except Exception:
            current_vix = 0.0

        tickers = self._get_universe()
        if limit:
            tickers = tickers[:limit]

        db_results_pack = []
        strict_results = []
        current_rows_for_next_batch = []

        FMT = (
            "{sym:<5} {px:<7} {sexp:<11} {sdte:<3} {siv:>6} | "
            "{mexp:<11} {mdte:<3} {miv:>6} {em:>5} | "
            "{kexp:<11} {kdte:<3} {kiv:>6} {ek:>5} | "
            "{sc:>4} {shp:<8} {gate:<6}   {tag:<8}"
        )
        HEADER = FMT.format(
            sym="Sym",
            px="Px",
            sexp="ShortExp",
            sdte="D",
            siv="S_IV",
            mexp="MicroExp",
            mdte="D",
            miv="M_IV",
            em="EdgM",
            kexp="MonthExp",
            kdte="D",
            kiv="K_IV",
            ek="EdgK",
            sc="Scr",
            shp="Shape",
            gate="Gate",
            tag="Tag",
        )
        WIDTH = len(HEADER)

        print("\n" + "=" * WIDTH)
        print(f"ğŸ§  TRADE GUARDIAN :: V4.5 FINAL | VIX: {current_vix:.2f} | Strategy: {strategy_name}")
        print("-" * WIDTH)
        print(HEADER)
        print("-" * WIDTH)

        for ticker in tickers:
            self.limiter.sleep()

            try:
                ctx = self.client.build_context(ticker, days=days)
                if not ctx:
                    print(f"{Fore.RED}âš ï¸  SKIP {ticker:<5} | Reason: No Context{Style.RESET_ALL}")
                    continue

                current_strategy = self.strategy if self.strategy else self._load_strategy(strategy_name)
                row = current_strategy.evaluate(ctx)
                if not row:
                    print(f"{Fore.YELLOW}âš ï¸  SKIP {ticker:<5} | Reason: Strategy Eval None{Style.RESET_ALL}")
                    continue

                # -------------------------
                # Momentum (Delta_15m-ish) withoutæ±¡æŸ“
                # -------------------------
                iv_diff = 0.0
                if self.last_batch_df is not None and not self.last_batch_df.empty:
                    if "short_exp" in self.last_batch_df.columns:
                        prev = self.last_batch_df[
                            (self.last_batch_df["symbol"] == row.symbol)
                            & (self.last_batch_df["short_exp"] == row.short_exp)
                        ]
                        if not prev.empty and "iv" in prev.columns:
                            try:
                                iv_diff = float(row.short_iv) - float(prev.iloc[0]["iv"])
                            except Exception:
                                iv_diff = 0.0

                mom_type = "QUIET"
                if iv_diff > 2.0:
                    mom_type = "PULSE"
                elif iv_diff > 0.5:
                    mom_type = "TREND"
                elif iv_diff < -1.0:
                    mom_type = "CRUSH"

                if row.meta is None:
                    row.meta = {}
                row.meta["delta_15m"] = iv_diff
                row.meta["momentum"] = mom_type

                # -------------------------
                # Blueprint resolve (then æ–¹æ¡ˆAå¯¹é½)
                # -------------------------
                bp = getattr(row, "blueprint", None)
                if not bp:
                    bp = self.plan(ctx, row)
                    row.blueprint = bp

                # âœ… æ–¹æ¡ˆAï¼šDIAGONAL æ—¶ï¼Œè¡¨æ ¼çš„ MonthExp/EdgK å¼ºåˆ¶ç­‰äº blueprint long leg
                # ï¼ˆå¿…é¡»æ”¾åœ¨ shape/gate ä¹‹å‰ï¼‰
                if bp:
                    self._sync_diag_meta_to_blueprint(ctx, row, bp)

                # -------------------------
                # Shape calc (use synchronized meta)
                # -------------------------
                tsf = ctx.tsf or {}
                regime = str(tsf.get("regime", "FLAT"))
                is_squeeze = bool(tsf.get("is_squeeze", False))

                em = float(row.meta.get("edge_micro", 0.0) or 0.0)
                ek = float(row.meta.get("edge_month", 0.0) or 0.0)

                shape = "FLAT"
                if regime == "BACKWARDATION":
                    shape = "BACKWARD"
                elif ek >= 0.20 and em < 0.08:
                    shape = "FFBS"
                elif is_squeeze or em >= 0.12:
                    shape = "SPIKE"
                elif ek >= 0.20:
                    shape = "STEEP"
                elif 0.15 <= ek < 0.20:
                    shape = "MILD"
                else:
                    shape = "FLAT"
                row.meta["shape"] = shape

                # -------------------------
                # Gate
                # -------------------------
                gate, reason = self._get_gate_status(row, bp, mom_type)

                # bp.error åªè®¤ç»“æ„æ€§é”™è¯¯ï¼›Gate Reason å†™å…¥ Note å’Œ Meta
                if gate not in ("EXEC", "LIMIT"):
                    row.meta["gate_reason"] = reason
                    if bp and (not getattr(bp, "note", "")):
                        bp.note = reason

                db_results_pack.append((row, ctx, bp, gate))

                # ä¿å­˜ short_exp ä¾›ä¸‹è½®ä½¿ç”¨
                current_rows_for_next_batch.append(
                    {"symbol": row.symbol, "iv": row.short_iv, "short_exp": row.short_exp}
                )

                if gate != "FORBID":
                    strict_results.append((row, ctx, bp, gate, mom_type, reason))

                # -------------------------
                # Print row
                # -------------------------
                if gate == "EXEC":
                    g_color = Fore.GREEN
                elif gate == "LIMIT":
                    g_color = Fore.CYAN
                elif gate == "FORBID":
                    g_color = Fore.RED
                else:
                    g_color = Fore.YELLOW

                gate_display = f"{g_color}{gate:<6}{Style.RESET_ALL}"
                tag_str = str(row.tag) if row.tag else ""

                print(
                    FMT.format(
                        sym=row.symbol,
                        px=f"{row.price:.1f}",
                        sexp=row.short_exp,
                        sdte=row.short_dte,
                        siv=f"{int(row.short_iv)}%",
                        mexp=str(row.meta.get("micro_exp", "N/A")),
                        mdte=str(row.meta.get("micro_dte", 0)),
                        miv=f"{int(row.meta.get('micro_iv', 0))}%",
                        em=f"{em:.2f}",
                        kexp=str(row.meta.get("month_exp", "N/A")),
                        kdte=str(row.meta.get("month_dte", 0)),
                        kiv=f"{int(row.meta.get('month_iv', 0))}%",
                        ek=f"{ek:.2f}",
                        sc=row.cal_score,
                        shp=shape,
                        gate=gate_display,
                        tag=tag_str,
                    )
                )

            except Exception as e:
                print(f"âŒ CRASH on {ticker}: {e}")
                import traceback

                traceback.print_exc()
                continue

        if current_rows_for_next_batch:
            self.last_batch_df = pd.DataFrame(current_rows_for_next_batch)

        elapsed = time.time() - start_ts
        valid_rows = [item[0] for item in db_results_pack]
        avg_abs_edge = 0.0
        cheap_vol_pct = 0.0

        if valid_rows:
            total_abs_edge = sum(abs(float(r.edge)) for r in valid_rows)
            avg_abs_edge = total_abs_edge / len(valid_rows)
            cheap_count = sum(1 for r in valid_rows if float(r.edge) > 0)
            cheap_vol_pct = cheap_count / len(valid_rows)

        self.db.save_scan_session(
            strategy_name, current_vix, len(tickers), avg_abs_edge, cheap_vol_pct, elapsed, db_results_pack
        )

        if detail and strict_results:
            print(f"\nğŸš€ Actionable Blueprints (Tactical Mode)")
            print("-" * WIDTH)
            for row, ctx, bp, gate, dna, reason in strict_results:
                self._print_enhanced_blueprint(bp, row, dna, gate, reason)
        print("-" * WIDTH)

    # -------------------------
    # Helpers (DTE / Term IV)
    # -------------------------
    def _dte_from_exp(self, exp: str) -> int:
        try:
            d = datetime.strptime(str(exp), "%Y-%m-%d").date()
            return max(0, (d - date.today()).days)
        except Exception:
            return 0

    def _term_iv_by_exp(self, ctx: Context, exp: str) -> float:
        """
        ctx.term: List[TermPoint]
        """
        try:
            for p in (getattr(ctx, "term", None) or []):
                if str(p.exp) == str(exp):
                    iv = float(p.iv or 0.0)
                    if 0 < iv < 1.5:
                        iv *= 100.0
                    return iv
        except Exception:
            pass
        return 0.0

    def _sync_diag_meta_to_blueprint(self, ctx: Context, row: ScanRow, bp: Blueprint) -> None:
        """
        æ–¹æ¡ˆAï¼šè®© row.meta çš„ month_* æ°¸è¿œç­‰äº blueprint å®é™… long leg
        """
        try:
            if not bp or str(getattr(bp, "strategy", "")).upper() != "DIAGONAL":
                return
            legs = getattr(bp, "legs", None) or []
            if not legs:
                return

            # long legï¼šBUY
            long_leg = next((leg for leg in legs if str(getattr(leg, "action", "")).upper() == "BUY"), None)
            if not long_leg:
                return

            long_exp = str(long_leg.exp)
            long_dte = self._dte_from_exp(long_exp)
            long_iv = self._term_iv_by_exp(ctx, long_exp)

            if row.meta is None:
                row.meta = {}

            # å¼ºåˆ¶å¯¹é½ï¼šMonthExp/MonthDTE/K_IV
            row.meta["month_exp"] = long_exp
            row.meta["month_dte"] = long_dte
            if long_iv > 0:
                row.meta["month_iv"] = long_iv

            # é‡æ–°è®¡ç®— edge_monthï¼ˆè®© EdgK å’Œ K_IV åŒæ­¥ï¼‰
            short_iv = float(row.short_iv or 0.0)
            base_iv = float(row.meta.get("month_iv") or 0.0)
            IV_FLOOR = 12.0
            denom = max(IV_FLOOR, short_iv if short_iv > 0 else IV_FLOOR)
            row.meta["edge_month"] = (base_iv - short_iv) / denom
        except Exception:
            # è¿™é‡Œç»ä¸æŠ›å¼‚å¸¸ï¼Œé¿å… scan loop å´©
            return

    # -------------------------
    # Gate Logic (ALWAYS returns tuple)
    # -------------------------
    def _get_gate_status(self, row: ScanRow, bp: Optional[Blueprint], dna_type: str) -> Tuple[str, str]:
        status = "WAIT"
        reason = "Score/Structure suboptimal"

        try:
            # 1) Hard Kill
            if not bp:
                return "FORBID", "No Blueprint"

            bp_error = getattr(bp, "error", None)
            if bp_error:
                return "FORBID", f"Blueprint Error: {bp_error}"

            est_gamma = float((row.meta or {}).get("est_gamma", 0.0) or 0.0)
            if est_gamma >= float(self.gamma_hard):
                return "FORBID", f"Gamma {est_gamma:.3f} >= {self.gamma_hard}"

            if dna_type == "CRUSH":
                return "FORBID", "Momentum: IV CRUSH (-Delta)"

            # 2) Strategy Logic
            tag = str(getattr(row, "tag", "") or "")
            em = float((row.meta or {}).get("edge_micro", 0.0) or 0.0)
            ek = float((row.meta or {}).get("edge_month", 0.0) or 0.0)
            shape = str((row.meta or {}).get("shape", "FLAT") or "FLAT")

            strat_type = str(
                getattr(row, "strategy_type", None) or getattr(bp, "strategy", "") or ""
            ).upper()

            # --- LG / STRADDLE ---
            if ("LG" in tag) or ("STRADDLE" in strat_type):
                # Spread Check
                max_spread = (row.meta or {}).get("max_spread_pct", None)
                if max_spread is None:
                    max_spread = self.lg_max_spread_pct

                bp_meta = getattr(bp, "meta", None) or {}
                spread_pct = bp_meta.get("spread_pct", None)

                if (max_spread is not None) and (spread_pct is not None):
                    try:
                        if float(spread_pct) > float(max_spread):
                            return "FORBID", f"Spread {float(spread_pct):.1%} > {float(max_spread):.1%}"
                    except Exception:
                        pass

                allowed_exec = self.cfg.get("rules", {}).get("lg_allowed_dna_exec", ["PULSE"])
                allowed_limit = self.cfg.get("rules", {}).get("lg_allowed_dna_limit", ["TREND"])

                if dna_type in allowed_exec:
                    status, reason = "EXEC", f"Momentum {dna_type} (Aggressive)"
                elif dna_type in allowed_limit:
                    status, reason = "LIMIT", f"Momentum {dna_type} (Passive)"
                else:
                    status, reason = "WAIT", "Market Sleeping (Theta Burn)"

                if em < self.micro_min and ek < self.month_min:
                    return "WAIT", "Edges Too Low"

            # --- DIAG ---
            elif "DIAG" in tag:
                if ek < self.month_min:
                    status, reason = "WAIT", f"Back Edge {ek:.2f} < {self.month_min}"
                elif shape in ("FFBS", "STEEP"):
                    status, reason = "EXEC", "Structure Prime"
                elif shape == "SPIKE":
                    status, reason = "WAIT", "Spike Shape (Front IV too high)"
                else:
                    if em < self.micro_min:
                        status, reason = "WAIT", f"Front Edge {em:.2f} too low"
                    else:
                        status, reason = "LIMIT", "Structure OK"

            # --- Vertical ---
            elif ("BULL" in tag) or ("BEAR" in tag) or ("VERT" in tag):
                if int(getattr(row, "cal_score", 0) or 0) >= 60:
                    status, reason = "LIMIT", "Vertical Setup OK"
                else:
                    status, reason = "WAIT", f"Score {int(row.cal_score)} < 60"

            # 3) Soft Cap
            if status in ("EXEC", "LIMIT") and est_gamma >= float(self.gamma_soft):
                status, reason = "LIMIT", f"Gamma {est_gamma:.3f} > {self.gamma_soft} (Soft Cap)"

            # 4) General Momentum
            if status == "EXEC" and "LG" not in tag:
                if dna_type == "QUIET":
                    status, reason = "LIMIT", "Momentum Quiet (Wait for Pulse)"

            # 5) Diagnostic
            if row.symbol in LEV_ETFS and est_gamma > 0.20:
                reason += " [LEV_ETF Risk]"

            return status, reason

        except Exception as e:
            # å…œåº•ï¼šä»»ä½•å¼‚å¸¸éƒ½ä¸å…è®¸è¿”å› None
            return "WAIT", f"GateError: {e}"

    # -------------------------
    # Fallback planner
    # -------------------------
    def plan(self, ctx: Context, row: ScanRow) -> Blueprint:
        """
        å½“ç­–ç•¥æ²¡äº§å‡º blueprint æ—¶çš„å…œåº•ï¼šç”¨ short_exp åš STRADDLEã€‚
        æ³¨æ„ï¼šæ°¸è¿œè¿”å› Blueprintï¼Œä¸è¿”å› Noneã€‚
        """
        bp = build_straddle_blueprint(symbol=ctx.symbol, underlying=ctx.price, chain=ctx.raw_chain, exp=row.short_exp)
        if bp:
            if not getattr(bp, "note", ""):
                bp.note = "Fallback Gamma Plan"
            return bp

        # æœ€ç»ˆå…œåº•ï¼ˆä¿è¯ Blueprint æ„é€ ä¸ä¾èµ–ä½ç½®å‚æ•°ï¼‰
        return Blueprint(symbol=ctx.symbol, strategy="STRADDLE", legs=[], est_debit=0.0, note="Build Failed", error="No Pricing Data")

    # -------------------------
    # Pretty print
    # -------------------------
    def _print_enhanced_blueprint(self, bp: Blueprint, row: ScanRow, dna: str, gate: str, reason: str):
        tactic = ""
        if gate == "LIMIT":
            tactic = f"{Fore.CYAN}[æŒ‚å•æ½œä¼] Limit @ Mid-$0.05 | {reason}{Style.RESET_ALL}"
        elif gate == "EXEC":
            tactic = f"{Fore.GREEN}[ç«‹å³æ‰§è¡Œ] Market/Mid+$0.02 | {reason}{Style.RESET_ALL}"
        elif gate == "WAIT":
            tactic = f"{Fore.YELLOW}[ä¿æŒå…³æ³¨] {reason}{Style.RESET_ALL}"
        else:
            tactic = f"{Fore.RED}[ç¦æ­¢] {reason}{Style.RESET_ALL}"

        strat_name = getattr(bp, "strategy", None) or "UNKNOWN"
        print(
            f" {Fore.WHITE}{bp.symbol:<5} {strat_name:<13} | Gate: {gate:<5} | Debit: ${bp.est_debit} | Gamma: {(row.meta or {}).get('est_gamma', 0):.4f}"
        )
        print(f"    Edges: Micro {(row.meta or {}).get('edge_micro', 0):.2f} / Month {(row.meta or {}).get('edge_month', 0):.2f}")

        shape = (row.meta or {}).get("shape", "")
        mom = (row.meta or {}).get("momentum", "QUIET")
        print(f"    Shape: {shape:<8} | Momentum: {mom}")

        if "DIAG" in str(getattr(row, "tag", "") or "") and shape == "FFBS":
            print(f"    âœ… {Fore.GREEN}FFBS (Front-Flat Back-Steep): å®Œç¾å¯¹è§’çº¿å½¢æ€{Style.RESET_ALL}")

        print(f"    ğŸ‘‰ {tactic}")

        legs = getattr(bp, "legs", None) or []
        if legs:
            for leg in legs:
                action = str(getattr(leg, "action", "")).upper()
                action_sym = "+" if action == "BUY" else "-"
                print(f"       {action_sym}{leg.ratio} {leg.exp} {leg.strike:<6} {leg.type}")
        else:
            print(f"       [ERROR] No Legs: {getattr(bp, 'error', None)}")
        print(f"    {'=' * 80}")

    # -------------------------
    # Strategy loader
    # -------------------------
    def _load_strategy(self, name: str):
        from trade_guardian.domain.registry import StrategyRegistry

        registry = StrategyRegistry(self.cfg, self.policy)
        try:
            return registry.get(name)
        except Exception:
            from trade_guardian.strategies.auto import AutoStrategy

            return AutoStrategy(self.cfg, self.policy)


================================================================================
FILE_PATH: src\trade_guardian\app\persistence.py
================================================================================
import sqlite3
import os
import json
from datetime import datetime
from dataclasses import asdict

class PersistenceManager:
    def __init__(self, db_path=None):
        # [FIX] (C) è·¯å¾„é”šå®šï¼šæ— è®ºåœ¨å“ªé‡Œè¿è¡Œï¼Œéƒ½å®šä½åˆ°é¡¹ç›®æ ¹ç›®å½•ä¸‹çš„ db æ–‡ä»¶å¤¹
        if db_path:
            self.db_path = db_path
        else:
            # å½“å‰æ–‡ä»¶åœ¨ src/trade_guardian/app/
            base_dir = os.path.dirname(os.path.abspath(__file__))
            # å›é€€ 3 å±‚åˆ°é¡¹ç›®æ ¹ç›®å½• (src/trade_guardian/app -> src/trade_guardian -> src -> root)
            project_root = os.path.abspath(os.path.join(base_dir, "..", "..", ".."))
            self.db_path = os.path.join(project_root, "db", "trade_guardian.db")

        # ç¡®ä¿å­˜æ”¾ç›®å½•å­˜åœ¨
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)


    # [FIX] Issue B: æ¥æ”¶ç»Ÿè®¡å‚æ•° (avg_edge, cheap_vol, elapsed)
    def save_scan_session(self, strategy_name, vix, count, avg_edge, cheap_vol, elapsed, results_pack):
        """ä¿å­˜å•æ¬¡æ‰«æçš„æ‰€æœ‰ç»“æœ"""
        conn = sqlite3.connect(self.db_path)
        c = conn.cursor()
        
        try:
            # [FIX] (B) æ—¶é—´æ ¼å¼ä¿®å¤ï¼šSQLite å¯¹ ISO 8601 (å¸¦T) æ”¯æŒä¸å¥½ï¼Œæ”¹ç”¨ç©ºæ ¼åˆ†éš”
            current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            c.execute("""INSERT INTO scan_batches 
                      (timestamp, strategy_name, market_vix, universe_size, avg_abs_edge, cheap_vol_pct, elapsed_time) 
                      VALUES (?, ?, ?, ?, ?, ?, ?)""",
                      (current_time, strategy_name, vix, count, avg_edge, cheap_vol, elapsed))
            batch_id = c.lastrowid
            
            for item in results_pack:
                row, ctx, bp, gate = item
                
                # [FIX] (D) è¡¥å…¨å­—æ®µï¼šå†™å…¥ hv_rank å’Œ regimeï¼Œé˜²æ­¢æ•°æ®ä¸¢å¤±
                # æ³¨æ„ï¼šè¿™é‡Œéœ€è¦ create_tg_db.py é‡Œ market_snapshots è¡¨ç»“æ„é…åˆ (ä½ ä¹‹å‰çš„ schema å·²ç»æœ‰äº†)
                c.execute("""INSERT INTO market_snapshots 
                          (batch_id, symbol, price, iv_short, iv_base, edge, hv_rank, regime) 
                          VALUES (?, ?, ?, ?, ?, ?, ?, ?)""",
                          (batch_id, row.symbol, row.price, row.short_iv, row.base_iv, row.edge, row.hv_rank, row.regime))
                snap_id = c.lastrowid
                
                tag_val = row.tag 
                est_gamma = row.meta.get("est_gamma", 0.0)
                est_debit = bp.est_debit if bp else 0.0
                strat_name = bp.strategy if bp else "NONE"
                
                # --- [NEW] è“å›¾åºåˆ—åŒ–é€»è¾‘ ---
                bp_json_str = ""
                if bp:
                    try:
                        # å°† dataclass è½¬æ¢ä¸ºå­—å…¸ï¼Œå†åºåˆ—åŒ–ä¸º JSON å­—ç¬¦ä¸²
                        bp_dict = asdict(bp)
                        bp_json_str = json.dumps(bp_dict)
                    except Exception as e:
                        print(f"âš ï¸ Failed to serialize blueprint for {row.symbol}: {e}")

                # --- [NEW] æ’å…¥ blueprint_json ---
                c.execute("""INSERT INTO trade_plans 
                          (snapshot_id, strategy_type, cal_score, short_risk, gate_status, est_debit, total_gamma, tag, blueprint_json) 
                          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                          (snap_id, strat_name, row.cal_score, row.short_risk, gate, est_debit, est_gamma, tag_val, bp_json_str))
                
            conn.commit()
            print(f"ğŸ’¾ [DB] Saved Batch {batch_id}: {count} items | AvgEdge: {avg_edge:.2f} | Time: {elapsed:.1f}s")
            
        except Exception as e:
            import traceback
            traceback.print_exc()
            print(f"âŒ [DB Error] Save failed: {e}")
        finally:
            conn.close()

================================================================================
FILE_PATH: src\trade_guardian\app\renderer.py
================================================================================
from __future__ import annotations
import os
from typing import List, Optional, Any
from trade_guardian.domain.models import ScanRow

# === 1. å®šä¹‰é¢œè‰²ä»£ç  ===
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    WARNING = '\033[93m' # é»„è‰²
    FAIL = '\033[91m'    # çº¢è‰²
    ENDC = '\033[0m'     # é‡ç½®é¢œè‰²
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

# è®© Windows ç»ˆç«¯æ”¯æŒ ANSI é¢œè‰²
os.system('')

class ScanlistRenderer:
    def __init__(self, cfg=None, policy=None, hv_cache_path: Optional[str] = None):
        self.cfg = cfg
        self.policy = policy
        self.hv_cache_path = hv_cache_path

    def _sanitize_int(self, value: Any, default: int = 0) -> int:
        """é˜²å¾¡æ€§ç¼–ç¨‹ï¼šç¡®ä¿è¿”å›çš„ä¸€å®šæ˜¯ int"""
        try:
            if isinstance(value, int): return value
            if isinstance(value, str) and value.isdigit(): return int(value)
            if isinstance(value, list): return self._sanitize_int(value[0], default) if value else default
            return default
        except:
            return default

    # [ä¸»æ¸²æŸ“å…¥å£]
    def render(self, 
               strict: List[ScanRow], 
               auto_adjusted: List[ScanRow], 
               watch: List[ScanRow], 
               days: int, 
               min_score: int = 0, 
               max_risk: int = 100, 
               detail: bool = False, 
               universe_size: int = 0,
               top: Any = 0, 
               **kwargs): # åæ‰æ‰€æœ‰æœªå®šä¹‰çš„å‚æ•°
        
        # æ¸…ç† top å‚æ•°
        safe_top = self._sanitize_int(top, 0)
        
        # æ‰“å°å¤´éƒ¨ä¿¡æ¯
        print("")
        print("=" * 95)
        print(f"ğŸ§  {Colors.HEADER}TRADE GUARDIAN :: SCANLIST (days={days}){Colors.ENDC}")
        print("=" * 95)
        
        # ç»Ÿè®¡ä¿¡æ¯
        adjusted_list = auto_adjusted if auto_adjusted else []
        total = universe_size if universe_size > 0 else (len(strict) + len(adjusted_list) + len(watch))
        
        print(f"Universe size: {total} | Strict: {len(strict)} | AutoAdjusted: {len(adjusted_list)} | Watch: {len(watch)} | Errors: 0")
        print(f"Strict Filter: score >= {min_score}, short_risk <= {max_risk}")
        if self.hv_cache_path:
            print(f"Throttle: 0.50s/ticker | HV cache: {self.hv_cache_path}")
        
        # æ‰“å°è¡¨æ ¼
        if strict:
            self._print_table(f"âœ… {Colors.GREEN}Strict Candidates (actionable now){Colors.ENDC}", strict)
            if detail:
                self._print_details("Top details (per-row explain)", strict)
                # æ‰“å°è“å›¾ (å»æ‰äº† Strategy #3 çš„æ–‡å­—)
                self._print_blueprints(f"ğŸš€ {Colors.CYAN}Actionable Blueprints{Colors.ENDC}", strict)

        if adjusted_list:
            self._print_table("ğŸ¤– Auto-Adjusted Candidates", adjusted_list)

        if watch:
            self._print_table("ğŸ‘€ Watchlist", watch)

    # [è¯Šæ–­ä¿¡æ¯å…¥å£]
    def render_diagnostics(self, strict: List[ScanRow], **kwargs):
        if not strict: return

        print(f"\nğŸ§¾ Diagnostics")
        avg_score = sum(r.cal_score for r in strict) / len(strict)
        
        # è®¡ç®—å¹³å‡ Edge
        valid_edges = [r.edge for r in strict if r.edge > 0]
        avg_edge = sum(valid_edges) / len(valid_edges) if valid_edges else 0.0
        
        print(f"   â€¢ Avg Score: {avg_score:.1f} | Avg Edge: {avg_edge:.2f}x")

    # [å†…éƒ¨ helper] æ‰“å°è¡¨æ ¼
    def _print_table(self, title: str, rows: List[ScanRow]):
        if not rows: return
        if title: print(f"\n{title}")
        
        header = f"{'Sym':<6} {'Px':<7} {'ShortExp':<10} {'ShortDTE':>8} {'ShortIV':>8} {'BaseIV':>8} {'Edge':>7} {'HV%':>5} {'Score':>7} {'Risk':>6} {'Tag':<11}"
        print(header)
        print("-" * len(header))
        
        for r in rows:
            # IV ä¿®æ­£ï¼šé™¤ä»¥ 100
            short_iv_val = r.short_iv / 100.0
            base_iv_val = r.base_iv / 100.0
            
            row_str = (
                f"{r.symbol:<6} "
                f"{r.price:<7.2f} "
                f"{r.short_exp:<10} "
                f"{r.short_dte:>8} "
                f"{short_iv_val:>8.1%} "
                f"{base_iv_val:>8.1%} "
                f"{r.edge:>6.2f}x "
                f"{r.hv_rank:>4.0f}% "
                f"{r.cal_score:>7} "
                f"{r.short_risk:>6} "
                f"{r.tag:<11}"
            )
            print(row_str)

    # [å†…éƒ¨ helper] æ‰“å°è¯¦æƒ…
    def _print_details(self, title: str, rows: List[ScanRow]):
        print(f"\n{title}")
        print("Explain legend")
        print("  score parts: b=base, rg=regime, ed=edge, hv=HV-rank slot, cv=curvature, pen=penalties")
        print("  risk  parts: b=base, dte=time-to-expiry, gm=gamma proxy, cv=curvature risk, rg=regime risk, pen=penalties")
        
        for r in rows:
            bd = r.score_breakdown
            rbd = r.risk_breakdown
            print(f"\n  {Colors.BOLD}{r.symbol:<6}{Colors.ENDC} score={r.cal_score:<3} [b{bd.base:+} rg{bd.regime:+} ed{bd.edge:+} hv{bd.hv:+} cv{bd.curvature:+} pen{bd.penalties:+}] | edge={r.edge:.2f}x tag={r.tag} hv={r.hv_rank:.0f}%")
            print(f"         risk={r.short_risk:<3} [b{rbd.base:+} dte{rbd.dte:+} gm{rbd.gamma:+} cv{rbd.curvature:+} rg{rbd.regime:+}] | short={r.short_exp} d{r.short_dte}")

    # [å†…éƒ¨ helper] æ‰“å°è“å›¾ (åŒ…å« Greeks)
    def _print_blueprints(self, title: str, rows: List[ScanRow]):
        valid_rows = [r for r in rows if getattr(r, 'blueprint', None)]
        if not valid_rows: return

        print(f"\n{title}")
        print("-" * 95)
        for r in valid_rows:
            bp = r.blueprint
            
            # æ‘˜è¦è¡Œ
            line = bp.one_liner()
            if "est_debit=" in line:
                parts = line.split("est_debit=")
                line = f"{parts[0]}{Colors.CYAN}est_debit={parts[1]}{Colors.ENDC}"
            print(f"  {line}")
            
            # Note è¡Œ
            note = getattr(bp, "note", "")
            if note:
                if "WARNING" in note or "Risk" in note:
                    print(f"    Note: {Colors.FAIL}{note}{Colors.ENDC}")
                elif "Healthy" in note:
                    print(f"    Note: {Colors.GREEN}{note}{Colors.ENDC}")
                else:
                    print(f"    Note: {note}")

            # è…¿éƒ¨è¯¦æƒ… (å¸¦ Greeks)
            if hasattr(bp, "short_exp") and hasattr(bp, "long_exp"):
                # Diagonal / PMCC / Calendar
                if hasattr(bp, "short_strike") and hasattr(bp, "long_strike"):
                     # PMCC
                     s_delta = bp.short_greeks.get("delta", 0) if getattr(bp, "short_greeks", None) else 0
                     l_delta = bp.long_greeks.get("delta", 0) if getattr(bp, "long_greeks", None) else 0
                     print(f"    Legs: +{bp.long_exp} ({bp.long_strike}C) [Î”{l_delta:.2f}]")
                     print(f"          -{bp.short_exp} ({bp.short_strike}C) [Î”{s_delta:.2f}]")
                else:
                     # Calendar
                     print(f"    Legs: -{bp.short_exp} / +{bp.long_exp} @ Strike {bp.strike}")
            
            elif hasattr(bp, "exp"):
                # Straddle
                atm_gamma = bp.greeks.get("gamma", 0) if getattr(bp, "greeks", None) else 0
                atm_delta = bp.greeks.get("delta", 0) if getattr(bp, "greeks", None) else 0
                print(f"    Legs: +{bp.exp} CALL & PUT @ Strike {bp.strike} [Î”{atm_delta:.2f} Î“{atm_gamma:.3f}]")
            
            else:
                print(f"    Legs: (Unknown structure)")

        print("-" * 95)
        print("")

================================================================================
FILE_PATH: src\trade_guardian\app\__init__.py
================================================================================


================================================================================
FILE_PATH: src\trade_guardian\domain\features.py
================================================================================
from __future__ import annotations

from typing import Dict, List

from trade_guardian.domain.models import HVInfo, TermPoint
from trade_guardian.domain.policy import ShortLegPolicy


class TSFeatureBuilder:
    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy

    @staticmethod
    def _eligible_points(term: List[TermPoint], min_dte: int) -> List[TermPoint]:
        return [p for p in term if p.dte >= min_dte]

    @staticmethod
    def _baseline_iv(term: List[TermPoint], fallback_iv: float) -> float:
        mids = [p.iv for p in term if 30 <= p.dte <= 90 and p.iv > 0]
        if mids:
            return float(sum(mids) / len(mids))
        return float(fallback_iv)

    def build(self, term: List[TermPoint], hv: HVInfo, rank: int) -> Dict[str, object]:
        if not term:
            return {"status": "Error", "msg": "Empty term structure"}

        eligible = self._eligible_points(term, self.policy.min_dte)
        if not eligible:
            return {"status": "Error", "msg": f"No eligible expiries (min_dte={self.policy.min_dte})"}

        if rank < 0 or rank >= len(eligible):
            return {"status": "Error", "msg": f"Rank out of range: rank={rank} eligible={len(eligible)}"}

        short = eligible[rank]
        base_iv = self._baseline_iv(term, fallback_iv=short.iv)

        # regime: compare base vs short
        if base_iv > short.iv * 1.03:
            regime = "CONTANGO"
        elif short.iv > base_iv * 1.03:
            regime = "BACKWARDATION"
        else:
            regime = "FLAT"

        # curvature: compare rank0 (nearest eligible) vs short
        front = eligible[0]
        squeeze_ratio = (front.iv / base_iv) if base_iv > 0 else 0.0

        # spiky front when rank0 materially richer than short rank
        curv = "SPIKY_FRONT" if (front.iv > short.iv * 1.20 and front.dte < 14) else "NORMAL"

        edge = (short.iv / base_iv) if base_iv > 0 else 0.0

        return {
            "status": "Success",
            "regime": regime,
            "curvature": curv,
            "short_exp": short.exp,
            "short_dte": short.dte,
            "short_iv": short.iv,
            "base_iv": base_iv,
            "edge": edge,
            "squeeze_ratio": squeeze_ratio,
        }


================================================================================
FILE_PATH: src\trade_guardian\domain\hv.py
================================================================================
from __future__ import annotations

from trade_guardian.domain.models import HVInfo
from trade_guardian.infra.cache import JsonDailyCache
from trade_guardian.infra.schwab_client import SchwabClient


class HVService:
    def __init__(self, client: SchwabClient, cache: JsonDailyCache):
        self.client = client
        self.cache = cache

    def get_hv(self, symbol: str) -> HVInfo:
        cached = self.cache.get(symbol)
        if cached:
            return HVInfo(**cached)

        hv = self.client.calculate_hv_percentile(symbol)
        # store even if partial to avoid repeated API spam
        self.cache.set(symbol, hv.__dict__)
        return hv


================================================================================
FILE_PATH: src\trade_guardian\domain\models.py
================================================================================
from __future__ import annotations
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any

# --- åŸºç¡€è®¾æ–½ç±» (ç”¨äº SchwabClient ç­‰) ---

@dataclass
class HVInfo:
    """Historical Volatility Data Container"""
    current_hv: float = 0.0
    hv_rank: float = 0.0
    hv_percentile: float = 0.0
    high_52w: float = 0.0
    low_52w: float = 0.0
    status: str = "Success"
    msg: str = ""
    hv_low: float = 0.0
    hv_high: float = 0.0
    p50: float = 0.0
    p75: float = 0.0
    p90: float = 0.0

@dataclass
class TermPoint:
    """Term Structure Point (ç”¨äº term structure è®¡ç®—)"""
    exp: str = "" 
    exp_date: str = "" 
    dte: int = 0
    iv: float = 0.0
    strike: float = 0.0
    mark: float = 0.0
    delta: float = 0.0
    theta: float = 0.0
    gamma: float = 0.0

# --- æ ¸å¿ƒåˆ†æç±» ---

@dataclass
class IVData:
    rank: float = 0.0
    percentile: float = 0.0
    current_iv: float = 0.0
    hv_rank: float = 0.0
    current_hv: float = 0.0

@dataclass
class Context:
    symbol: str
    price: float
    iv: IVData
    hv: IVData
    tsf: dict  # Term Structure Factors
    raw_chain: dict
    metrics: Any = None 
    # [FIX] P0-1: å¢åŠ  term å­—æ®µï¼Œé˜²æ­¢ Calendar ç­–ç•¥æŠ¥é”™
    term: List[TermPoint] = field(default_factory=list) 

@dataclass
class ScoreBreakdown:
    base: int = 0
    regime: int = 0
    edge: int = 0
    hv: int = 0
    curvature: int = 0
    penalties: int = 0

@dataclass
class RiskBreakdown:
    base: int = 0
    dte: int = 0
    gamma: int = 0
    regime: int = 0
    curvature: int = 0
    penalties: int = 0

@dataclass
class ScanRow:
    symbol: str
    price: float
    short_exp: str
    short_dte: int
    short_iv: float
    base_iv: float
    edge: float
    hv_rank: float
    regime: str
    curvature: str
    tag: str
    cal_score: int
    short_risk: int
    score_breakdown: ScoreBreakdown
    risk_breakdown: RiskBreakdown
    meta: Dict[str, Any] = field(default_factory=dict)
    # å…è®¸åŠ¨æ€æŒ‚è½½ blueprint
    blueprint: Optional[Blueprint] = None

@dataclass
class Recommendation:
    strategy: str
    symbol: str
    action: str
    rationale: str
    entry_price: float
    score: int
    conviction: str
    meta: dict

# --- æ‰§è¡Œè“å›¾ç±» (Orchestrator éœ€è¦) ---

@dataclass
class OrderLeg:
    """å®šä¹‰æœŸæƒç­–ç•¥çš„ä¸€æ¡è…¿"""
    symbol: str
    action: str      # BUY / SELL
    ratio: int       # e.g. 1
    exp: str         # Expiry Date (YYYY-MM-DD)
    strike: float
    type: str        # CALL / PUT

@dataclass
class Blueprint:
    """å®šä¹‰æœ€ç»ˆç”Ÿæˆçš„æ‰§è¡Œè“å›¾"""
    symbol: str
    strategy: str
    legs: List[OrderLeg] = field(default_factory=list)
    est_debit: float = 0.0
    note: str = ""
    gamma_exposure: float = 0.0
    error: Optional[str] = None

    # [NEW] å…è®¸å­˜æ”¾ spread_pct / pin_risk / extra diagnostics ç­‰
    meta: Dict[str, Any] = field(default_factory=dict)

    # å…è®¸åŠ¨æ€æŒ‚è½½ greeks å­—å…¸
    short_greeks: Dict[str, float] = field(default_factory=dict)
    long_greeks: Dict[str, float] = field(default_factory=dict)
    greeks: Dict[str, float] = field(default_factory=dict)

    def one_liner(self) -> str:
        return f"{self.symbol} {self.strategy} | est_debit={self.est_debit}"


================================================================================
FILE_PATH: src\trade_guardian\domain\policy.py
================================================================================
from dataclasses import dataclass
from typing import List


@dataclass(frozen=True)
class ShortLegPolicy:
    base_rank: int = 1
    min_dte: int = 3
    max_probe_rank: int = 3  # count, e.g. 3 => ranks base..base+2

    def probe_ranks(self) -> List[int]:
        if self.max_probe_rank <= 1:
            return [self.base_rank]
        return list(range(self.base_rank, self.base_rank + self.max_probe_rank))


================================================================================
FILE_PATH: src\trade_guardian\domain\registry.py
================================================================================
from __future__ import annotations

from trade_guardian.domain.policy import ShortLegPolicy

from trade_guardian.strategies.auto import AutoStrategy
from trade_guardian.strategies.calendar import CalendarStrategy
from trade_guardian.strategies.hv_calendar import HVCalendarStrategy
from trade_guardian.strategies.long_gamma import LongGammaStrategy
from trade_guardian.strategies.diagonal import DiagonalStrategy
from trade_guardian.strategies.iron_condor import IronCondorStrategy
from trade_guardian.strategies.vertical_credit import VerticalCreditStrategy


class StrategyRegistry:
    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy

    def get(self, name: str):
        n = (name or "").strip().lower()

        if n in ("calendar", "cal"):
            return CalendarStrategy(self.cfg, self.policy)

        if n in ("hv_calendar", "hvcal", "hv"):
            return HVCalendarStrategy(self.cfg, self.policy)
            
        if n in ("long_gamma", "gamma", "straddle", "lg"):
            return LongGammaStrategy(self.cfg, self.policy)
        
        if n in ("diagonal", "pmcc", "diag"):
            return DiagonalStrategy(self.cfg, self.policy)
        
        # [æ–°å¢] IC æ³¨å†Œé€»è¾‘
        if n in ("ic", "condor", "iron_condor"):
            return IronCondorStrategy(self.cfg, self.policy)
        
        # [æ–°å¢] å‚ç›´ä»·å·®
        if n in ("vertical", "pcs", "ccs", "credit_spread"):
            return VerticalCreditStrategy(self.cfg, self.policy)
        
        
        if n in ("auto", "smart", "default"):
            return AutoStrategy(self.cfg, self.policy)
        
        # æ›´æ–°æŠ¥é”™ä¿¡æ¯
        raise KeyError(f"Unknown strategy: {name}. Available: calendar, hv, lg, diagonal, ic, vertical, auto")

================================================================================
FILE_PATH: src\trade_guardian\domain\scoring.py
================================================================================
from __future__ import annotations

from dataclasses import dataclass

from trade_guardian.domain.models import ScoreBreakdown


@dataclass(frozen=True)
class ScoringRules:
    # core
    min_edge_short_base: float = 1.05

    # HV-aware (Strategy #2)
    hv_enabled: bool = False
    hv_low_rank: float = 20.0
    hv_mid_rank: float = 50.0
    hv_high_rank: float = 70.0

    hv_low_bonus: int = 10     # hv_rank <= low
    hv_mid_bonus: int = 4      # (low, mid]
    hv_high_penalty: int = -4  # (mid, high]
    hv_extreme_penalty: int = -10  # > high


class Scoring:
    def __init__(self, rules: ScoringRules):
        self.rules = rules

    def _hv_points(self, hv_rank: float) -> int:
        """
        HV scoring (explainable bucket model):
          - low hv_rank: calendars generally benefit from "room for vol expansion"
          - high hv_rank: you're paying rich vol; calendar can become "chasing vol"
        """
        if not self.rules.hv_enabled:
            return 0

        r = float(hv_rank)
        if r <= self.rules.hv_low_rank:
            return int(self.rules.hv_low_bonus)
        if r <= self.rules.hv_mid_rank:
            return int(self.rules.hv_mid_bonus)
        if r <= self.rules.hv_high_rank:
            return int(self.rules.hv_high_penalty)
        return int(self.rules.hv_extreme_penalty)

    def score_calendar(self, regime: str, curvature: str, edge: float, hv_rank: float) -> tuple[int, ScoreBreakdown]:
        """
        Keep simple & explainable:
          base 50
          +curv bonus when SPIKY_FRONT
          edge: reward if >= min_edge_short_base, penalty if weak
          regime: penalize CONTANGO a bit, neutral FLAT, small bonus BACKWARDATION
          hv: optional bucketed adjustment (Strategy #2)
        """
        bd = ScoreBreakdown(base=50)

        # regime
        if regime == "CONTANGO":
            bd.regime = -8
        elif regime == "BACKWARDATION":
            bd.regime = +4
        else:
            bd.regime = 0

        # curvature
        bd.curvature = +6 if curvature == "SPIKY_FRONT" else 0

        # edge
        if edge >= self.rules.min_edge_short_base:
            bd.edge = +8
        elif edge >= 1.0:
            bd.edge = -8
        else:
            bd.edge = -14

        # hv (strategy #2)
        bd.hv = self._hv_points(hv_rank)

        total = bd.base + bd.regime + bd.edge + bd.hv + bd.curvature + bd.penalties
        return int(total), bd


================================================================================
FILE_PATH: src\trade_guardian\domain\__init__.py
================================================================================



================================================================================
FILE_PATH: src\trade_guardian\infra\cache.py
================================================================================
from __future__ import annotations

import json
import os
from datetime import datetime
from typing import Any, Dict, Optional


class JsonDailyCache:
    """
    Simple daily cache. Resets automatically each day by storing a date stamp.
    """
    def __init__(self, path: str):
        self.path = path
        self._data: Dict[str, Any] = {}
        self._load()

    def _load(self):
        if not os.path.exists(self.path):
            self._data = {"_date": self._today(), "items": {}}
            return
        try:
            with open(self.path, "r", encoding="utf-8") as f:
                self._data = json.load(f)
        except Exception:
            self._data = {"_date": self._today(), "items": {}}

        if self._data.get("_date") != self._today():
            self._data = {"_date": self._today(), "items": {}}

    def _save(self):
        os.makedirs(os.path.dirname(self.path), exist_ok=True)
        with open(self.path, "w", encoding="utf-8") as f:
            json.dump(self._data, f, indent=2)

    @staticmethod
    def _today() -> str:
        return datetime.now().strftime("%Y-%m-%d")

    def get(self, key: str) -> Optional[dict]:
        return self._data.get("items", {}).get(key)

    def set(self, key: str, value: dict) -> None:
        self._data.setdefault("items", {})[key] = value
        self._save()


================================================================================
FILE_PATH: src\trade_guardian\infra\config.py
================================================================================
from __future__ import annotations

import json
import os
import yaml  # <--- [NEW] å¼•å…¥ yaml
from typing import Any, Dict, Optional

from trade_guardian.domain.policy import ShortLegPolicy

# é»˜è®¤é…ç½®ä¿æŒå­—å…¸ç»“æ„ä¸å˜ (ä»£ç é‡Œç”¨)
DEFAULT_CONFIG: Dict[str, Any] = {
    "paths": {
        "tickers_csv": "data/tickers.csv",
        "cache_dir": "cache",
    },
    "scan": {
        "throttle_sec": 0.50,
        "contract_type": "ALL",
    },
    "rules": {
        "min_edge_short_base": 1.05,
        "lg_min_dte_etf": 7,
        "lg_min_dte_stock": 10,
        "pin_risk_threshold": 0.25
    },
    "policy": {
        "base_rank": 1,
        "min_dte": 3,
        "probe_count": 3,
    },
    "strategies": {
        "hv_calendar": {
            "hv_rules": {
                "hv_low_rank": 20.0,
                "hv_mid_rank": 50.0,
                "hv_high_rank": 70.0,
                "hv_low_bonus": 10,
                "hv_mid_bonus": 4,
                "hv_high_penalty": -4,
                "hv_extreme_penalty": -10,
            }
        }
    },
}


def _deep_merge(a: Dict[str, Any], b: Dict[str, Any]) -> Dict[str, Any]:
    out = dict(a)
    for k, v in b.items():
        if isinstance(v, dict) and isinstance(out.get(k), dict):
            out[k] = _deep_merge(out[k], v)  # type: ignore[arg-type]
        else:
            out[k] = v
    return out


def load_config(path: str, default_cfg: Dict[str, Any]) -> Dict[str, Any]:
    """
    [MOD] æ”¯æŒåŠ è½½ .yaml æˆ– .json æ–‡ä»¶
    """
    if not os.path.exists(path):
        # å°è¯•æ‰¾åŒåçš„ .yaml æ–‡ä»¶ (å¦‚æœä¼ å…¥çš„æ˜¯ .json)
        base, ext = os.path.splitext(path)
        if ext == '.json':
            yaml_path = base + '.yaml'
            if os.path.exists(yaml_path):
                path = yaml_path
            else:
                return dict(default_cfg)
        else:
            return dict(default_cfg)

    with open(path, "r", encoding="utf-8") as f:
        # [MOD] æ ¹æ®æ‰©å±•åå†³å®šè§£ææ–¹å¼
        if path.endswith(('.yaml', '.yml')):
            user_cfg = yaml.safe_load(f)
        else:
            user_cfg = json.load(f)

    if not isinstance(user_cfg, dict):
        return dict(default_cfg)
    return _deep_merge(default_cfg, user_cfg)


def write_config_template(path: str, default_cfg: Dict[str, Any], overwrite: bool = False) -> None:
    """
    [MOD] å†™å…¥é…ç½®æ¨¡æ¿ (å¦‚æœæ˜¯ .yaml åˆ™å†™å…¥ YAML æ ¼å¼)
    æ³¨æ„ï¼šç¨‹åºè‡ªåŠ¨å†™å…¥æ—¶æ— æ³•ä¿ç•™æ³¨é‡Šï¼Œå»ºè®®ç”¨æˆ·æ‰‹åŠ¨ç»´æŠ¤ config.yaml
    """
    # å¦‚æœä¼ å…¥çš„æ˜¯ .json ä½†æˆ‘ä»¬æƒ³å¼ºåˆ¶è½¬ä¸º yaml (å¯é€‰)
    if path.endswith('.json'):
        path = path.replace('.json', '.yaml')

    if os.path.exists(path) and not overwrite:
        return
        
    os.makedirs(os.path.dirname(path), exist_ok=True)
    
    with open(path, "w", encoding="utf-8") as f:
        if path.endswith(('.yaml', '.yml')):
            # default_flow_style=False ä¿è¯è¾“å‡ºä¸ºå—çŠ¶æ ¼å¼ï¼Œæ›´æ˜“è¯»
            yaml.dump(default_cfg, f, default_flow_style=False, allow_unicode=True)
        else:
            json.dump(default_cfg, f, indent=2, ensure_ascii=False)

def merge_config_paths(cfg: Dict[str, Any], root: str, csv_override: Optional[str]) -> Dict[str, Any]:
    # ... (ä¿æŒä¸å˜) ...
    out = dict(cfg)
    out.setdefault("paths", {})
    paths = dict(out["paths"])

    if csv_override:
        paths["tickers_csv"] = csv_override

    tickers_csv = paths.get("tickers_csv", "data/tickers.csv")
    if not os.path.isabs(tickers_csv):
        tickers_csv = os.path.join(root, tickers_csv)
    paths["tickers_csv"] = os.path.normpath(tickers_csv)

    cache_dir = paths.get("cache_dir", "cache")
    if not os.path.isabs(cache_dir):
        cache_dir = os.path.join(root, cache_dir)
    paths["cache_dir"] = os.path.normpath(cache_dir)

    out["paths"] = paths
    return out


def _resolve_probe_count(pcfg: Dict[str, Any], base_rank: int) -> int:
    """
    Return probe_count (>=1).
    æ”¯æŒï¼š
      - policy.probe_count
      - policy.max_probe_rank (inclusive)
    """
    if "probe_count" in pcfg and pcfg.get("probe_count") is not None:
        try:
            c = int(pcfg["probe_count"])
            return max(1, c)
        except Exception:
            return 3

    if "max_probe_rank" in pcfg and pcfg.get("max_probe_rank") is not None:
        try:
            mx = int(pcfg["max_probe_rank"])
            return max(1, (mx - int(base_rank) + 1))
        except Exception:
            return 3
    return 3


def policy_from_cfg_and_cli(cfg: Dict[str, Any], args) -> ShortLegPolicy:
    """
    Build ShortLegPolicy from config + CLI overrides.

    CLI args:
      --short-rank
      --min-short-dte
      --max-probe-rank   (meaning: absolute inclusive rank upper bound)
    """
    pcfg = (cfg.get("policy", {}) or {})

    base_rank = int(pcfg.get("base_rank", 1))
    min_dte = int(pcfg.get("min_dte", 3))
    probe_count = _resolve_probe_count(pcfg, base_rank)

    if getattr(args, "short_rank", None) is not None:
        base_rank = int(args.short_rank)
    if getattr(args, "min_short_dte", None) is not None:
        min_dte = int(args.min_short_dte)

    if getattr(args, "max_probe_rank", None) is not None:
        mx = int(args.max_probe_rank)
        probe_count = max(1, (mx - int(base_rank) + 1))

    return ShortLegPolicy(int(base_rank), int(min_dte), int(probe_count))

================================================================================
FILE_PATH: src\trade_guardian\infra\rate_limit.py
================================================================================
import time


class RateLimiter:
    def __init__(self, throttle_sec: float):
        self.throttle_sec = float(throttle_sec)

    def sleep(self):
        if self.throttle_sec > 0:
            time.sleep(self.throttle_sec)


================================================================================
FILE_PATH: src\trade_guardian\infra\retry_option_chain.py
================================================================================
from __future__ import annotations

import json
import logging
import random
import time
from dataclasses import dataclass, asdict
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Callable, Dict, Optional, Tuple

log = logging.getLogger(__name__)


@dataclass(frozen=True)
class RetryConfig:
    max_attempts: int = 3
    base_sleep_s: float = 0.5      # first backoff
    max_sleep_s: float = 4.0       # cap
    jitter_s: float = 0.15         # random +/- jitter
    timeout_s: float = 10.0        # if your client supports timeout, pass it through


@dataclass
class FetchAttemptRecord:
    ts_utc: str
    symbol: str
    provider: str
    attempt: int
    max_attempts: int
    ok: bool

    # request parameters you care about
    request_params: Dict[str, Any]

    # response/exception info
    reason: str = ""               # classified reason string
    http_status: Optional[int] = None
    error: str = ""                # exception message if any
    response_meta: Dict[str, Any] = None  # optional: headers, request_id, etc.
    response_snippet: str = ""     # short text snippet (safe length)


class OptionChainFetchError(RuntimeError):
    pass


def _utc_now_iso() -> str:
    return datetime.now(timezone.utc).isoformat(timespec="seconds")


def _safe_snippet(s: Any, max_len: int = 400) -> str:
    if s is None:
        return ""
    try:
        txt = s if isinstance(s, str) else json.dumps(s, ensure_ascii=False)
    except Exception:
        txt = repr(s)
    txt = txt.replace("\n", " ").replace("\r", " ")
    return txt[:max_len]


def classify_empty_response(
    *,
    payload: Any,
    http_status: Optional[int] = None,
    error: Optional[BaseException] = None,
) -> str:
    """
    Return a stable machine-readable reason.
    Keep this conservative: it's for diagnostics, not logic.
    """
    if error is not None:
        msg = str(error).lower()
        if "timeout" in msg:
            return "timeout"
        if "rate" in msg or "429" in msg:
            return "rate_limited"
        if "403" in msg or "forbidden" in msg:
            return "forbidden"
        if "401" in msg or "unauthorized" in msg:
            return "unauthorized"
        if "not found" in msg or "404" in msg:
            return "not_found"
        if "connection" in msg or "ssl" in msg:
            return "network_error"
        return "exception"

    if http_status is not None:
        if http_status == 204:
            return "no_content"
        if http_status == 404:
            return "not_found"
        if http_status == 401:
            return "unauthorized"
        if http_status == 403:
            return "forbidden"
        if http_status == 429:
            return "rate_limited"
        if 500 <= http_status <= 599:
            return "server_error"
        if 400 <= http_status <= 499:
            return "client_error"

    # payload-level hints
    if payload is None:
        return "payload_none"
    if isinstance(payload, (list, tuple)) and len(payload) == 0:
        return "payload_empty_list"
    if isinstance(payload, dict) and len(payload.keys()) == 0:
        return "payload_empty_dict"

    # common shapes: provider returns {"errors":[...]} or {"message": "..."}
    if isinstance(payload, dict):
        if "error" in payload:
            return "payload_error_field"
        if "errors" in payload and payload.get("errors"):
            return "payload_errors"
        if "message" in payload and payload.get("message"):
            return "payload_message"
        # option-chain typical: chain/expirations missing
        for k in ("callExpDateMap", "putExpDateMap", "options", "data"):
            if k in payload and not payload.get(k):
                return f"payload_missing_{k}"

    return "unknown_empty_or_unexpected"


def _write_jsonl(path: Path, record: Dict[str, Any]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("a", encoding="utf-8") as f:
        f.write(json.dumps(record, ensure_ascii=False) + "\n")


def fetch_with_retry_and_diagnostics(
    *,
    symbol: str,
    provider: str,
    request_params: Dict[str, Any],
    fetch_fn: Callable[[Dict[str, Any]], Tuple[Any, Optional[int], Dict[str, Any]]],
    # fetch_fn contract:
    #   input: request_params
    #   return: (payload, http_status, response_meta)
    #   - http_status may be None if not available
    #   - response_meta may include request_id, headers, url, etc.
    retry: RetryConfig = RetryConfig(),
    diag_jsonl_path: Path = Path("cache") / "option_chain_failures.jsonl",
    # If True: only retry on transient reasons; if False: retry all failures
    retry_only_transient: bool = True,
) -> Any:
    """
    This function is meant to sit in your infra layer.
    It does:
      - retry/backoff
      - classify failures and write JSONL diagnostic records
    """

    transient_reasons = {
        "timeout",
        "network_error",
        "server_error",
        "rate_limited",
        "no_content",
        "unknown_empty_or_unexpected",
        "payload_none",
        "payload_empty_list",
        "payload_empty_dict",
    }

    last_error: Optional[BaseException] = None
    last_reason = "unknown"
    last_status: Optional[int] = None
    last_meta: Dict[str, Any] = {}

    for attempt in range(1, retry.max_attempts + 1):
        try:
            payload, http_status, response_meta = fetch_fn(request_params)
            last_status = http_status
            last_meta = response_meta or {}

            # treat "empty payload" as failure that can be retried (often transient)
            is_empty = payload is None
            if not is_empty and isinstance(payload, (list, tuple, dict)):
                is_empty = (len(payload) == 0)

            if is_empty:
                reason = classify_empty_response(payload=payload, http_status=http_status)
                last_reason = reason

                rec = FetchAttemptRecord(
                    ts_utc=_utc_now_iso(),
                    symbol=symbol,
                    provider=provider,
                    attempt=attempt,
                    max_attempts=retry.max_attempts,
                    ok=False,
                    request_params=request_params,
                    reason=reason,
                    http_status=http_status,
                    error="",
                    response_meta=response_meta or {},
                    response_snippet=_safe_snippet(payload),
                )
                _write_jsonl(diag_jsonl_path, asdict(rec))

                # decide retry
                if attempt < retry.max_attempts and (not retry_only_transient or reason in transient_reasons):
                    _sleep_backoff(attempt, retry)
                    continue

                raise OptionChainFetchError(f"{symbol}: empty option chain payload ({reason})")

            # success
            return payload

        except Exception as e:
            last_error = e
            reason = classify_empty_response(payload=None, http_status=last_status, error=e)
            last_reason = reason

            rec = FetchAttemptRecord(
                ts_utc=_utc_now_iso(),
                symbol=symbol,
                provider=provider,
                attempt=attempt,
                max_attempts=retry.max_attempts,
                ok=False,
                request_params=request_params,
                reason=reason,
                http_status=last_status,
                error=str(e),
                response_meta=last_meta or {},
                response_snippet="",
            )
            _write_jsonl(diag_jsonl_path, asdict(rec))

            if attempt < retry.max_attempts and (not retry_only_transient or reason in transient_reasons):
                _sleep_backoff(attempt, retry)
                continue

            raise

    # should never reach
    if last_error is not None:
        raise last_error
    raise OptionChainFetchError(f"{symbol}: failed to fetch option chain ({last_reason})")


def _sleep_backoff(attempt: int, retry: RetryConfig) -> None:
    # exponential backoff with jitter
    base = retry.base_sleep_s * (2 ** (attempt - 1))
    sleep_s = min(retry.max_sleep_s, base)
    sleep_s += random.uniform(-retry.jitter_s, retry.jitter_s)
    sleep_s = max(0.0, sleep_s)
    time.sleep(sleep_s)


================================================================================
FILE_PATH: src\trade_guardian\infra\schwab_client.py
================================================================================
from __future__ import annotations

import requests
import numpy as np
import pandas as pd

from datetime import datetime, timedelta, date
from urllib.parse import quote
from typing import Optional, Any, List, Dict, Tuple

from trade_guardian.domain.models import Context, IVData, HVInfo, TermPoint
from trade_guardian.infra.schwab_token_manager import fetch_schwab_token


# =========================================================
# Helpers
# =========================================================

def _to_date(iso: str) -> date:
    return datetime.strptime(iso, "%Y-%m-%d").date()


def is_third_friday(d: date) -> bool:
    # Third Friday: weekday=4 (Fri) and day 15..21
    return d.weekday() == 4 and 15 <= d.day <= 21


def get_series_kind(exp_str: str) -> str:
    d = _to_date(exp_str)
    if is_third_friday(d):
        return "MONTHLY"
    if d.weekday() == 4:
        return "WEEKLY"
    return "DAILY"


def _safe_float(x: Any, default: float = 0.0) -> float:
    try:
        if x is None:
            return default
        return float(x)
    except Exception:
        return default


def _pick_iv(quote_obj: Dict[str, Any]) -> float:
    """
    Schwab chain contract:
      - volatility: é€šå¸¸å°±æ˜¯ IVï¼ˆä½† deep ITM/OTM æˆ– DTE<1 æ—¶å¯èƒ½å¤±çœŸåˆ°å‡ ç™¾%ï¼‰
      - theoreticalVolatility: Schwab ç”¨äºç†è®ºä»·çš„å¹³æ»‘æ³¢åŠ¨ç‡ï¼ˆå¸¸æ›´ç¨³å®šï¼‰

    è§„åˆ™ï¼ˆæŒ‰ä½ ç»™çš„è¯´æ˜ï¼‰ï¼š
      1) ä¼˜å…ˆ volatility
      2) è‹¥ |delta|>0.90 æˆ– <0.10ï¼Œæˆ– DTE<1ï¼Œä¸” volatility ç¦»è°±(>100% æˆ– <1%)ï¼Œ
         ä¸” theoreticalVolatility æ­£å¸¸ï¼Œåˆ™å›é€€ theoreticalVolatility
      3) volatility ç¼ºå¤±/ä¸º0 æ—¶ï¼Œå†å°è¯• impliedVolatility ç­‰å­—æ®µ
    """
    raw_iv = _safe_float(quote_obj.get("volatility", None), 0.0)
    theo_iv = _safe_float(quote_obj.get("theoreticalVolatility", None), 0.0)

    delta = abs(_safe_float(quote_obj.get("delta", None), 0.0))
    dte = _safe_float(quote_obj.get("daysToExpiration", None), -1.0)  # chain é‡Œä¸€èˆ¬æœ‰

    # ç”¨ä¸ä½  build_context ç›¸åŒçš„ heuristic è½¬æˆâ€œç™¾åˆ†æ¯”å°ºåº¦â€æ¥åˆ¤æ–­æ˜¯å¦ç¦»è°±
    def _as_pct(v: float) -> float:
        if 0 < v < 1.5:
            return v * 100.0
        return v

    raw_iv_pct = _as_pct(raw_iv)
    theo_iv_pct = _as_pct(theo_iv)

    extreme_delta = (delta > 0.90) or (0 < delta < 0.10)
    very_short_dte = (dte >= 0 and dte < 1)

    # å¦‚æœ volatility ç¼ºå¤±/ä¸º 0ï¼šå…ˆå°è¯•å…¶ä»– iv å­—æ®µ
    if raw_iv <= 0:
        for k in ("impliedVolatility", "impliedVol", "iv"):
            v = _safe_float(quote_obj.get(k, None), 0.0)
            if v > 0:
                raw_iv = v
                raw_iv_pct = _as_pct(raw_iv)
                break

    # å…³é”®æ¸…æ´—é€»è¾‘ï¼šdeep ITM/OTM æˆ– DTE<1 æ—¶ï¼Œvolatility å¯èƒ½åæ¨å´©æºƒ
    if (extreme_delta or very_short_dte) and theo_iv > 0:
        if (raw_iv_pct > 100.0) or (0 < raw_iv_pct < 1.0):
            return theo_iv  # theo_iv é€šå¸¸æ›´ç¨³å®š

    # æ­£å¸¸æƒ…å†µä¸‹ï¼šè¿”å› volatilityï¼ˆæˆ–å…¶ fallback çš„ impliedVolatilityï¼‰
    return raw_iv if raw_iv > 0 else 0.0


def _pick_mark(quote_obj: Dict[str, Any]) -> float:
    # æ›´ç¡¬çš„ mid fallbackï¼šmark -> (bid+ask)/2 -> last -> 0
    mark = _safe_float(quote_obj.get("mark", None), 0.0)
    if mark > 0:
        return mark
    bid = _safe_float(quote_obj.get("bid", None), 0.0)
    ask = _safe_float(quote_obj.get("ask", None), 0.0)
    if bid > 0 and ask > 0:
        return (bid + ask) / 2.0
    last = _safe_float(quote_obj.get("last", None), 0.0)
    return last if last > 0 else 0.0


# =========================================================
# SchwabClient
# =========================================================

class SchwabClient:
    OPTION_CHAIN_URL = "https://api.schwabapi.com/marketdata/v1/chains"
    QUOTE_URL_TEMPLATE = "https://api.schwabapi.com/marketdata/v1/quotes?symbols={symbols}&fields=quote"
    PRICE_HISTORY_URL = "https://api.schwabapi.com/marketdata/v1/pricehistory"

    def __init__(self, cfg: dict | None = None):
        self.cfg = cfg or {}

    # ----------------------------
    # Basic API
    # ----------------------------

    def _headers(self) -> Dict[str, str]:
        token = fetch_schwab_token()
        if not token:
            raise ValueError("Token fetch failed")
        return {"Authorization": f"Bearer {token}", "Accept": "application/json"}

    def get_quote(self, symbol: str) -> dict:
        encoded = quote(symbol, safe="")
        url = self.QUOTE_URL_TEMPLATE.format(symbols=encoded)
        resp = requests.get(url, headers=self._headers(), timeout=20)
        data = resp.json()
        return data.get(symbol, {}).get("quote", {}) or {}

    def calculate_hv_percentile(self, symbol: str) -> HVInfo:
        try:
            params = {
                "symbol": symbol,
                "periodType": "year",
                "period": 2,
                "frequencyType": "daily",
                "frequency": 1,
            }
            resp = requests.get(self.PRICE_HISTORY_URL, headers=self._headers(), params=params, timeout=30)
            data = resp.json()
            candles = data.get("candles") or []
            if not candles:
                return HVInfo(status="Error")

            df = pd.DataFrame(candles)
            df["close"] = df["close"].astype(float)
            df["log_ret"] = np.log(df["close"] / df["close"].shift(1))
            df["hv"] = df.dropna(subset=["log_ret"])["log_ret"].rolling(window=20).std() * np.sqrt(252) * 100

            current_hv = float(df["hv"].iloc[-1])
            recent = df["hv"].dropna().tail(252)
            hv_low, hv_high = float(recent.min()), float(recent.max())
            hv_rank = (current_hv - hv_low) / (hv_high - hv_low) * 100.0 if hv_high > hv_low else 0.0

            return HVInfo(status="Success", current_hv=current_hv, hv_rank=hv_rank, hv_low=hv_low, hv_high=hv_high)
        except Exception:
            return HVInfo(status="Error")

    def _fetch_chain(self, symbol: str, from_d: str, to_d: str, range_val: str = "ALL") -> dict:
        params = {
            "symbol": symbol,
            "contractType": "ALL",
            "strategy": "SINGLE",
            "range": range_val,
            "fromDate": from_d,
            "toDate": to_d,
        }
        resp = requests.get(self.OPTION_CHAIN_URL, headers=self._headers(), params=params, timeout=30)
        return resp.json() if resp.status_code == 200 else {}

    # ----------------------------
    # Term scan
    # ----------------------------

    def scan_atm_term(self, symbol: str, days: int) -> Tuple[float, List[TermPoint], dict]:
        """
        æ‰«æ term structure ç‚¹ç”¨äº TSFã€‚
        æ¯ä¸ª expiryï¼šå–ç¦»ç°ä»·æœ€è¿‘çš„å‰ N æ¡£ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ª IV>0 çš„ï¼ˆé¿å…æŠŠ 30-45DTE æ‰¹é‡è¯¯æ€ï¼‰ã€‚
        """
        q = self.get_quote(symbol)
        price = _safe_float(q.get("lastPrice") or q.get("last") or q.get("mark"), 0.0)
        if price <= 0:
            raise RuntimeError(f"No price for {symbol}")

        from_date = datetime.now().strftime("%Y-%m-%d")
        to_date = (datetime.now() + timedelta(days=days)).strftime("%Y-%m-%d")

        chain = self._fetch_chain(symbol, from_date, to_date, range_val="ALL")
        call_map = chain.get("callExpDateMap") or {}

        term: List[TermPoint] = []
        TOP_N_STRIKES = int(self.cfg.get("scan", {}).get("atm_probe_strikes", 6) or 6)

        for date_str, strikes_map in sorted(call_map.items()):
            try:
                parts = date_str.split(":")
                date_iso, dte = parts[0], int(parts[1])
            except Exception:
                continue

            if not isinstance(strikes_map, dict) or not strikes_map:
                continue

            strike_items = list(strikes_map.items())

            def _dist(item) -> float:
                try:
                    s_val = float(item[0])
                    return abs(s_val - price)
                except Exception:
                    return 1e18

            strike_items.sort(key=_dist)
            strike_items = strike_items[:max(1, TOP_N_STRIKES)]

            best_data = None
            best_strike = 0.0

            for s_str, contracts in strike_items:
                if not contracts:
                    continue
                c = contracts[0] or {}
                iv = _pick_iv(c)
                if iv <= 0:
                    continue

                best_strike = _safe_float(s_str, 0.0)
                best_data = {
                    "iv": iv,
                    "mark": _pick_mark(c),
                    "delta": _safe_float(c.get("delta"), 0.0),
                    "theta": _safe_float(c.get("theta"), 0.0),
                    "gamma": _safe_float(c.get("gamma"), 0.0),
                }
                break

            if best_data and best_strike > 0:
                term.append(
                    TermPoint(
                        exp=date_iso,
                        exp_date=date_iso,
                        dte=dte,
                        strike=best_strike,
                        iv=best_data["iv"],
                        mark=best_data["mark"],
                        delta=best_data["delta"],
                        theta=best_data["theta"],
                        gamma=best_data["gamma"],
                    )
                )

        return price, term, chain

    # ----------------------------
    # Core: build_context (Anchor vs DiagLong split)
    # ----------------------------

    def _rules(self) -> dict:
        return self.cfg.get("rules", {}) or {}

    def _rget(self, key: str, default: Any) -> Any:
        return self._rules().get(key, default)

    def _select_anchor_point(self, term_points: List[TermPoint], short_point: TermPoint) -> TermPoint:
        """
        Anchorï¼ˆæœˆåº¦é”šç‚¹ï¼‰ï¼šç”¨äº Edge/Shape çš„ç¨³å®šå‚è€ƒç‚¹ã€‚
        âœ… ä¿®æ­£ï¼šä¸»çª—å£é‡Œâ€œåªè¦æœ‰ç‚¹â€å°±ç»ä¸ fallback åˆ°æ›´è¿œï¼›
               å¦‚æœä¸»çª—å£ç‚¹æ•° <3ï¼Œåˆ™ä¸ç”¨ä¸‰ç‚¹æ›²ç‡(sd)ç®—æ³•ï¼Œæ”¹ä¸ºæŒ‰ target_dte è·ç¦»é€‰ï¼ˆå¹¶å°Šé‡ prefer_monthlyï¼‰ã€‚
        """
        min_dte = int(self._rget("anchor_min_dte", self._rget("month_min_dte", 20)))
        max_dte = int(self._rget("anchor_max_dte", self._rget("month_max_dte", 45)))
        fb_max = int(self._rget("anchor_fallback_max_dte", self._rget("month_fallback_max_dte", 90)))
        target = float(self._rget("anchor_target_dte", self._rget("month_target_dte", 35)))
        lam = float(self._rget("anchor_lambda_dist", self._rget("month_lambda_dist", 0.35)))
        prefer_monthly = bool(self._rget("anchor_prefer_monthly", self._rget("month_prefer_monthly", True)))

        pool = [p for p in term_points if min_dte <= int(p.dte) <= max_dte]

        if not pool:
            pool = [p for p in term_points if min_dte <= int(p.dte) <= fb_max]

        if not pool:
            cand = [p for p in term_points if int(p.dte) >= min_dte]
            if cand:
                return min(cand, key=lambda p: abs(int(p.dte) - target))
            return term_points[-1]

        if len(pool) < 3:
            candidates = pool
            if prefer_monthly:
                monthly = [p for p in candidates if get_series_kind(p.exp) == "MONTHLY"]
                if monthly:
                    candidates = monthly
            return min(candidates, key=lambda p: abs(int(p.dte) - target))

        scored: List[Tuple[float, float, TermPoint]] = []
        for i in range(1, len(pool) - 1):
            window = [pool[i - 1].iv, pool[i].iv, pool[i + 1].iv]
            sd = float(np.std(window))
            dist_penalty = abs(int(pool[i].dte) - target) / max(1.0, target)
            score = sd + (lam * dist_penalty)
            scored.append((score, sd, pool[i]))

        scored.sort(key=lambda x: x[0])
        top = scored[: min(5, len(scored))]

        if prefer_monthly:
            for _, _, p in top:
                if get_series_kind(p.exp) == "MONTHLY":
                    return p
        return top[0][2]

    def _select_diag_long_point(self, term_points: List[TermPoint], short_point: TermPoint) -> TermPoint:
        """
        å¯¹è§’çº¿ long legï¼šäº¤æ˜“ç”¨çœŸå®é•¿è…¿ã€‚
        âœ… å¼ºçº¦æŸï¼šlong_dte >= short_dte + diag_long_min_gap_vs_short
        """
        min_dte = int(self._rget("diag_long_min_dte", 45))
        max_dte = int(self._rget("diag_long_max_dte", 75))
        fb_max = int(self._rget("diag_long_fallback_max_dte", 120))
        target = float(self._rget("diag_long_target_dte", 60))
        lam = float(self._rget("diag_long_lambda_dist", 0.25))
        prefer_monthly = bool(self._rget("diag_long_prefer_monthly", False))
        min_gap = int(self._rget("diag_long_min_gap_vs_short", 20))

        min_needed = int(short_point.dte) + max(0, min_gap)

        def eligible(p: TermPoint, hi: int) -> bool:
            return (min_dte <= int(p.dte) <= hi) and (int(p.dte) >= min_needed)

        pool = [p for p in term_points if eligible(p, max_dte)]
        if len(pool) < 3:
            pool = [p for p in term_points if eligible(p, fb_max)]

        if not pool:
            cand = [p for p in term_points if int(p.dte) >= min_needed]
            if cand:
                return min(cand, key=lambda p: abs(int(p.dte) - target))
            return term_points[-1]

        pool_sorted = sorted(
            pool,
            key=lambda p: abs(int(p.dte) - target) + lam * abs(int(p.dte) - target) / max(1.0, target),
        )
        top = pool_sorted[: min(8, len(pool_sorted))]
        if prefer_monthly:
            for p in top:
                if get_series_kind(p.exp) == "MONTHLY":
                    return p
        return top[0]

    def build_context(self, symbol: str, days: int = 600) -> Optional[Context]:
        try:
            hv_info = self.calculate_hv_percentile(symbol)
            if getattr(hv_info, "status", "") == "Error":
                hv_info = HVInfo(current_hv=0.0, hv_rank=50.0)

            price, term_points, raw_chain = self.scan_atm_term(symbol, days)
            if not term_points or len(term_points) < 3:
                return None
            term_points.sort(key=lambda x: int(x.dte))

            for p in term_points:
                if 0 < float(p.iv) < 1.5:
                    p.iv *= 100.0

            nearest_candidates = [p for p in term_points if int(p.dte) >= 1]
            nearest_point = nearest_candidates[0] if nearest_candidates else term_points[0]

            base_rank = int(self.cfg.get("policy", {}).get("base_rank", 1) or 1)
            short_pool = [p for p in term_points if 1 <= int(p.dte) <= 15]
            if short_pool:
                short_point = short_pool[base_rank] if len(short_pool) > base_rank else short_pool[-1]
            else:
                short_point = nearest_point

            nearest_iv_base = float(nearest_point.iv) if float(nearest_point.iv) > 0 else 1.0

            micro_pool = [p for p in term_points if 1 <= int(p.dte) <= 15]
            micro_point = None

            if len(micro_pool) >= 2:
                local_maxima: List[TermPoint] = []
                for i in range(1, len(micro_pool) - 1):
                    if micro_pool[i].iv > micro_pool[i - 1].iv and micro_pool[i].iv > micro_pool[i + 1].iv:
                        local_maxima.append(micro_pool[i])

                if local_maxima:
                    micro_point = max(local_maxima, key=lambda x: x.iv)
                else:
                    def _momentum_score(p: TermPoint) -> float:
                        d_eff = max(1, int(p.dte))
                        return (float(p.iv) - nearest_iv_base) / np.sqrt(d_eff)
                    micro_point = max(micro_pool, key=_momentum_score)

            if not micro_point:
                micro_point = short_point

            anchor_point = self._select_anchor_point(term_points, short_point)
            diag_long_point = self._select_diag_long_point(term_points, short_point)

            IV_FLOOR = 12.0

            regime = "FLAT"
            if float(short_point.iv) > float(anchor_point.iv) * 1.03:
                regime = "BACKWARDATION"
            elif float(anchor_point.iv) > float(short_point.iv) * 1.03:
                regime = "CONTANGO"

            curvature = "SPIKY_FRONT" if float(micro_point.iv) > float(short_point.iv) * 1.10 else "NORMAL"
            is_squeeze = True if (float(micro_point.iv) > float(anchor_point.iv) * 1.05) else False

            tsf = {
                "regime": regime,
                "curvature": curvature,
                "is_squeeze": is_squeeze,

                "short_exp": short_point.exp,
                "short_dte": int(short_point.dte),
                "short_iv": float(short_point.iv),

                "nearest_exp": nearest_point.exp,
                "nearest_dte": int(nearest_point.dte),
                "nearest_iv": float(nearest_point.iv),

                "micro_exp": micro_point.exp,
                "micro_dte": int(micro_point.dte),
                "micro_iv": float(micro_point.iv),

                "month_exp": anchor_point.exp,
                "month_dte": int(anchor_point.dte),
                "month_iv": float(anchor_point.iv),

                "diag_long_exp": diag_long_point.exp,
                "diag_long_dte": int(diag_long_point.dte),
                "diag_long_iv": float(diag_long_point.iv),

                "edge_micro": (float(micro_point.iv) - float(short_point.iv)) / max(IV_FLOOR, float(short_point.iv)),
                "edge_month": (float(anchor_point.iv) - float(short_point.iv)) / max(IV_FLOOR, float(short_point.iv)),
            }

            iv_data = IVData(
                rank=float(hv_info.hv_rank),
                percentile=0.0,
                current_iv=float(short_point.iv),
                hv_rank=float(hv_info.hv_rank),
                current_hv=float(hv_info.current_hv),
            )

            class Metrics:
                pass

            metrics = Metrics()
            metrics.gamma = float(short_point.gamma)
            metrics.delta = float(short_point.delta)
            metrics.theta = float(short_point.theta)

            return Context(
                symbol=symbol,
                price=float(price),
                iv=iv_data,
                hv=iv_data,
                tsf=tsf,
                raw_chain=raw_chain,
                metrics=metrics,
                term=term_points,
            )

        except Exception:
            return None


================================================================================
FILE_PATH: src\trade_guardian\infra\schwab_token_manager.py
================================================================================
# trade_guardian/infra/schwab_token_manager.py
from __future__ import annotations

import os

def fetch_schwab_token() -> str:
    """
    Resolve Schwab OAuth access token.
    Priority:
      1) env SCHWAB_ACCESS_TOKEN
      2) legacy module shipped with this project: schwab_token_manager_legacy.py
      3) legacy global module name: schwab_token_manager (if user has it on PYTHONPATH)
    """
    tok = os.getenv("SCHWAB_ACCESS_TOKEN", "").strip()
    if tok:
        return tok

    # local legacy copy (recommended)
    try:
        from .schwab_token_manager_legacy import fetch_schwab_token as legacy_fetch
        tok = (legacy_fetch() or "").strip()
        if tok:
            return tok
    except Exception:
        pass

    # global legacy name (optional)
    try:
        from schwab_token_manager import fetch_schwab_token as global_fetch  # type: ignore
        tok = (global_fetch() or "").strip()
        if tok:
            return tok
    except Exception:
        pass

    raise RuntimeError(
        "Schwab token not found. "
        "Set env SCHWAB_ACCESS_TOKEN, or copy your old schwab_token_manager.py into "
        "trade_guardian/infra/schwab_token_manager_legacy.py."
    )


================================================================================
FILE_PATH: src\trade_guardian\infra\schwab_token_manager_legacy.py
================================================================================
# File: schwab_token_manager.py

import requests
import json
from typing import Optional

# --- Configuration for API Token Server ---
TOKEN_SERVER = "http://127.0.0.1:5000" # Your local token server URL

def fetch_schwab_token() -> Optional[str]:
    """
    Fetches the Schwab API access token from the local token server.
    This is a central utility function to be used by other data fetcher modules.
    """
    try:
        resp = requests.get(f"{TOKEN_SERVER}/token")
        resp.raise_for_status()
        token_data = resp.json()
        access_token = token_data.get("access_token")
        if not access_token:
            print("Error: 'access_token' key not found in token server response.")
            return None
        return access_token
    except requests.exceptions.RequestException as e:
        print(f"Error fetching Schwab token: {e}")
    except json.JSONDecodeError:
        print(f"Error decoding JSON from token server. Response: {resp.text}")
    return None

# --- Main block for standalone testing ---
if __name__ == "__main__":
    print("--- Testing Schwab Token Manager ---")
    token = fetch_schwab_token()
    if token:
        print("Successfully fetched an access token.")
        # print(f"Token (first 15 chars): {token[:15]}...") # Uncomment for more verbose testing
    else:
        print("Failed to fetch an access token.")
    print("--- Test Complete ---")

================================================================================
FILE_PATH: src\trade_guardian\infra\tickers.py
================================================================================
# src/trade_guardian/infra/tickers.py
from __future__ import annotations

from typing import List
import csv
import os
import re

_VALID = re.compile(r"^[A-Z0-9\.\-\_]+$")  # allow BRK.B, etc.

def load_tickers_csv(path: str) -> List[str]:
    """
    Load tickers from a csv where each line contains a symbol (or first column is symbol).
    Skips:
      - blank lines
      - comment lines starting with # or //
      - header-like tokens: SYMBOL, TICKER, SYM
      - invalid symbols
    """
    if not os.path.exists(path):
        raise FileNotFoundError(f"tickers.csv not found: {path}")

    out: List[str] = []
    with open(path, "r", newline="", encoding="utf-8-sig") as f:
        reader = csv.reader(f)
        for row in reader:
            if not row:
                continue
            sym = (row[0] or "").strip().upper()
            if not sym:
                continue
            if sym.startswith("#") or sym.startswith("//"):
                continue
            if sym in {"SYMBOL", "TICKER", "SYM"}:
                continue
            if not _VALID.match(sym):
                continue
            out.append(sym)

    # de-dup while keeping order
    seen = set()
    uniq: List[str] = []
    for s in out:
        if s not in seen:
            uniq.append(s)
            seen.add(s)
    return uniq


================================================================================
FILE_PATH: src\trade_guardian\infra\__init__.py
================================================================================



================================================================================
FILE_PATH: src\trade_guardian\strategies\auto.py
================================================================================
from __future__ import annotations
from typing import Optional, Tuple
from trade_guardian.domain.models import Context, Recommendation, ScanRow
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.strategies.base import Strategy
from trade_guardian.strategies.diagonal import DiagonalStrategy
from trade_guardian.strategies.long_gamma import LongGammaStrategy
from trade_guardian.strategies.vertical_credit import VerticalCreditStrategy

LEV_ETFS = ["TQQQ", "SQQQ", "SOXL", "SOXS", "TSLL", "TSLS", "NVDL", "LABU", "UVXY"]

class AutoStrategy(Strategy):
    name = "auto"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy
        self.diagonal = DiagonalStrategy(cfg, policy)
        self.long_gamma = LongGammaStrategy(cfg, policy)
        self.vertical = VerticalCreditStrategy(cfg, policy)

    def evaluate(self, ctx: Context) -> ScanRow:
        hv_rank = float(ctx.hv.hv_rank)
        tsf = ctx.tsf
        regime = str(tsf.get("regime", "FLAT"))
        edge_month = float(tsf.get("edge_month", 0.0))
        current_iv = float(ctx.iv.current_iv)
        is_lev_etf = ctx.symbol in LEV_ETFS

        # 1. [å€’æŒ‚ä¿æŠ¤] Backwardation -> å¼ºåˆ¶ Long Gamma (é˜²å®ˆ)
        if regime == "BACKWARDATION":
            row = self.long_gamma.evaluate(ctx)
            row.tag = "LG-DEFENSE"
            return row

        # 2. [æ æ†é™ç»´æ‰“å‡»] æ æ† ETF å¼ºåˆ¶èµ° Vertical
        if is_lev_etf:
            row_vert = self.vertical.evaluate(ctx)
            if row_vert and "FAIL" not in (row_vert.tag or ""):
                return row_vert

        # 3. [ç»“æ„ä¼˜å…ˆ] Edge > 0.20 -> Diagonal (è¿›æ”»)
        if edge_month >= 0.20:
            row_diag = self.diagonal.evaluate(ctx)
            if row_diag and row_diag.meta and "long_strike" in row_diag.meta:
                return row_diag

        # 4. [é«˜æ³¢æ”¶ç§Ÿ] HV Rank > 30 OR IV > 40% -> Vertical
        if hv_rank > 30 or current_iv > 40.0:
            row_vert = self.vertical.evaluate(ctx)
            if row_vert and "FAIL" not in (row_vert.tag or ""):
                return row_vert

        # 5. [ä½æ³¢åšå¼ˆ] HV < 30 -> Long Gamma
        if hv_rank < 30:
            row = self.long_gamma.evaluate(ctx)
            row.tag = "LG-LOWVOL" 
            return row
        
        # 6. [é»˜è®¤å…œåº•]
        row = self.long_gamma.evaluate(ctx)
        row.tag = "LG-BASE"
        return row

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        row = self.evaluate(ctx)
        tag = row.tag or ""
        
        if "DIAG" in tag:
            return self.diagonal.recommend(ctx, min_score, max_risk)
        elif "PCS" in tag or "CCS" in tag or "VERT" in tag or "BULL" in tag or "BEAR" in tag:
            return self.vertical.recommend(ctx, min_score, max_risk)
        else:
            return self.long_gamma.recommend(ctx, min_score, max_risk)

================================================================================
FILE_PATH: src\trade_guardian\strategies\base.py
================================================================================
from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Optional, Tuple

from trade_guardian.domain.models import Context, Recommendation, ScanRow


class Strategy(ABC):
    name: str = "base"

    @abstractmethod
    def evaluate(self, ctx: Context) -> ScanRow:
        raise NotImplementedError

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        """
        Optional: probe ranks to find a tradable short leg.
        For strategies that don't support probing, return (None, "-").
        """
        return None, "-"


================================================================================
FILE_PATH: src\trade_guardian\strategies\blueprint.py
================================================================================
from __future__ import annotations

from typing import Optional, Dict, Any

from trade_guardian.domain.models import Blueprint, OrderLeg


# =============================================================================
# Quote Helpers
# =============================================================================

def _extract_quote_full(chain: Dict[str, Any], side: str, exp: str, strike: float) -> Dict[str, float]:
    """
    Return {"bid": x, "ask": y, "mid": z}.
    - "mid" uses mark if valid (>0), else falls back to (bid+ask)/2 only if both bid/ask > 0.
    - If not found or insufficient data, returns zeros.
    """
    side_key = "callExpDateMap" if side.upper() == "CALL" else "putExpDateMap"
    side_map = chain.get(side_key, {}) or {}

    # Find the matching expiry bucket
    target_key = None
    for k in side_map.keys():
        if str(k).startswith(exp):
            target_key = k
            break
    if not target_key:
        return {"bid": 0.0, "ask": 0.0, "mid": 0.0}

    strikes_map = side_map.get(target_key, {}) or {}

    # Find the matching strike
    quote0 = None
    for s_key, quotes in strikes_map.items():
        try:
            if abs(float(s_key) - float(strike)) < 0.01 and quotes:
                quote0 = quotes[0]
                break
        except Exception:
            continue

    if not quote0:
        return {"bid": 0.0, "ask": 0.0, "mid": 0.0}

    bid = float(quote0.get("bid") or 0.0)
    ask = float(quote0.get("ask") or 0.0)
    mark = float(quote0.get("mark") or 0.0)

    # Hard mid fallback policy:
    # 1) mark if > 0
    # 2) (bid+ask)/2 only if both bid and ask are > 0
    mid = 0.0
    if mark > 0:
        mid = mark
    elif bid > 0 and ask > 0:
        mid = (bid + ask) / 2.0

    return {"bid": bid, "ask": ask, "mid": float(mid)}


def _extract_mid_for(chain: Dict[str, Any], side: str, exp: str, strike: float) -> Optional[float]:
    q = _extract_quote_full(chain=chain, side=side, exp=exp, strike=strike)
    return q["mid"] if q["mid"] > 0 else None


def _extract_greeks_for(chain: Dict[str, Any], side: str, exp: str, strike: float) -> Dict[str, float]:
    side_key = "callExpDateMap" if side.upper() == "CALL" else "putExpDateMap"
    exp_map = chain.get(side_key, {}) or {}

    target_key = None
    for k in exp_map.keys():
        if str(k).startswith(exp):
            target_key = k
            break
    if not target_key:
        return {}

    strikes_map = exp_map.get(target_key, {}) or {}
    quote0 = None
    for s_str, q_list in strikes_map.items():
        try:
            if abs(float(s_str) - float(strike)) < 0.01 and q_list:
                quote0 = q_list[0]
                break
        except Exception:
            continue

    if not quote0:
        return {}

    return {
        "delta": float(quote0.get("delta", 0.0) or 0.0),
        "gamma": float(quote0.get("gamma", 0.0) or 0.0),
        "theta": float(quote0.get("theta", 0.0) or 0.0),
    }


# =============================================================================
# Blueprint Builders
# =============================================================================

def build_diagonal_blueprint(
    *,
    symbol: str,
    underlying: float,
    chain: Dict[str, Any],
    short_exp: str,
    long_exp: str,
    target_short_strike: float,
    target_long_strike: float,
    side: str = "CALL",
) -> Optional[Blueprint]:
    short_mid = _extract_mid_for(chain=chain, side=side, exp=short_exp, strike=target_short_strike)
    long_mid = _extract_mid_for(chain=chain, side=side, exp=long_exp, strike=target_long_strike)

    width = abs(float(target_short_strike) - float(target_long_strike))
    est_debit = 0.0
    error_msg: Optional[str] = None
    note = ""

    if isinstance(short_mid, (int, float)) and isinstance(long_mid, (int, float)):
        est_debit = float(long_mid - short_mid)

        if est_debit > width and width > 0:
            excess = est_debit - width
            note = f"âš ï¸ High Debit (Net Risk: -${excess:.2f}). Vega Play."
        else:
            note = f"Healthy PMCC Setup. Width={width:.2f}"
    else:
        error_msg = "Missing pricing data"

    legs = [
        OrderLeg(symbol=symbol, action="BUY", ratio=1, exp=long_exp, strike=float(target_long_strike), type=side),
        OrderLeg(symbol=symbol, action="SELL", ratio=1, exp=short_exp, strike=float(target_short_strike), type=side),
    ]

    return Blueprint(
        symbol=symbol,
        strategy="DIAGONAL",
        legs=legs,
        est_debit=round(float(est_debit), 2),
        note=note,
        error=error_msg,
    )


def build_straddle_blueprint(
    *,
    symbol: str,
    underlying: float,
    chain: Dict[str, Any],
    exp: str,
) -> Optional[Blueprint]:
    call_map = chain.get("callExpDateMap", {}) or {}

    target_key = None
    for k in call_map.keys():
        if str(k).startswith(exp):
            target_key = k
            break

    if not target_key:
        return Blueprint(symbol=symbol, strategy="STRADDLE", legs=[], est_debit=0.0, error="Expiry Not Found")

    strike_keys = list((call_map.get(target_key, {}) or {}).keys())
    strikes = []
    for s in strike_keys:
        try:
            strikes.append(float(s))
        except Exception:
            continue
    strikes.sort()

    if not strikes:
        return Blueprint(symbol=symbol, strategy="STRADDLE", legs=[], est_debit=0.0, error="No Strikes")

    strike = min(strikes, key=lambda x: abs(float(x) - float(underlying)))

    q_call = _extract_quote_full(chain=chain, side="CALL", exp=exp, strike=strike)
    q_put = _extract_quote_full(chain=chain, side="PUT", exp=exp, strike=strike)

    # Hard liquidity gate: any missing bid/ask => forbid (prevents 0% spread loophole)
    if q_call["bid"] <= 0 or q_call["ask"] <= 0 or q_put["bid"] <= 0 or q_put["ask"] <= 0:
        return Blueprint(
            symbol=symbol,
            strategy="STRADDLE",
            legs=[],
            est_debit=0.0,
            error=f"Missing Quote Data for {strike} (Zero Liquidity)",
        )

    # Hard mid policy: require both legs mid > 0 (mark or valid (bid+ask)/2)
    if q_call["mid"] <= 0 or q_put["mid"] <= 0:
        return Blueprint(
            symbol=symbol,
            strategy="STRADDLE",
            legs=[],
            est_debit=0.0,
            error=f"Zero Mid Price for {strike}",
        )

    est_debit = float(q_call["mid"] + q_put["mid"])

    total_bid = float(q_call["bid"] + q_put["bid"])
    total_ask = float(q_call["ask"] + q_put["ask"])
    total_mid = (total_bid + total_ask) / 2.0

    if total_mid <= 0:
        return Blueprint(symbol=symbol, strategy="STRADDLE", legs=[], est_debit=0.0, error="Zero Mid Price")

    spread_pct = (total_ask - total_bid) / total_mid

    legs = [
        OrderLeg(symbol=symbol, action="BUY", ratio=1, exp=exp, strike=float(strike), type="CALL"),
        OrderLeg(symbol=symbol, action="BUY", ratio=1, exp=exp, strike=float(strike), type="PUT"),
    ]

    bp = Blueprint(
        symbol=symbol,
        strategy="STRADDLE",
        legs=legs,
        est_debit=round(est_debit, 2),
        note="ATM Straddle",
    )

    # meta is always present in models.py (default_factory), so just set it.
    bp.meta["spread_pct"] = float(spread_pct)
    bp.meta["strike"] = float(strike)
    bp.meta["exp"] = str(exp)
    bp.meta["q_call_bid"] = float(q_call["bid"])
    bp.meta["q_call_ask"] = float(q_call["ask"])
    bp.meta["q_put_bid"] = float(q_put["bid"])
    bp.meta["q_put_ask"] = float(q_put["ask"])

    return bp


def build_calendar_blueprint(
    *,
    symbol: str,
    underlying: float,
    chain: Dict[str, Any],
    short_exp: str,
    long_exp: str,
    prefer_side: str = "CALL",
) -> Optional[Blueprint]:
    call_map = chain.get("callExpDateMap", {}) or {}

    target_key = None
    for k in call_map.keys():
        if str(k).startswith(short_exp):
            target_key = k
            break
    if not target_key:
        return None

    strike_keys = list((call_map.get(target_key, {}) or {}).keys())
    strikes = []
    for s in strike_keys:
        try:
            strikes.append(float(s))
        except Exception:
            continue
    strikes.sort()

    if not strikes:
        return None

    strike = min(strikes, key=lambda x: abs(float(x) - float(underlying)))

    short_mid = _extract_mid_for(chain=chain, side=prefer_side, exp=short_exp, strike=strike)
    long_mid = _extract_mid_for(chain=chain, side=prefer_side, exp=long_exp, strike=strike)

    est_debit = 0.0
    error_msg: Optional[str] = None
    if isinstance(short_mid, (int, float)) and isinstance(long_mid, (int, float)):
        est_debit = float(long_mid - short_mid)
    else:
        error_msg = "Missing pricing data"

    legs = [
        OrderLeg(symbol=symbol, action="BUY", ratio=1, exp=long_exp, strike=float(strike), type=prefer_side),
        OrderLeg(symbol=symbol, action="SELL", ratio=1, exp=short_exp, strike=float(strike), type=prefer_side),
    ]

    return Blueprint(
        symbol=symbol,
        strategy="CALENDAR",
        legs=legs,
        est_debit=round(est_debit, 2),
        note="ATM Calendar",
        error=error_msg,
    )


================================================================================
FILE_PATH: src\trade_guardian\strategies\calendar.py
================================================================================
from __future__ import annotations

from typing import Optional, Tuple

from trade_guardian.domain.models import (
    Context,
    Recommendation,
    ScanRow,
    ScoreBreakdown,
    RiskBreakdown,
)
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.domain.scoring import Scoring, ScoringRules


class CalendarStrategy:
    name = "calendar"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy
        rules = ScoringRules(min_edge_short_base=float(cfg["rules"]["min_edge_short_base"]))
        self.scoring = Scoring(rules)

    def _tag(self, regime: str, curvature: str) -> str:
        t = "F" if regime == "FLAT" else ("C" if regime == "CONTANGO" else "B")
        if curvature == "SPIKY_FRONT":
            t += "S"
        return t

    @staticmethod
    def _clamp(x: float, lo: float, hi: float) -> float:
        return max(lo, min(hi, x))

    def _risk_score(
        self,
        ctx: Context,
        *,
        short_dte: int,
        short_gamma: float,
        rank0_dte: int,
        rank0_gamma: float,
        regime: str,
        curvature: str,
        squeeze_ratio: float,
    ) -> tuple[int, RiskBreakdown]:
        """
        Continuous & explainable risk model (0..100):

        base: start at 35 (not 50) so the system has headroom.
        dte: continuous decay with DTE (shorter => higher risk)
        gamma: continuous penalty based on gamma normalized vs front (or max)
        curvature: continuous penalty based on squeeze_ratio (only when SPIKY_FRONT)
        regime: small penalty (BACKWARDATION > CONTANGO > FLAT)
        """
        bd = RiskBreakdown(base=35)

        # -------- DTE penalty (continuous) --------
        # Target behavior (approx):
        #   dte ~ 1-3  => big penalty
        #   dte ~ 6    => medium
        #   dte ~ 10   => smaller
        #   dte >= 21  => near 0
        d = float(max(0, short_dte))
        # smooth curve: 0..~22 then clamp
        dte_pen = 26.0 / (1.0 + (d / 6.5) ** 1.25)  # d=6 => ~14-16 ; d=10 => ~9-11 ; d=20 => ~4
        # extra caution if front expiry is extremely close (weekly Friday effect / 0DTE clusters)
        front_pen = 0.0
        if rank0_dte <= 1:
            front_pen = 6.0
        elif rank0_dte <= 3:
            front_pen = 3.0

        bd.dte = int(round(self._clamp(dte_pen + front_pen, 0.0, 30.0)))

        # -------- Gamma penalty (continuous) --------
        # Normalize gamma: if we have rank0_gamma use it; otherwise fall back to max gamma in eligible term
        denom = rank0_gamma if rank0_gamma and rank0_gamma > 0 else 0.0
        if denom <= 0:
            # fallback: max gamma among term points we have
            try:
                denom = max(float(p.gamma) for p in ctx.term if p.gamma is not None)  # type: ignore
            except Exception:
                denom = 0.0

        g = float(short_gamma) if short_gamma is not None else 0.0
        g_norm = (g / denom) if denom > 0 else 0.0
        g_norm = self._clamp(g_norm, 0.0, 2.0)  # allow >1 if short gamma > front (rare but possible)

        # penalty curve: small when g_norm <=0.3, grows faster after 0.6
        # map roughly into 0..22
        gamma_pen = 22.0 * (g_norm ** 0.75)
        bd.gamma = int(round(self._clamp(gamma_pen, 0.0, 22.0)))

        # -------- Curvature penalty (continuous) --------
        # Use squeeze_ratio: (rank0_iv / base_iv) as a "front spike" severity.
        # Only penalize meaningfully if SPIKY_FRONT and squeeze is above mild threshold.
        curv_pen = 0.0
        if curvature == "SPIKY_FRONT":
            sr = float(squeeze_ratio) if squeeze_ratio is not None else 0.0
            # thresholded linear ramp:
            #  sr <= 1.10 => ~0
            #  sr 1.10..1.80 => 0..10
            curv_pen = 10.0 * self._clamp((sr - 1.10) / 0.70, 0.0, 1.0)

        # [FIX] Issue A: å­—æ®µåä¿®æ­£ä¸º curvature (åŸä¸º curv)
        bd.curvature = int(round(self._clamp(curv_pen, 0.0, 10.0)))

        # -------- Regime penalty (small, not dominating) --------
        # BACKWARDATION means front richer -> short leg can be more dangerous (bigger adverse gamma & gap risk).
        if regime == "BACKWARDATION":
            bd.regime = 4
        elif regime == "CONTANGO":
            bd.regime = 2
        else:
            bd.regime = 0

        # -------- Penalties slot (reserved) --------
        bd.penalties = 0

        # [FIX] Issue A: æ±‡æ€»è®¡ç®—ä¹ŸåŒæ­¥ä¿®æ­£
        total = bd.base + bd.dte + bd.gamma + bd.curvature + bd.regime + bd.penalties
        return int(self._clamp(float(total), 0.0, 100.0)), bd

    def evaluate(self, ctx: Context) -> ScanRow:
        tsf = ctx.tsf
        regime = str(tsf["regime"])
        curvature = str(tsf["curvature"])
        short_exp = str(tsf["short_exp"])
        short_dte = int(tsf["short_dte"])
        short_iv = float(tsf["short_iv"])
        base_iv = float(tsf["base_iv"])
        edge = float(tsf["edge"])
        squeeze_ratio = float(tsf.get("squeeze_ratio", 0.0))

        eligible = [p for p in ctx.term if p.dte >= self.policy.min_dte]
        if not eligible:
            # fallback: no eligible list, treat chosen short as the only reference
            rank0_dte = short_dte
            rank0_gamma = 0.0
            short_gamma = 0.0
        else:
            # rank0 refers to nearest *eligible* expiry (respect MIN_SHORT_DTE policy)
            rank0 = eligible[0]
            rank0_dte = int(rank0.dte)
            rank0_gamma = float(rank0.gamma) if rank0.gamma is not None else 0.0

            # find the chosen short point in eligible chain by matching exp or dte
            short_point = None
            for p in eligible:
                if str(p.exp) == short_exp:
                    short_point = p
                    break
            if short_point is None:
                # fallback by dte match
                for p in eligible:
                    if int(p.dte) == short_dte:
                        short_point = p
                        break
            short_gamma = float(short_point.gamma) if (short_point and short_point.gamma is not None) else 0.0

        score, bd = self.scoring.score_calendar(
            regime=regime,
            curvature=curvature,
            edge=edge,
            hv_rank=ctx.hv.hv_rank,
        )

        risk, rbd = self._risk_score(
            ctx,
            short_dte=short_dte,
            short_gamma=short_gamma,
            rank0_dte=rank0_dte,
            rank0_gamma=rank0_gamma,
            regime=regime,
            curvature=curvature,
            squeeze_ratio=squeeze_ratio,
        )

        tag = self._tag(regime, curvature)

        return ScanRow(
            symbol=ctx.symbol,
            price=float(ctx.price),
            short_exp=short_exp,
            short_dte=short_dte,
            short_iv=short_iv,
            base_iv=base_iv,
            edge=edge,
            hv_rank=float(ctx.hv.hv_rank),
            regime=regime,
            curvature=curvature,
            tag=tag,
            cal_score=int(score),
            short_risk=int(risk),
            score_breakdown=bd,
            risk_breakdown=rbd,
        )

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        """
        Probe ranks base..base+N-1 and return first rank with risk<=max_risk AND score>=min_score.
        If none, return (None, summary).
        """
        ranks = self.policy.probe_ranks()
        eligible = [p for p in ctx.term if p.dte >= self.policy.min_dte]
        if not eligible:
            return None, "-"

        # constants for risk computation
        regime = str(ctx.tsf["regime"])
        curvature = str(ctx.tsf["curvature"])
        squeeze_ratio = float(ctx.tsf.get("squeeze_ratio", 0.0))

        rank0 = eligible[0]
        rank0_dte = int(rank0.dte)
        rank0_gamma = float(rank0.gamma) if rank0.gamma is not None else 0.0

        best_attempt: Optional[Recommendation] = None
        best_summary = "-"

        for rk in ranks:
            if rk < 0 or rk >= len(eligible):
                continue

            p = eligible[rk]
            base_iv = float(ctx.tsf["base_iv"])
            edge = (float(p.iv) / base_iv) if base_iv > 0 else 0.0

            score, bd = self.scoring.score_calendar(
                regime=regime,
                curvature=curvature,
                edge=edge,
                hv_rank=ctx.hv.hv_rank,
            )

            short_gamma = float(p.gamma) if p.gamma is not None else 0.0
            risk, rbd = self._risk_score(
                ctx,
                short_dte=int(p.dte),
                short_gamma=short_gamma,
                rank0_dte=rank0_dte,
                rank0_gamma=rank0_gamma,
                regime=regime,
                curvature=curvature,
                squeeze_ratio=squeeze_ratio,
            )

            tag = self._tag(regime, curvature)

            # [FIX] Issue E: Correctly construct Recommendation object with meta dict
            if score >= min_score and risk <= max_risk:
                meta_data = {
                    "rank": int(rk),
                    "exp": str(p.exp),
                    "dte": int(p.dte),
                    "iv": float(p.iv),
                    "tag": tag,
                    "risk_breakdown": rbd,
                    "squeeze_ratio": squeeze_ratio
                }
                
                rec = Recommendation(
                    strategy="CALENDAR",
                    symbol=ctx.symbol,
                    action="OPEN",
                    rationale=f"Score {score} > {min_score}",
                    entry_price=ctx.price,
                    score=int(score),
                    conviction="MEDIUM",
                    meta=meta_data
                )
                summary = f"ok rk{rk} {p.exp} d{p.dte} e{edge:.2f} s{score} r{risk} {tag}"
                return rec, summary

            # Track best attempt
            if best_attempt is None or score > best_attempt.score:
                meta_data = {
                    "rank": int(rk),
                    "exp": str(p.exp),
                    "dte": int(p.dte),
                    "iv": float(p.iv),
                    "tag": tag,
                    "risk_breakdown": rbd,
                    "squeeze_ratio": squeeze_ratio
                }
                
                best_attempt = Recommendation(
                    strategy="CALENDAR",
                    symbol=ctx.symbol,
                    action="WATCH",
                    rationale="Best attempt",
                    entry_price=ctx.price,
                    score=int(score),
                    conviction="LOW",
                    meta=meta_data
                )
                best_summary = f"best rk{rk} {p.exp} d{p.dte} e{edge:.2f} s{score} r{risk} {tag}"

        return None, best_summary

================================================================================
FILE_PATH: src\trade_guardian\strategies\diagonal.py
================================================================================
from __future__ import annotations

from datetime import datetime, date
from typing import Optional, Tuple, List, Dict, Any

from trade_guardian.domain.models import (
    Context, Recommendation, ScanRow, ScoreBreakdown, RiskBreakdown, Blueprint, TermPoint
)
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.strategies.base import Strategy
from trade_guardian.strategies.blueprint import build_diagonal_blueprint


def _to_date(iso: str) -> date:
    return datetime.strptime(iso, "%Y-%m-%d").date()


def _is_third_friday(d: date) -> bool:
    return d.weekday() == 4 and 15 <= d.day <= 21


def _iv_to_pct(iv: float) -> float:
    """Schwab iv may be 0.xx or already percent; keep consistent with build_context heuristic."""
    v = float(iv or 0.0)
    if 0 < v < 1.5:
        v *= 100.0
    return v


class DiagonalStrategy(Strategy):
    name = "diagonal"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy

        # --- Short leg controls (existing behavior) ---
        diag_cfg = cfg.get("strategies", {}).get("diagonal", {})
        self.short_min_dte = int(diag_cfg.get("short_min_dte", 1))
        self.short_max_dte = int(diag_cfg.get("short_max_dte", 14))
        self.use_rank_0 = bool(diag_cfg.get("use_rank_0_for_short", False))

        # --- NEW: PMCC delta-based strike selection (defaults are conservative) ---
        # short covered call: target ~0.30, stay OTM with small buffer
        self.short_call_delta_target = float(diag_cfg.get("short_call_delta_target", 0.30))
        self.short_call_delta_min = float(diag_cfg.get("short_call_delta_min", 0.15))
        self.short_call_delta_max = float(diag_cfg.get("short_call_delta_max", 0.40))
        self.short_call_otm_min_pct = float(diag_cfg.get("short_call_otm_min_pct", 0.01))  # 1% OTM buffer

        # long call (PMCC): usually ITM delta 0.65~0.85, target ~0.75
        self.long_call_delta_target = float(diag_cfg.get("long_call_delta_target", 0.75))
        self.long_call_delta_min = float(diag_cfg.get("long_call_delta_min", 0.60))
        self.long_call_delta_max = float(diag_cfg.get("long_call_delta_max", 0.90))

        # liquidity sanity
        self.min_bid = float(diag_cfg.get("min_bid", 0.05))
        self.min_oi = int(diag_cfg.get("min_open_interest", 0))

        # --- Long expiry controls (trade long leg selection) ---
        rules = cfg.get("rules", {})
        self.diag_long_min_dte = int(rules.get("diag_long_min_dte", 30))
        self.diag_long_max_dte = int(rules.get("diag_long_max_dte", 45))
        self.diag_long_fallback_max_dte = int(rules.get("diag_long_fallback_max_dte", 90))
        self.diag_long_target_dte = float(rules.get("diag_long_target_dte", 38))
        self.diag_long_lambda_dist = float(rules.get("diag_long_lambda_dist", 0.25))
        self.diag_long_prefer_monthly = bool(rules.get("diag_long_prefer_monthly", False))
        self.diag_long_min_gap_vs_short = int(rules.get("diag_long_min_gap_vs_short", 20))

    @staticmethod
    def _clamp(x: float, lo: float, hi: float) -> float:
        return max(lo, min(hi, x))

    def _term_point_by_exp(self, ctx: Context, exp: str) -> Optional[TermPoint]:
        term: List[TermPoint] = getattr(ctx, "term", []) or []
        for p in term:
            if str(p.exp) == str(exp):
                return p
        return None

    def _pick_diag_long_exp(self, ctx: Context, short_dte: int) -> Optional[str]:
        """
        Trade long leg expiry selector (scheme A).
        Chooses from ctx.term using rules.diag_long_*.
        """
        term: List[TermPoint] = getattr(ctx, "term", []) or []
        if not term:
            return None

        min_dte_eff = max(self.diag_long_min_dte, int(short_dte) + self.diag_long_min_gap_vs_short)

        pool = [p for p in term if min_dte_eff <= int(p.dte) <= self.diag_long_max_dte]
        if not pool:
            pool = [p for p in term if min_dte_eff <= int(p.dte) <= self.diag_long_fallback_max_dte]
        if not pool:
            far = [p for p in term if int(p.dte) >= min_dte_eff]
            if far:
                return max(far, key=lambda x: int(x.dte)).exp
            return None

        if self.diag_long_prefer_monthly:
            monthly = []
            for p in pool:
                try:
                    if _is_third_friday(_to_date(p.exp)):
                        monthly.append(p)
                except Exception:
                    continue
            if monthly:
                pool = monthly

        def score(p: TermPoint) -> float:
            dist = abs(float(p.dte) - self.diag_long_target_dte) / max(1.0, self.diag_long_target_dte)
            return self.diag_long_lambda_dist * dist

        best = min(pool, key=score)
        return best.exp

    # ----------------------------
    # NEW: robust exp_key picker
    # ----------------------------
    @staticmethod
    def _find_exp_key(call_map: Dict[str, Any], exp_iso: str, dte_hint: Optional[int] = None) -> Optional[str]:
        if not call_map:
            return None
        keys = list(call_map.keys())

        # 1) exact startswith match
        for k in keys:
            if str(k).startswith(str(exp_iso)):
                return k

        # 2) dte hint match (handles cases where exp_iso mismatch but DTE aligns)
        if dte_hint is not None:
            best_k = None
            best_dist = 10**9
            for k in keys:
                try:
                    parts = str(k).split(":")
                    dte = int(parts[1]) if len(parts) > 1 else None
                    if dte is None:
                        continue
                    dist = abs(dte - int(dte_hint))
                    if dist < best_dist:
                        best_dist = dist
                        best_k = k
                except Exception:
                    continue
            if best_k is not None:
                return best_k

        # 3) fallback: first key (deterministic by sort)
        return sorted(keys)[0]

    # ----------------------------
    # NEW: strike selection by delta
    # ----------------------------
    def _pick_call_strike_by_delta(
        self,
        chain: dict,
        exp_iso: str,
        spot: float,
        *,
        dte_hint: Optional[int],
        want: str,  # "SHORT" or "LONG"
    ) -> Optional[float]:
        call_map = chain.get("callExpDateMap", {}) or {}
        exp_key = self._find_exp_key(call_map, exp_iso, dte_hint=dte_hint)
        if not exp_key:
            return None

        strikes_map = call_map.get(exp_key, {}) or {}
        if not isinstance(strikes_map, dict) or not strikes_map:
            return None

        candidates: List[Tuple[float, float, float]] = []
        # tuple: (score, strike, delta)

        if want == "SHORT":
            tgt = float(self.short_call_delta_target)
            dmin = float(self.short_call_delta_min)
            dmax = float(self.short_call_delta_max)
            min_strike = float(spot) * (1.0 + float(self.short_call_otm_min_pct))

            for s_str, q_list in strikes_map.items():
                try:
                    strike = float(s_str)
                except Exception:
                    continue
                if strike < min_strike:
                    continue
                if not q_list:
                    continue
                q = q_list[0] or {}
                bid = float(q.get("bid") or 0.0)
                ask = float(q.get("ask") or 0.0)
                oi = int(q.get("openInterest") or 0)

                if bid < self.min_bid or ask <= 0:
                    continue
                if self.min_oi > 0 and oi < self.min_oi:
                    continue

                delta = float(q.get("delta") or 0.0)
                if delta <= 0:
                    continue

                # delta band
                if not (dmin <= delta <= dmax):
                    continue

                # score: primarily delta closeness; add small penalty for being too close to spot
                delta_score = abs(delta - tgt)
                mny_penalty = abs(strike - spot) / max(1.0, spot) * 0.10
                score = delta_score + mny_penalty
                candidates.append((score, strike, delta))

        else:  # want == "LONG"
            tgt = float(self.long_call_delta_target)
            dmin = float(self.long_call_delta_min)
            dmax = float(self.long_call_delta_max)

            for s_str, q_list in strikes_map.items():
                try:
                    strike = float(s_str)
                except Exception:
                    continue
                # ITM / near-ITM: strike <= spot
                if strike > spot:
                    continue
                if not q_list:
                    continue
                q = q_list[0] or {}
                bid = float(q.get("bid") or 0.0)
                ask = float(q.get("ask") or 0.0)
                oi = int(q.get("openInterest") or 0)

                if bid < self.min_bid or ask <= 0:
                    continue
                if self.min_oi > 0 and oi < self.min_oi:
                    continue

                delta = float(q.get("delta") or 0.0)
                if delta <= 0:
                    continue

                if not (dmin <= delta <= dmax):
                    continue

                # score: delta closeness; mild penalty for being too deep ITM (keeps cost reasonable)
                delta_score = abs(delta - tgt)
                depth_penalty = abs(spot - strike) / max(1.0, spot) * 0.05
                score = delta_score + depth_penalty
                candidates.append((score, strike, delta))

        if candidates:
            candidates.sort(key=lambda x: x[0])
            return float(candidates[0][1])

        # fallback (no candidates): keep old simple behavior but safer
        strike_list: List[float] = []
        for s_str in strikes_map.keys():
            try:
                strike_list.append(float(s_str))
            except Exception:
                continue
        if not strike_list:
            return None
        strike_list.sort()

        if want == "SHORT":
            # fallback: choose further OTM than before (>= spot*(1+otm_min_pct))
            min_strike = float(spot) * (1.0 + float(self.short_call_otm_min_pct))
            for s in strike_list:
                if s >= min_strike:
                    return float(s)
            return float(strike_list[-1])

        # LONG fallback: closest ITM strike
        itms = [s for s in strike_list if s <= spot]
        return float(itms[-1]) if itms else float(strike_list[0])

    def _find_strikes_with_exp(
        self, ctx: Context, short_exp: str, long_exp: str, short_dte: int, long_dte_hint: Optional[int]
    ) -> Tuple[Optional[float], Optional[str], Optional[float]]:
        spot = float(ctx.price)
        chain = ctx.raw_chain

        if not short_exp or not long_exp:
            return None, None, None

        # pick short strike by delta (~0.30)
        short_strike = self._pick_call_strike_by_delta(
            chain, short_exp, spot,
            dte_hint=int(short_dte) if short_dte else None,
            want="SHORT",
        )
        if short_strike is None:
            return None, None, None

        # pick long strike by delta (~0.75 ITM)
        long_strike = self._pick_call_strike_by_delta(
            chain, long_exp, spot,
            dte_hint=int(long_dte_hint) if long_dte_hint else None,
            want="LONG",
        )
        if long_strike is None:
            return None, None, None

        # ensure long strike < short strike (standard call diagonal / PMCC)
        if long_strike >= short_strike:
            # force long lower than short
            long_strike = min(long_strike, short_strike - 0.5)

        return float(short_strike), str(long_exp), float(long_strike)

    def evaluate(self, ctx: Context) -> ScanRow:
        tsf = (ctx.tsf or {}).copy()

        hv_rank = float(ctx.hv.hv_rank)
        price = float(ctx.price)

        short_exp = str(tsf.get("short_exp"))
        short_dte = int(tsf.get("short_dte", 0))
        short_iv = float(tsf.get("short_iv", 0.0))

        # rank-0 override (existing behavior)
        nearest_dte = int(tsf.get("nearest_dte", 999))
        if self.use_rank_0 and nearest_dte < short_dte and nearest_dte >= self.short_min_dte:
            short_exp = str(tsf.get("nearest_exp"))
            short_dte = nearest_dte
            short_iv = float(tsf.get("nearest_iv", 0.0))

            tsf["short_exp"] = short_exp
            tsf["short_dte"] = short_dte
            tsf["short_iv"] = short_iv

        # Anchor (structure)
        anchor_exp = str(tsf.get("month_exp"))
        anchor_dte = int(tsf.get("month_dte", 0))
        anchor_iv = float(tsf.get("month_iv", 0.0))
        anchor_edge_month = float(tsf.get("edge_month", 0.0))

        # Scheme A: pick TRADE long expiry from ctx.term
        long_exp_trade = self._pick_diag_long_exp(ctx, short_dte=short_dte)
        if not long_exp_trade:
            long_exp_trade = anchor_exp

        # get long_dte hint for exp_key matching
        tp_long = self._term_point_by_exp(ctx, str(long_exp_trade)) if long_exp_trade else None
        long_dte_hint = int(tp_long.dte) if tp_long and tp_long.dte is not None else None

        # strikes (delta-based)
        short_strike, long_exp, long_strike = self._find_strikes_with_exp(
            ctx, short_exp, str(long_exp_trade), short_dte=short_dte, long_dte_hint=long_dte_hint
        )

        # month_* represents TRADE long leg (same as blueprint)
        IV_FLOOR = 12.0
        month_exp = str(long_exp_trade or "")
        month_dte = 0
        month_iv = 0.0

        tp = self._term_point_by_exp(ctx, month_exp) if month_exp else None
        if tp:
            month_dte = int(tp.dte or 0)
            month_iv = _iv_to_pct(tp.iv)

        if month_iv <= 0:
            month_iv = _iv_to_pct(anchor_iv)

        denom = max(IV_FLOOR, float(short_iv or 0.0) if float(short_iv or 0.0) > 0 else IV_FLOOR)
        edge_month_trade = (float(month_iv) - float(short_iv or 0.0)) / denom

        # Scoring
        bd = ScoreBreakdown(base=50)
        bd.edge = int(self._clamp(edge_month_trade * 80, -20, 40))

        if short_strike and long_strike and long_exp:
            bd.base += 10
        else:
            bd.penalties = -999

        if edge_month_trade < 0:
            bd.regime = -30

        score = bd.base + bd.regime + bd.edge + bd.hv + bd.curvature + bd.penalties
        risk = 30
        if edge_month_trade < 0:
            risk += 40

        tag = "DIAG"
        if edge_month_trade > 0.15:
            tag += "+"

        row = ScanRow(
            symbol=ctx.symbol,
            price=price,
            short_exp=short_exp,
            short_dte=short_dte,
            short_iv=float(short_iv),
            base_iv=float(month_iv),
            edge=float(edge_month_trade),
            hv_rank=hv_rank,
            regime=str(tsf.get("regime")),
            curvature=str(tsf.get("curvature")),
            tag=tag,
            cal_score=int(self._clamp(float(score), 0, 100)),
            short_risk=int(self._clamp(float(risk), 0, 100)),
            score_breakdown=bd,
            risk_breakdown=RiskBreakdown(base=risk),
        )

        if short_strike and long_strike and long_exp:
            bp = build_diagonal_blueprint(
                symbol=ctx.symbol,
                underlying=price,
                chain=ctx.raw_chain,
                short_exp=short_exp,
                long_exp=long_exp,  # == month_exp under scheme A
                target_short_strike=short_strike,
                target_long_strike=long_strike,
                side="CALL",
            )
            row.blueprint = bp

            row.meta = {
                "strategy": "diagonal",
                "short_strike": short_strike,
                "long_exp": long_exp,
                "long_strike": long_strike,
                "est_gamma": float(ctx.metrics.gamma) if ctx.metrics else 0.0,

                "micro_exp": tsf.get("micro_exp"),
                "micro_dte": tsf.get("micro_dte"),
                "micro_iv": tsf.get("micro_iv"),
                "edge_micro": float(tsf.get("edge_micro", 0.0)),

                "month_exp": month_exp,
                "month_dte": month_dte,
                "month_iv": float(month_iv),
                "edge_month": float(edge_month_trade),

                "anchor_exp": anchor_exp,
                "anchor_dte": anchor_dte,
                "anchor_iv": float(_iv_to_pct(anchor_iv)),
                "anchor_edge_month": float(anchor_edge_month),

                "diag_long_exp_src": "term_pick" if long_exp_trade and long_exp_trade != anchor_exp else "anchor_fallback",

                # NEW: expose delta targets (for debugging)
                "short_call_delta_target": self.short_call_delta_target,
                "long_call_delta_target": self.long_call_delta_target,
            }

        return row

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        row = self.evaluate(ctx)
        if row.cal_score < min_score:
            return None, "Score too low"
        if not row.blueprint:
            return None, "Structure build failed"

        rec = Recommendation(
            strategy="DIAGONAL",
            symbol=ctx.symbol,
            action="OPEN DIAGONAL",
            rationale=f"Tactical Diagonal: Edge {row.edge:.2f}",
            entry_price=ctx.price,
            score=row.cal_score,
            conviction="HIGH",
            meta=row.meta,
        )
        return rec, "OK"


================================================================================
FILE_PATH: src\trade_guardian\strategies\hv_calendar.py
================================================================================
from __future__ import annotations

from typing import Optional, Tuple

from trade_guardian.domain.models import Context, Recommendation, ScanRow
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.domain.scoring import Scoring, ScoringRules

# å¤ç”¨ calendar çš„é£é™©è¿ç»­æ¨¡å‹ + explainï¼ˆrisk_breakdownï¼‰
from trade_guardian.strategies.calendar import CalendarStrategy


class HVCalendarStrategy(CalendarStrategy):
    """
    Strategy #2: HV-aware calendar
      - score: calendar score + hv adjust (å†™å…¥ score_breakdown.hv)
      - risk : å¤ç”¨ CalendarStrategy._risk_scoreï¼ˆä½ å½“å‰ç‰ˆæœ¬éœ€è¦ gamma/squeeze ç­‰è¾“å…¥ï¼‰
    """
    name = "hv_calendar"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        super().__init__(cfg, policy)

        rules = ScoringRules(min_edge_short_base=float(cfg["rules"]["min_edge_short_base"]))
        self.scoring = Scoring(rules)

        hv_cfg = ((cfg.get("strategies", {}) or {}).get("hv_calendar", {}) or {})
        hv_rules = (hv_cfg.get("hv_rules", {}) or {})

        self.hv_low_rank = float(hv_rules.get("hv_low_rank", 20.0))
        self.hv_mid_rank = float(hv_rules.get("hv_mid_rank", 50.0))
        self.hv_high_rank = float(hv_rules.get("hv_high_rank", 70.0))

        self.hv_low_bonus = int(hv_rules.get("hv_low_bonus", 10))
        self.hv_mid_bonus = int(hv_rules.get("hv_mid_bonus", 4))
        self.hv_high_penalty = int(hv_rules.get("hv_high_penalty", -4))
        self.hv_extreme_penalty = int(hv_rules.get("hv_extreme_penalty", -10))

    def _hv_adjust(self, hv_rank: float) -> int:
        if hv_rank <= self.hv_low_rank:
            return self.hv_low_bonus
        if hv_rank <= self.hv_mid_rank:
            return self.hv_mid_bonus
        if hv_rank <= self.hv_high_rank:
            return 0
        if hv_rank <= 90.0:
            return self.hv_high_penalty
        return self.hv_extreme_penalty

    @staticmethod
    def _find_point_gamma(ctx: Context, exp: str, dte: int) -> float:
        """
        Best-effort: åœ¨ ctx.term é‡ŒæŒ‰ exp+dte æ‰¾å¯¹åº”ç‚¹çš„ gammaã€‚
        æ‰¾ä¸åˆ°å°±é€€åŒ–ä¸º 0.0ï¼ˆé£é™©æ¨¡å‹ä»å¯è·‘ï¼Œåªæ˜¯ gamma åˆ†é¡¹ä¼šåå°/ä¸º 0ï¼‰ã€‚
        """
        for p in ctx.term:
            if str(p.exp) == str(exp) and int(p.dte) == int(dte):
                try:
                    return float(getattr(p, "gamma", 0.0) or 0.0)
                except Exception:
                    return 0.0
        return 0.0

    @staticmethod
    def _best_effort_squeeze_ratio(ctx: Context) -> float:
        """
        squeeze_ratio åœ¨ä½ é¡¹ç›®é‡Œå¯èƒ½ï¼š
          - å·²ç»ç”± TSFeatureBuilder å†™å…¥ ctx.tsf["squeeze_ratio"]
          - æˆ–è€…æ²¡æœ‰ï¼ˆæ—©å…ˆè¾“å‡ºæ›¾å‡ºç° N/Aï¼‰
        è¿™é‡Œç»Ÿä¸€è¿”å› floatï¼Œç¼ºå¤±å°± 0.0ã€‚
        """
        try:
            v = ctx.tsf.get("squeeze_ratio", 0.0)  # type: ignore
            return float(v) if v is not None else 0.0
        except Exception:
            return 0.0

    def evaluate(self, ctx: Context) -> ScanRow:
        tsf = ctx.tsf
        regime = str(tsf["regime"])
        curvature = str(tsf["curvature"])
        short_exp = str(tsf["short_exp"])
        short_dte = int(tsf["short_dte"])
        short_iv = float(tsf["short_iv"])
        base_iv = float(tsf["base_iv"])
        edge = float(tsf["edge"])
        hv_rank = float(ctx.hv.hv_rank)

        # ---------------- score (HV-aware) ----------------
        score, bd = self.scoring.score_calendar(
            regime=regime,
            curvature=curvature,
            edge=edge,
            hv_rank=hv_rank,
        )
        hv_adj = self._hv_adjust(hv_rank)
        bd.hv = int(hv_adj)
        score = int(score + hv_adj)

        # ---------------- risk (reuse calendar continuous model) ----------------
        eligible = [p for p in ctx.term if int(p.dte) >= int(self.policy.min_dte)]
        rank0_dte = int(eligible[0].dte) if eligible else int(short_dte)
        rank0_gamma = float(getattr(eligible[0], "gamma", 0.0) or 0.0) if eligible else 0.0

        short_gamma = self._find_point_gamma(ctx, exp=short_exp, dte=short_dte)
        squeeze_ratio = self._best_effort_squeeze_ratio(ctx)

        # âœ… å…³é”®ï¼šä¸¥æ ¼æŒ‰ä½ å½“å‰ calendar.py çš„ keyword-only å‚æ•°ç­¾åè°ƒç”¨
        risk, rbd = self._risk_score(
            ctx,
            short_dte=short_dte,
            short_gamma=short_gamma,
            rank0_dte=rank0_dte,
            rank0_gamma=rank0_gamma,
            regime=regime,
            curvature=curvature,
            squeeze_ratio=squeeze_ratio,
        )

        tag = self._tag(regime, curvature)

        row = ScanRow(
            symbol=ctx.symbol,
            price=float(ctx.price),
            short_exp=short_exp,
            short_dte=short_dte,
            short_iv=short_iv,
            base_iv=base_iv,
            edge=edge,
            hv_rank=hv_rank,
            regime=regime,
            curvature=curvature,
            tag=tag,
            cal_score=int(score),
            short_risk=int(risk),
            score_breakdown=bd,
        )

        # renderer ç”¨ getattrï¼Œæ‰€ä»¥æˆ‘ä»¬ç”¨ setattr æŒ‚ä¸Š explain å­—æ®µ
        setattr(row, "risk_breakdown", rbd)
        setattr(row, "squeeze_ratio", squeeze_ratio)

        return row

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        ranks = self.policy.probe_ranks()
        eligible = [p for p in ctx.term if int(p.dte) >= int(self.policy.min_dte)]
        if not eligible:
            return None, "-"

        hv_rank = float(ctx.hv.hv_rank)
        hv_adj = self._hv_adjust(hv_rank)
        squeeze_ratio = self._best_effort_squeeze_ratio(ctx)

        rank0_dte = int(eligible[0].dte)
        rank0_gamma = float(getattr(eligible[0], "gamma", 0.0) or 0.0)

        best: Optional[Recommendation] = None
        best_summary = "-"

        for rk in ranks:
            if rk < 0 or rk >= len(eligible):
                continue

            p = eligible[rk]

            base_iv = float(ctx.tsf["base_iv"])
            edge = (float(p.iv) / base_iv) if base_iv > 0 else 0.0

            regime = str(ctx.tsf["regime"])
            curvature = str(ctx.tsf["curvature"])

            score, bd = self.scoring.score_calendar(regime=regime, curvature=curvature, edge=edge, hv_rank=hv_rank)
            bd.hv = int(hv_adj)
            score = int(score + hv_adj)

            short_gamma = float(getattr(p, "gamma", 0.0) or 0.0)

            risk, rbd = self._risk_score(
                ctx,
                short_dte=int(p.dte),
                short_gamma=short_gamma,
                rank0_dte=rank0_dte,
                rank0_gamma=rank0_gamma,
                regime=regime,
                curvature=curvature,
                squeeze_ratio=squeeze_ratio,
            )

            tag = self._tag(regime, curvature)

            if score >= min_score and risk <= max_risk:
                rec = Recommendation(
                    rec_rank=int(rk),
                    rec_exp=str(p.exp),
                    rec_dte=int(p.dte),
                    rec_iv=float(p.iv),
                    rec_edge=float(edge),
                    rec_score=int(score),
                    rec_risk=int(risk),
                    rec_tag=tag,
                    rec_breakdown=bd,
                )
                setattr(rec, "risk_breakdown", rbd)
                setattr(rec, "squeeze_ratio", squeeze_ratio)

                summary = f"ok rk{rk} {p.exp} d{p.dte} e{edge:.2f} s{score} r{risk} {tag}"
                return rec, summary

            if best is None or score > best.rec_score:
                best = Recommendation(
                    rec_rank=int(rk),
                    rec_exp=str(p.exp),
                    rec_dte=int(p.dte),
                    rec_iv=float(p.iv),
                    rec_edge=float(edge),
                    rec_score=int(score),
                    rec_risk=int(risk),
                    rec_tag=tag,
                    rec_breakdown=bd,
                )
                setattr(best, "risk_breakdown", rbd)
                setattr(best, "squeeze_ratio", squeeze_ratio)
                best_summary = f"best rk{rk} {p.exp} d{p.dte} e{edge:.2f} s{score} r{risk} {tag}"

        return None, best_summary


================================================================================
FILE_PATH: src\trade_guardian\strategies\iron_condor.py
================================================================================
from __future__ import annotations
from typing import Optional, Dict, Any, Tuple, List

from trade_guardian.domain.models import (
    Context, ScanRow, Blueprint, OrderLeg, ScoreBreakdown, RiskBreakdown, Recommendation
)
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.strategies.base import Strategy

class IronCondorStrategy(Strategy):
    """
    Strategy: Iron Condor (Flexible / Wide Wing Mode)
    
    Logic:
      - é»˜è®¤æ¨¡å¼æ”¹ä¸º "Wide Wings" (å³ Synthetic Strangle)ï¼Œé€‚é… IRA è´¦æˆ·ã€‚
      - Sell Legs: ~20 Delta (é«˜èƒœç‡)
      - Buy Legs:  ~05 Delta (æè¿œç«¯ä¿æŠ¤ï¼Œé™ä½ Theta æŸè€—)
    """
    name = "iron_condor" # ä¿æŒåŸæœ‰æ³¨å†Œåï¼Œä¸Šæ¸¸æ— éœ€ä¿®æ”¹

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy
        
        # [æ ¸å¿ƒä¿®æ”¹] å¢åŠ é…ç½®çµæ´»æ€§
        # å¦‚æœ cfg é‡Œæ²¡æœ‰æŒ‡å®š wing_deltaï¼Œé»˜è®¤ä½¿ç”¨ 0.05 (å®½ç¿…è†€/åˆæˆå®½è·¨æ¨¡å¼)
        # å¦‚æœæƒ³åˆ‡å›æ ‡å‡† ICï¼Œåªéœ€åœ¨ config ä¼ å‚ wing_delta=0.10
        self.short_delta = self.cfg.get("short_delta", 0.20)
        # é»˜è®¤å°±æ˜¯æ‚¨æƒ³è¦çš„ 0.05 Delta (å®½ç¿…è†€/é€€ä¼‘è´¦æˆ·æ¨¡å¼)
        self.wing_delta = self.cfg.get("wing_delta", 0.05) 

    def _find_strike_by_delta(self, chain: Dict, exp: str, side: str, target_delta: float) -> Optional[float]:
        map_key = "callExpDateMap" if side == "CALL" else "putExpDateMap"
        exp_map = chain.get(map_key, {})
        
        target_key = None
        for k in exp_map.keys():
            if k.startswith(exp):
                target_key = k
                break
        if not target_key: return None

        best_strike = None
        # [ä¿®æ”¹ç‚¹] ä½¿ç”¨ float('inf') ä»£è¡¨æ­£æ— ç©·å¤§ï¼Œè¿™æ˜¯æœ€æ ‡å‡†çš„å†™æ³•
        min_diff = float('inf') 
        
        strikes_data = exp_map[target_key]
        for s_str, quotes in strikes_data.items():
            try:
                strike = float(s_str)
                quote = quotes[0]
                d = abs(float(quote.get("delta", 0.0))) 
                
                if d < 0.001: continue 
                
                diff = abs(d - target_delta)
                
                # ä»»ä½•å®æ•° diff éƒ½ä¼šå°äº float('inf')ï¼Œé€»è¾‘å®Œç¾
                if diff < min_diff:
                    min_diff = diff
                    best_strike = strike
            except: continue
            
        return best_strike

    def _get_quote_data(self, chain: Dict, exp: str, side: str, strike: float) -> Tuple[float, float]:
        map_key = "callExpDateMap" if side == "CALL" else "putExpDateMap"
        for k, v in chain.get(map_key, {}).items():
            if k.startswith(exp):
                strike_key = f"{strike:.1f}"
                found_quotes = None
                if strike_key in v:
                    found_quotes = v[strike_key]
                else:
                    for s_key, q_list in v.items():
                        if abs(float(s_key) - strike) < 0.01:
                            found_quotes = q_list
                            break
                
                if found_quotes:
                    q = found_quotes[0]
                    px = float(q.get("mark") or (float(q.get("bid",0)) + float(q.get("ask",0)))/2.0)
                    delta = float(q.get("delta", 0.0))
                    return px, delta
        return 0.0, 0.0

    def evaluate(self, ctx: Context) -> ScanRow:
        hv_rank = float(ctx.hv.hv_rank)
        
        exp = ctx.tsf.get("month_exp")
        dte = int(ctx.tsf.get("month_dte", 0))
        
        if not exp or dte < 20:
            return self._empty_row(ctx, score=0, risk=99, note="DTE < 20")

        # [ä½¿ç”¨é…ç½®å‚æ•°]
        s_put_k = self._find_strike_by_delta(ctx.raw_chain, exp, "PUT", self.short_delta)
        l_put_k = self._find_strike_by_delta(ctx.raw_chain, exp, "PUT", self.wing_delta)
        
        s_call_k = self._find_strike_by_delta(ctx.raw_chain, exp, "CALL", self.short_delta)
        l_call_k = self._find_strike_by_delta(ctx.raw_chain, exp, "CALL", self.wing_delta)

        if not all([s_put_k, l_put_k, s_call_k, l_call_k]):
             return self._empty_row(ctx, score=0, risk=99, note="Legs Missing")
        
        price = ctx.price
        # ç®€å•çš„é€»è¾‘æ£€æŸ¥
        if not (l_put_k < s_put_k < price < s_call_k < l_call_k):
             return self._empty_row(ctx, score=0, risk=99, note="Inv Strikes")

        p_sp, d_sp = self._get_quote_data(ctx.raw_chain, exp, "PUT", s_put_k)
        p_lp, d_lp = self._get_quote_data(ctx.raw_chain, exp, "PUT", l_put_k)
        p_sc, d_sc = self._get_quote_data(ctx.raw_chain, exp, "CALL", s_call_k)
        p_lc, d_lc = self._get_quote_data(ctx.raw_chain, exp, "CALL", l_call_k)
        
        credit = (p_sp - p_lp) + (p_sc - p_lc)
        width_put = s_put_k - l_put_k
        width_call = l_call_k - s_call_k
        max_width = max(width_put, width_call)
        
        max_risk = max_width - credit
        if max_risk <= 0: max_risk = 0.1
        
        ror = credit / max_risk

        # [è‡ªåŠ¨é€‚åº”è¯„åˆ†]
        # å¦‚æœæ˜¯å®½ç¿…è†€ (Delta <= 0.05)ï¼ŒRoR é˜ˆå€¼è‡ªåŠ¨é™ä½
        # å¦‚æœæ˜¯æ ‡å‡† IC (Delta >= 0.10)ï¼ŒRoR é˜ˆå€¼ä¿æŒè¾ƒé«˜
        score = 50
        
        if hv_rank > 50: score += 10
        if hv_rank > 80: score += 10
        if hv_rank < 30: score -= 20
        
        if self.wing_delta <= 0.06:
            # === å®½ç¿…è†€è¯„åˆ†æ ‡å‡† (IRA Mode) ===
            if ror > 0.18: score += 15
            elif ror > 0.12: score += 5
            elif ror < 0.10: score -= 15
        else:
            # === æ ‡å‡† IC è¯„åˆ†æ ‡å‡† (Standard Mode) ===
            if ror > 0.30: score += 15
            elif ror > 0.20: score += 5
            elif ror < 0.15: score -= 10
        
        if ctx.tsf.get("regime") == "BACKWARDATION":
            score -= 30 
            
        # æ ¹æ®æ¨¡å¼æ‰“ä¸åŒçš„ Tagï¼Œæ–¹ä¾¿å‰å°åŒºåˆ†
        tag = "IC-WIDE" if self.wing_delta <= 0.06 else "IC-STD"
        if ror > (0.20 if self.wing_delta <= 0.06 else 0.35):
            tag += "-RICH"
        
        legs = [
            OrderLeg(ctx.symbol, "SELL", 1, exp, s_put_k, "PUT"),
            OrderLeg(ctx.symbol, "BUY", 1, exp, l_put_k, "PUT"),
            OrderLeg(ctx.symbol, "SELL", 1, exp, s_call_k, "CALL"),
            OrderLeg(ctx.symbol, "BUY", 1, exp, l_call_k, "CALL"),
        ]
        
        bp = Blueprint(
            symbol=ctx.symbol,
            strategy="IRON_CONDOR", # ä¿æŒåŸæœ‰ç­–ç•¥åï¼Œå…¼å®¹æ•°æ®åº“
            legs=legs,
            est_debit= -round(credit, 2),
            note=f"Wing D.{self.wing_delta:.2f} | Risk ${max_risk:.2f} | RoR {ror:.1%}",
            error=None
        )
        bp.short_greeks = {"delta": d_sc}

        calc_risk = max(0, 100 - score)

        row = ScanRow(
            symbol=ctx.symbol,
            price=ctx.price,
            short_exp=exp,
            short_dte=dte,
            short_iv=ctx.iv.current_iv,
            base_iv=ctx.tsf.get("month_iv", 0),
            edge=ctx.tsf.get("edge_month", 0),
            hv_rank=hv_rank,
            regime=str(ctx.tsf.get("regime")),
            curvature="NORMAL",
            tag=tag,
            cal_score=int(score),
            short_risk=int(calc_risk),
            score_breakdown=ScoreBreakdown(base=50),
            risk_breakdown=RiskBreakdown(base=0),
            meta={
                "credit": credit, 
                "width": max_width,
                "wing_delta": self.wing_delta
            }
        )
        row.blueprint = bp
        return row

    def _empty_row(self, ctx, score, risk, note):
        # ä¿æŒåŸæœ‰ç»“æ„
        bp = Blueprint(
            symbol=ctx.symbol,
            strategy="IC-FAIL",
            legs=[],
            est_debit=0.0,
            error=note,
            note=note
        )
        return ScanRow(
            symbol=ctx.symbol,
            price=ctx.price,
            short_exp="N/A", short_dte=0, short_iv=0.0, base_iv=0.0, edge=0.0, 
            hv_rank=float(ctx.hv.hv_rank), regime="N/A", curvature="N/A", 
            tag="IC-FAIL", cal_score=score, short_risk=risk,
            score_breakdown=ScoreBreakdown(), risk_breakdown=RiskBreakdown(),
            meta={"error": note}, blueprint=bp
        )

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        row = self.evaluate(ctx)
        if row.blueprint and not row.blueprint.error and row.cal_score >= min_score:
             rec = Recommendation(
                strategy="IRON_CONDOR",
                symbol=ctx.symbol,
                action="OPEN",
                rationale=row.blueprint.note,
                entry_price=ctx.price,
                score=row.cal_score,
                conviction="MEDIUM",
                meta=row.meta
             )
             return rec, "OK"
        return None, "Score too low"

================================================================================
FILE_PATH: src\trade_guardian\strategies\long_gamma.py
================================================================================
from __future__ import annotations
from typing import Tuple, List
from trade_guardian.domain.models import Context, ScanRow, ScoreBreakdown, RiskBreakdown, Blueprint
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.strategies.base import Strategy

ETF_LIST = ["SPY", "QQQ", "IWM", "TQQQ", "SQQQ", "SOXL", "SOXS", "TSLL", "TSLS", "NVDL", "UVXY", "TLT"]

class LongGammaStrategy(Strategy):
    name = "long_gamma"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy
        self.rules = cfg.get("rules", {})
        
        self.min_dte_etf = self.rules.get("lg_min_dte_etf", 7)
        self.min_dte_stock = self.rules.get("lg_min_dte_stock", 10)
        self.pin_cap = self.rules.get("pin_risk_cap", 0.25)
        self.pin_coeff = self.rules.get("pin_risk_coeff", 0.3)
        self.max_spread = self.rules.get("lg_max_spread_pct", 0.08)

    @staticmethod
    def _clamp(x: float, lo: float, hi: float) -> float:
        return max(lo, min(hi, x))

    def _strikes_from_chain(self, ctx: Context, exp: str, side: str="CALL") -> List[float]:
        """
        [FIX] ç›´æ¥ä» raw_chain è·å–è¯¥åˆ°æœŸæ—¥çš„æ‰€æœ‰ Strikeï¼Œç”¨äºç®—çœŸå® Step
        """
        key = "callExpDateMap" if side=="CALL" else "putExpDateMap"
        m = ctx.raw_chain.get(key, {}) or {}
        
        target_key = None
        for k in m.keys():
            if k.startswith(exp):
                target_key = k
                break
        
        if target_key and target_key in m:
            return sorted([float(s) for s in m[target_key].keys()])
        return []

    def _get_real_strike_step(self, ctx: Context, exp: str) -> float:
        strikes = self._strikes_from_chain(ctx, exp)
        if len(strikes) < 2: return 1.0

        # åªçœ‹ ATM é™„è¿‘ 10 ä¸ª strike
        center_idx = min(range(len(strikes)), key=lambda i: abs(strikes[i] - ctx.price))
        start = max(0, center_idx - 5)
        end = min(len(strikes), center_idx + 5)
        subset = strikes[start:end]
        
        diffs = [subset[i+1] - subset[i] for i in range(len(subset)-1)]
        if not diffs: return 1.0
        
        # å–æœ€å°æ­£å·®å€¼
        return min(d for d in diffs if d > 0)

    def _check_pin_risk(self, ctx: Context, price: float, dte: int, exp: str) -> Tuple[bool, str]:
        if dte > 3: return False, ""
        
        real_step = self._get_real_strike_step(ctx, exp)
        threshold = min(self.pin_cap, self.pin_coeff * real_step)
        
        nearest_anchor = round(price / real_step) * real_step
        dist = abs(price - nearest_anchor)
        
        if dist < threshold:
            return True, f"Pinned: Dist {dist:.2f} < {threshold:.2f} (Step {real_step})"
            
        return False, ""

    def _empty_row(self, ctx, note):
        bd = ScoreBreakdown(base=0)
        return ScanRow(
            symbol=ctx.symbol, price=float(ctx.price),
            short_exp="N/A", short_dte=0, short_iv=0, base_iv=0, edge=0, hv_rank=0,
            regime="N/A", curvature="N/A", tag="LG-FAIL",
            cal_score=0, short_risk=99,
            score_breakdown=bd, risk_breakdown=RiskBreakdown(),
            meta={"error": note},
            blueprint=Blueprint(ctx.symbol, "LG-FAIL", [], 0.0, error=note, note=note)
        )

    def evaluate(self, ctx: Context) -> ScanRow:
        tsf = ctx.tsf
        symbol = ctx.symbol
        price = float(ctx.price)
        
        short_iv = float(tsf.get("short_iv", 0.0))
        edge_micro = float(tsf.get("edge_micro", 0.0))
        edge_month = float(tsf.get("edge_month", 0.0))
        short_dte = int(tsf.get("short_dte", 0))
        short_exp = str(tsf.get("short_exp", ""))
        
        # 1. DTE Hard Kill
        is_etf = symbol in ETF_LIST
        min_dte = self.min_dte_etf if is_etf else self.min_dte_stock
        has_catalyst = False 
        
        if short_dte < min_dte and not has_catalyst:
            return self._empty_row(ctx, f"DTE {short_dte} < {min_dte} (Theta Risk)")

        # 2. Pin Risk Hard Kill (Data-Driven)
        is_pinned, pin_msg = self._check_pin_risk(ctx, price, short_dte, short_exp)
        if is_pinned:
            return self._empty_row(ctx, pin_msg)

        # 3. è¯„åˆ†é€»è¾‘
        score = 60
        score += int(self._clamp(edge_micro * 40, -20, 20))
        score += int(self._clamp(edge_month * 60, -20, 30))
        score = self._clamp(score, 0, 100)

        # 4. æ„é€  Gate
        gate = "WAIT"
        if score > 75 and edge_micro > 0.05 and edge_month > 0.10:
            gate = "READY"
        
        if symbol in ["TSLL", "TQQQ", "SOXL", "ONDS", "SMCI"]:
             gate = "FORBID"

        tag = "LG"
        if edge_micro > 0.15: tag += "-M"
        if edge_month > 0.30: tag += "-K"

        bd = ScoreBreakdown(base=60) 
        rbd = RiskBreakdown(base=20)
        
        row = ScanRow(
            symbol=symbol,
            price=price,
            short_exp=short_exp,
            short_dte=short_dte,
            short_iv=short_iv,
            base_iv=tsf.get("month_iv", 0.0),
            edge=edge_month,
            hv_rank=50.0,
            regime="NORMAL",
            curvature="FLAT",
            tag=tag,
            cal_score=int(score),
            short_risk=20,
            score_breakdown=bd,
            risk_breakdown=rbd,
        )
        
        row.meta = {
            "micro_exp": tsf.get("micro_exp"),
            "micro_dte": tsf.get("micro_dte"),
            "micro_iv": tsf.get("micro_iv"),
            "edge_micro": edge_micro,
            "month_exp": tsf.get("month_exp"),
            "month_dte": tsf.get("month_dte"),
            "month_iv": tsf.get("month_iv"),
            "edge_month": edge_month,
            "est_gamma": float(ctx.metrics.gamma) * 2.0 if ctx.metrics else 0.0,
            "strike": round(price, 1),
            "max_spread_pct": self.max_spread, # ä¼ é€’ç»™ Orchestrator
            "stop_loss_rules": {
                "type": "time_based",
                "minutes": self.rules.get("lg_time_stop_min", 90),
                "no_move_pct": self.rules.get("lg_no_move_frac", 0.25)
            }
        }
        return row

================================================================================
FILE_PATH: src\trade_guardian\strategies\placeholder.py
================================================================================
from __future__ import annotations

from trade_guardian.domain.models import Context, ScanRow, ScoreBreakdown
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.strategies.base import Strategy


class PlaceholderStrategy(Strategy):
    """
    Strategy #2/#3 placeholder.
    Exists to prove the framework: registry, CLI, orchestrator wiring.
    Not intended for trading logic.
    """
    name = "placeholder"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy

    def evaluate(self, ctx: Context) -> ScanRow:
        bd = ScoreBreakdown(base=0)
        return ScanRow(
            symbol=ctx.symbol,
            price=float(ctx.price),
            short_exp=ctx.tsf.get("short_exp", ""),
            short_dte=int(ctx.tsf.get("short_dte", 0)),
            short_iv=float(ctx.tsf.get("short_iv", 0.0)),
            base_iv=float(ctx.tsf.get("base_iv", 0.0)),
            edge=float(ctx.tsf.get("edge", 0.0)),
            hv_rank=float(ctx.hv.hv_rank),
            regime=str(ctx.tsf.get("regime", "FLAT")),
            curvature=str(ctx.tsf.get("curvature", "NORMAL")),
            tag="NA",
            cal_score=0,
            short_risk=100,
            score_breakdown=bd,
        )


================================================================================
FILE_PATH: src\trade_guardian\strategies\strategy2_stub.py
================================================================================
from typing import Optional, Tuple

from trade_guardian.domain.models import Context, ScanRow, Recommendation, ScoreBreakdown


class Strategy2Stub:
    """
    Reserved for strategy #2. Framework is in place.
    This stub intentionally does not implement real logic yet.
    """
    name = "strategy2"

    def __init__(self, cfg: dict):
        self.cfg = cfg

    def evaluate(self, ctx: Context) -> ScanRow:
        raise NotImplementedError("strategy2 is not implemented yet.")

    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        return None, "-"


================================================================================
FILE_PATH: src\trade_guardian\strategies\vertical_credit.py
================================================================================
from __future__ import annotations
from typing import Optional, Dict, Any, Tuple, List

from trade_guardian.domain.models import (
    Context, ScanRow, Blueprint, OrderLeg, ScoreBreakdown, RiskBreakdown, Recommendation
)
from trade_guardian.domain.policy import ShortLegPolicy
from trade_guardian.strategies.base import Strategy

class VerticalCreditStrategy(Strategy):
    name = "vertical_credit"

    def __init__(self, cfg: dict, policy: ShortLegPolicy):
        self.cfg = cfg
        self.policy = policy

    def _find_strike_by_delta(self, chain: Dict, exp: str, side: str, target_delta: float) -> Optional[float]:
        map_key = "callExpDateMap" if side == "CALL" else "putExpDateMap"
        exp_map = chain.get(map_key, {})
        target_key = None
        for k in exp_map.keys():
            if k.startswith(exp):
                target_key = k
                break
        if not target_key: return None

        best_strike = None
        min_diff = 999.0
        strikes_data = exp_map[target_key]
        for s_str, quotes in strikes_data.items():
            try:
                strike = float(s_str)
                quote = quotes[0]
                d = abs(float(quote.get("delta", 0.0))) 
                if d < 0.01: continue 
                diff = abs(d - target_delta)
                if diff < min_diff:
                    min_diff = diff
                    best_strike = strike
            except: continue
        return best_strike

    def _get_quote_data(self, chain: Dict, exp: str, side: str, strike: float) -> Tuple[float, float]:
        map_key = "callExpDateMap" if side == "CALL" else "putExpDateMap"
        for k, v in chain.get(map_key, {}).items():
            if k.startswith(exp):
                strike_key = f"{strike:.1f}"
                found_quotes = None
                if strike_key in v:
                    found_quotes = v[strike_key]
                else:
                    for s_key, q_list in v.items():
                        if abs(float(s_key) - strike) < 0.01:
                            found_quotes = q_list
                            break
                if found_quotes:
                    q = found_quotes[0]
                    px = float(q.get("mark") or (float(q.get("bid",0)) + float(q.get("ask",0)))/2.0)
                    delta = float(q.get("delta", 0.0))
                    return px, delta
        return 0.0, 0.0

    def evaluate(self, ctx: Context) -> ScanRow:
        hv_rank = float(ctx.hv.hv_rank)
        exp = ctx.tsf.get("month_exp")
        dte = int(ctx.tsf.get("month_dte", 0))
        
        if not exp or dte < 15:
            return self._empty_row(ctx, 0, 99, "DTE < 15")

        side_short = "PUT"
        side_long = "PUT"
        strat_tag = "BULL-PUT" if side_short == "PUT" else "BEAR-CALL"
        
        s_strike = self._find_strike_by_delta(ctx.raw_chain, exp, side_short, 0.30)
        l_strike = self._find_strike_by_delta(ctx.raw_chain, exp, side_long, 0.10)

        if not s_strike or not l_strike:
             return self._empty_row(ctx, 0, 99, "Legs Missing (Delta?)")

        price = ctx.price
        if side_short == "PUT":
            if not (l_strike < s_strike < price):
                 return self._empty_row(ctx, 0, 99, "Inv Strikes (PCS)")
        else:
             if not (price < s_strike < l_strike):
                 return self._empty_row(ctx, 0, 99, "Inv Strikes (CCS)")

        p_s, d_s = self._get_quote_data(ctx.raw_chain, exp, side_short, s_strike)
        p_l, d_l = self._get_quote_data(ctx.raw_chain, exp, side_long, l_strike)
        
        credit = p_s - p_l
        width = abs(s_strike - l_strike)
        max_risk = width - credit
        if max_risk <= 0: max_risk = 0.1
        
        ror = credit / max_risk
        score = 50
        if hv_rank > 50: score += 10
        if ror > 0.25: score += 15
        elif ror > 0.15: score += 5
        
        if score >= 70: strat_tag += "â˜…"
        
        legs = [
            OrderLeg(ctx.symbol, "SELL", 1, exp, s_strike, side_short),
            OrderLeg(ctx.symbol, "BUY", 1, exp, l_strike, side_long)
        ]
        
        bp = Blueprint(
            symbol=ctx.symbol,
            strategy=strat_tag.replace("â˜…", ""),
            legs=legs,
            est_debit= -round(credit, 2),
            note=f"Credit ${credit:.2f} | Risk ${max_risk:.2f} | RoR {ror:.1%}",
            error=None,
            short_greeks={"delta": d_s}
        )

        calc_risk = max(0, 100 - score)
        meta_data = ctx.tsf.copy() if ctx.tsf else {}
        meta_data.update({"credit": credit, "width": width, "est_gamma": 0.0})

        # [FIX] è¿˜åŸä¸º TSF é”šç‚¹
        tsf_short_exp = str(ctx.tsf.get("short_exp", "N/A"))
        tsf_short_dte = int(ctx.tsf.get("short_dte", 0))
        tsf_short_iv = float(ctx.tsf.get("short_iv", 0.0))

        row = ScanRow(
            symbol=ctx.symbol,
            price=ctx.price,
            short_exp=tsf_short_exp,
            short_dte=tsf_short_dte,
            short_iv=tsf_short_iv,
            base_iv=ctx.tsf.get("month_iv", 0),
            edge=ctx.tsf.get("edge_month", 0),
            hv_rank=hv_rank,
            regime=str(ctx.tsf.get("regime")),
            curvature="NORMAL",
            tag=strat_tag,
            cal_score=int(score),
            short_risk=int(calc_risk),
            score_breakdown=ScoreBreakdown(base=50),
            risk_breakdown=RiskBreakdown(base=0),
            meta=meta_data 
        )
        row.blueprint = bp
        return row

    def _empty_row(self, ctx, score, risk, note):
        from trade_guardian.domain.models import ScanRow, Blueprint, ScoreBreakdown, RiskBreakdown
        bp = Blueprint(ctx.symbol, "VERT-FAIL", [], 0.0, error=note, note=note)
        meta_data = ctx.tsf.copy() if ctx.tsf else {}
        meta_data["error"] = note
        return ScanRow(
            symbol=ctx.symbol, price=ctx.price,
            short_exp="N/A", short_dte=0, short_iv=0, base_iv=0, edge=0, hv_rank=0,
            regime="N/A", curvature="N/A", tag="VERT-FAIL",
            cal_score=score, short_risk=risk,
            score_breakdown=ScoreBreakdown(), risk_breakdown=RiskBreakdown(),
            meta=meta_data, blueprint=bp
        )
        
    def recommend(self, ctx: Context, min_score: int, max_risk: int) -> Tuple[Optional[Recommendation], str]:
        row = self.evaluate(ctx)
        if row.blueprint and not row.blueprint.error and row.cal_score >= min_score:
             rec = Recommendation(
                strategy="VERTICAL", symbol=ctx.symbol, action="OPEN",
                rationale=row.blueprint.note, entry_price=ctx.price,
                score=row.cal_score, conviction="MEDIUM", meta=row.meta
             )
             return rec, "OK"
        return None, "Score too low"

================================================================================
FILE_PATH: src\trade_guardian\strategies\__init__.py
================================================================================


================================================================================
FILE_PATH: src\trade_guardian\ui\dashboard.py
================================================================================
import streamlit as st
import pandas as pd
import sqlite3
import os
import sys
import json
import time
from datetime import datetime, timedelta

# ==========================================
# 1. ç¯å¢ƒä¸è·¯å¾„è®¾ç½®
# ==========================================
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.abspath(os.path.join(current_dir, "..", "..", ".."))
sys.path.insert(0, os.path.join(project_root, "src"))

from trade_guardian.infra.config import load_config, DEFAULT_CONFIG
from trade_guardian.infra.schwab_client import SchwabClient
from trade_guardian.action.sniper import Sniper

# ==========================================
# 2. é¡µé¢é…ç½® & CSS
# ==========================================
st.set_page_config(
    page_title="Trade Guardian",
    page_icon="ğŸ›¡ï¸",
    layout="wide",
    initial_sidebar_state="expanded"
)

if "last_refresh_time" not in st.session_state:
    st.session_state.last_refresh_time = time.time()

st.markdown(
    """
<style>
    .block-container {
        padding-top: 1rem !important;
        padding-bottom: 1rem !important;
    }
    .stProgress > div > div > div > div { background-color: #f63366; }

    .sidebar-header {
        display: flex; justify-content: space-between; align-items: center;
        background-color: #262730; padding: 10px 5px; border-radius: 6px; border: 1px solid #444; margin-bottom: 15px;
    }
    .header-item { flex: 1; text-align: center; border-right: 1px solid #555; line-height: 1.2; }
    .header-item:last-child { border-right: none; }
    .header-label { font-size: 0.7rem; color: #aaa; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 2px; }
    .header-value { font-size: 1rem; font-weight: 700; color: #eee; white-space: nowrap; }

    .blueprint-box {
        font-size: 0.85rem; background-color: #1e1e1e; border: 1px solid #333;
        border-radius: 4px; padding: 8px 12px; margin-bottom: 6px;
        display: flex; justify-content: space-between;
    }
    .leg-buy { border-left: 4px solid #00c853; }
    .leg-sell { border-left: 4px solid #f44336; }

    .calc-box {
        background-color: #0e1117; border: 1px solid #4caf50; border-radius: 8px;
        padding: 15px; text-align: center; margin-top: 15px; margin-bottom: 15px;
        box-shadow: 0 0 10px rgba(76, 175, 80, 0.1);
    }
    .calc-title { color: #888; font-size: 0.8rem; letter-spacing: 1px; margin-bottom: 5px; }
    .calc-price { font-size: 2.4rem; font-weight: 700; color: #4caf50; font-family: 'Roboto Mono', monospace; line-height: 1; }
    .calc-sub { font-size: 0.9rem; color: #aaa; margin-top: 5px; }

    div.row-widget.stRadio > div { flex-direction: row; gap: 5px; }
    div.row-widget.stRadio > div[role="radiogroup"] > label {
        background-color: #262730; border: 1px solid #444; padding: 5px 10px;
        border-radius: 4px; flex: 1; text-align: center; justify-content: center;
    }
</style>
""",
    unsafe_allow_html=True
)

# ==========================================
# 3. æ ¸å¿ƒé€»è¾‘
# ==========================================

def _pick_cfg_path() -> str | None:
    candidates = [
        os.path.join(project_root, "config", "config.yaml"),
        os.path.join(project_root, "config", "config.yml"),
        os.path.join(project_root, "config", "config.json"),
    ]
    for p in candidates:
        if os.path.exists(p):
            return p
    return None


@st.cache_resource
def get_sniper():
    cfg_path = _pick_cfg_path()
    if not cfg_path:
        return None
    cfg = load_config(cfg_path, DEFAULT_CONFIG)
    return Sniper(SchwabClient(cfg))


def get_past_batch_id(conn, current_ts_str, minutes_ago):
    try:
        curr_dt = datetime.strptime(current_ts_str, "%Y-%m-%d %H:%M:%S")
        target_dt = curr_dt - timedelta(minutes=minutes_ago)
        target_str = target_dt.strftime("%Y-%m-%d %H:%M:%S")
        row = conn.execute(
            "SELECT batch_id, timestamp FROM scan_batches WHERE timestamp <= ? ORDER BY batch_id DESC LIMIT 1",
            (target_str,)
        ).fetchone()
        return row[0] if row else None
    except Exception:
        return None


@st.cache_data(ttl=10)
def load_radar_with_deltas():
    db_path = os.path.join(project_root, "db", "trade_guardian.db")
    if not os.path.exists(db_path):
        return None, None

    conn = sqlite3.connect(db_path)
    try:
        curr_batch = conn.execute(
            "SELECT batch_id, timestamp, market_vix FROM scan_batches ORDER BY batch_id DESC LIMIT 1"
        ).fetchone()
        if not curr_batch:
            return None, None
        curr_id, curr_ts, vix = curr_batch

        id_10m = get_past_batch_id(conn, curr_ts, 10)
        id_1h = get_past_batch_id(conn, curr_ts, 60)

        # âœ… NEW: rank_score ç”¨äºæ’åºï¼ˆWAIT ç½šåˆ†ï¼‰ï¼Œä½† UI ä»æ˜¾ç¤º cal_score
        # ä½ å¯ä»¥éšæ—¶è°ƒæ•´è¿™äº›å¸¸æ•°ï¼šWAIT æ›´é åå°±æŠŠ -40 æ”¹æˆ -80 ç­‰ã€‚
        query_main = """
            SELECT
                s.symbol, s.price, s.iv_short, s.edge, s.regime,
                p.strategy_type, p.tag, p.cal_score, p.gate_status, p.blueprint_json,
                (p.cal_score + CASE p.gate_status
                    WHEN 'EXEC'   THEN 120
                    WHEN 'LIMIT'  THEN 40
                    WHEN 'WAIT'   THEN -40
                    WHEN 'FORBID' THEN -200
                    ELSE -60
                END) AS rank_score
            FROM market_snapshots s
            JOIN trade_plans p ON s.snapshot_id = p.snapshot_id
            WHERE s.batch_id = ?
            ORDER BY rank_score DESC, p.cal_score DESC
        """
        df = pd.read_sql_query(query_main, conn, params=(curr_id,))

        df["d_10m"] = 0.0
        df["d_1h"] = 0.0

        if id_10m:
            df_10 = pd.read_sql_query(
                "SELECT symbol, price FROM market_snapshots WHERE batch_id = ?",
                conn,
                params=(id_10m,)
            )
            merged = df.merge(df_10, on="symbol", how="left", suffixes=("", "_old"))
            df["d_10m"] = merged["price"] - merged["price_old"]

        if id_1h:
            df_1h = pd.read_sql_query(
                "SELECT symbol, price FROM market_snapshots WHERE batch_id = ?",
                conn,
                params=(id_1h,)
            )
            merged = df.merge(df_1h, on="symbol", how="left", suffixes=("", "_old"))
            df["d_1h"] = merged["price"] - merged["price_old"]

        df["d_10m"] = df["d_10m"].fillna(0.0)
        df["d_1h"] = df["d_1h"].fillna(0.0)

        return df, (curr_ts, vix)
    finally:
        conn.close()


# ==========================================
# 4. ç•Œé¢æ¸²æŸ“
# ==========================================

st.title("ğŸ›¡ï¸ Trade Guardian Command Center")

if "auto_refresh" not in st.session_state:
    st.session_state.auto_refresh = True

df, metadata = load_radar_with_deltas()
auto_ref = False

if df is not None:
    ts, vix = metadata

    vix_val = float(vix)
    vix_label = "NORMAL"
    vix_color = "#ffd700"
    if vix_val < 15:
        vix_color = "#00c853"
        vix_label = "LOW"
    elif 20 <= vix_val < 25:
        vix_color = "#ff9800"
        vix_label = "ELEVATED"
    elif vix_val >= 25:
        vix_color = "#f44336"
        vix_label = "PANIC"

    col1, col2, col3, col4, col5 = st.columns([1.5, 1.5, 1.5, 1, 1])

    col1.markdown(
        f"""
        <div style="background-color: #262730; padding: 10px; border-radius: 5px; border-left: 5px solid {vix_color};">
            <div style="font-size: 0.8rem; color: #aaa;">MARKET VIX</div>
            <div style="font-size: 1.5rem; font-weight: bold; color: white;">{vix:.2f} <span style="font-size:0.8rem; color:{vix_color}">({vix_label})</span></div>
        </div>
        """,
        unsafe_allow_html=True
    )

    col2.metric("Scan Time", ts.split(" ")[1])
    col3.metric("Candidates", len(df))

    if col4.button("ğŸ”„ Refresh"):
        load_radar_with_deltas.clear()
        st.session_state.last_refresh_time = time.time()
        st.rerun()

    auto_ref = col5.checkbox("Auto (5min)", value=st.session_state.auto_refresh)
    st.session_state.auto_refresh = auto_ref

    # --- ä¸»è¡¨æ ¼ ---
    display_df = df.copy()

    def format_delta(val):
        if val > 0:
            return f"ğŸŸ¢ +{val:.2f}"
        elif val < 0:
            return f"ğŸ”´ {val:.2f}"
        else:
            return f"âšª {val:.2f}"

    display_df["Î”10m"] = display_df["d_10m"].apply(format_delta)
    display_df["Î”1h"] = display_df["d_1h"].apply(format_delta)

    # æ³¨æ„ï¼šrank_score ä¸å±•ç¤ºï¼Œåªç”¨äºæ’åºï¼ˆå·²ç»åœ¨ SQL é‡Œæ’å¥½äº†ï¼‰
    cols = [
        "symbol", "price", "Î”10m", "Î”1h", "iv_short", "edge", "regime",
        "strategy_type", "tag", "gate_status", "cal_score", "blueprint_json"
    ]
    cols = [c for c in cols if c in display_df.columns]
    display_df = display_df[cols]

    column_cfg = {
        "blueprint_json": None,
        "cal_score": st.column_config.ProgressColumn("Score", min_value=0, max_value=100, format="%d"),
        "symbol": st.column_config.TextColumn("Symbol", width="small"),
        "price": st.column_config.NumberColumn("Price", format="$%.2f"),
        "edge": st.column_config.NumberColumn("Edge", format="%.2f"),
        "iv_short": st.column_config.NumberColumn("IV", format="%.1f%%"),
    }

    event = st.dataframe(
        display_df,
        width="stretch",
        hide_index=True,
        column_config=column_cfg,
        selection_mode="single-row",
        on_select="rerun",
        height=700,
        key="radar_master"
    )

    # --- ä¾§è¾¹æ  ---
    if len(event.selection.rows) > 0:
        selected_index = event.selection.rows[0]
        row = df.iloc[selected_index]
        symbol = row["symbol"]
        bp_json_raw = row["blueprint_json"]

        with st.sidebar:
            st.markdown(f"## ğŸ”­ Scope: **{symbol}**")

            gate_color = "#00c853" if row["gate_status"] == "EXEC" else (
                "#ffeb3b" if row["gate_status"] == "LIMIT" else "#f44336"
            )

            strat_display = row["strategy_type"]

            st.markdown(
                f"""
                <div class="sidebar-header">
                    <div class="header-item"><div class="header-label">STRATEGY</div><div class="header-value">{strat_display}</div></div>
                    <div class="header-item"><div class="header-label">TAG</div><div class="header-value">{row['tag']}</div></div>
                    <div class="header-item"><div class="header-label">GATE</div><div class="header-value" style="color: {gate_color};">{row['gate_status']}</div></div>
                </div>
                """,
                unsafe_allow_html=True
            )

            bp_valid = False
            short_exp, short_strike = None, 0.0
            long_exp, long_strike = None, 0.0
            target_strategy = "STRADDLE"

            if bp_json_raw:
                try:
                    bp_data = json.loads(bp_json_raw)
                    legs = bp_data.get("legs", [])
                    if legs:
                        bp_valid = True
                        if "DIAGONAL" in str(row["strategy_type"]).upper() or "DIAGONAL" in str(row["tag"]).upper():
                            target_strategy = "DIAGONAL"
                            for leg in legs:
                                cls = "leg-buy" if leg["action"] == "BUY" else "leg-sell"
                                icon = "ğŸŸ¢" if leg["action"] == "BUY" else "ğŸ”´"
                                st.markdown(
                                    f"""<div class="blueprint-box {cls}"><span>{icon} <b>{leg['action']} {leg['ratio']}x</b></span><span>{leg['exp']}</span><span><b>{leg['strike']} {leg['type']}</b></span></div>""",
                                    unsafe_allow_html=True
                                )
                                if leg["action"] == "SELL":
                                    short_exp = leg["exp"]
                                    short_strike = float(leg["strike"])
                                elif leg["action"] == "BUY":
                                    long_exp = leg["exp"]
                                    long_strike = float(leg["strike"])
                        else:
                            target_strategy = "STRADDLE"
                            for leg in legs:
                                cls = "leg-buy" if leg["action"] == "BUY" else "leg-sell"
                                st.markdown(
                                    f"""<div class="blueprint-box {cls}"><span>{leg['action']} {leg['ratio']}x</span><span>{leg['exp']}</span><span><b>{leg['strike']} {leg['type']}</b></span></div>""",
                                    unsafe_allow_html=True
                                )
                            if legs:
                                short_exp = legs[0]["exp"]
                                short_strike = float(legs[0]["strike"])
                except Exception as e:
                    st.error(f"Blueprint Error: {e}")

            st.divider()
            urgency = st.radio(
                "Pricing Mode",
                ["PASSIVE", "NEUTRAL", "AGGRESSIVE"],
                horizontal=True,
                label_visibility="collapsed"
            )

            limit_price_display, est_cost_display, is_ready = "---", "---", False

            if bp_valid and short_exp:
                try:
                    sniper = get_sniper()
                    if sniper:
                        res = sniper.lock_target(
                            symbol=symbol,
                            strategy=target_strategy,
                            short_exp=short_exp,
                            short_strike=short_strike,
                            long_exp=long_exp,
                            long_strike=long_strike,
                            urgency=urgency
                        )
                        if res.get("status") == "READY":
                            is_ready = True
                            limit_price_display = f"${res['limit_price']:.2f}"
                            est_cost_display = f"${res['est_cost']:.0f}"
                        else:
                            st.error(res.get("msg", "Sniper returned FAIL"))
                    else:
                        st.error("Sniper not initialized. Check config/config.yaml path & load_config.")
                except Exception as e:
                    st.error(f"Pricing Error: {e}")

            st.markdown(
                f"""<div class="calc-box"><div class="calc-title">CALCULATED LIMIT ({urgency})</div><div class="calc-price">{limit_price_display}</div><div class="calc-sub">Est. Cost: {est_cost_display}</div></div>""",
                unsafe_allow_html=True
            )

            c1, c2 = st.columns([4, 1])
            with c1:
                if st.button(
                    "ğŸš€ SEND ORDER TO BROKER",
                    type="primary",
                    use_container_width=True,
                    disabled=not is_ready
                ):
                    st.toast(f"Order Sent! {symbol} @ {limit_price_display}", icon="âœ…")
            with c2:
                if st.button("ğŸ”„"):
                    st.rerun()

    else:
        with st.sidebar:
            st.info("ğŸ‘ˆ Select a target from the radar.")

else:
    st.warning("âš ï¸ No scan data found. Please run `python src/trade_guardian.py scanlist` first.")

# å€’è®¡æ—¶é€»è¾‘
if auto_ref:
    time_elapsed = time.time() - st.session_state.last_refresh_time
    time_remaining = 300 - int(time_elapsed)

    if time_remaining <= 0:
        load_radar_with_deltas.clear()
        st.session_state.last_refresh_time = time.time()
        st.rerun()
    else:
        countdown_box = st.empty()
        for i in range(time_remaining, 0, -5):
            countdown_box.caption(f"â³ Auto-refresh in **{i}** seconds...")
            time.sleep(5)
        st.rerun()


================================================================================
FILE_PATH: src\trade_guardian.egg-info\dependency_links.txt
================================================================================



================================================================================
FILE_PATH: src\trade_guardian.egg-info\requires.txt
================================================================================
requests
pandas
numpy
tabulate
colorama


================================================================================
FILE_PATH: src\trade_guardian.egg-info\SOURCES.txt
================================================================================
pyproject.toml
src/trade_guardian/__init__.py
src/trade_guardian.egg-info/PKG-INFO
src/trade_guardian.egg-info/SOURCES.txt
src/trade_guardian.egg-info/dependency_links.txt
src/trade_guardian.egg-info/requires.txt
src/trade_guardian.egg-info/top_level.txt
src/trade_guardian/app/__init__.py
src/trade_guardian/app/cli.py
src/trade_guardian/app/orchestrator.py
src/trade_guardian/app/renderer.py
src/trade_guardian/domain/__init__.py
src/trade_guardian/domain/features.py
src/trade_guardian/domain/hv.py
src/trade_guardian/domain/models.py
src/trade_guardian/domain/policy.py
src/trade_guardian/domain/registry.py
src/trade_guardian/domain/scoring.py
src/trade_guardian/infra/__init__.py
src/trade_guardian/infra/cache.py
src/trade_guardian/infra/config.py
src/trade_guardian/infra/rate_limit.py
src/trade_guardian/infra/schwab_client.py
src/trade_guardian/infra/schwab_token_manager.py
src/trade_guardian/infra/tickers.py
src/trade_guardian/strategies/__init__.py
src/trade_guardian/strategies/base.py
src/trade_guardian/strategies/calendar.py
src/trade_guardian/strategies/placeholder.py
src/trade_guardian/strategies/strategy2_stub.py

================================================================================
FILE_PATH: src\trade_guardian.egg-info\top_level.txt
================================================================================
trade_guardian

